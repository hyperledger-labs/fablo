// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose.sh 1`] = `
"#!/bin/bash
SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

source \\"$BASEDIR\\"/fabric-compose/scripts/lib/oo-bootstrap.sh

source \\"$BASEDIR\\"/fabric-compose/scripts/base-help.sh
source \\"$BASEDIR\\"/fabric-compose/scripts/base-functions.sh
source \\"$BASEDIR\\"/fabric-compose/commands-generated.sh

source \\"$BASEDIR\\"/fabric-compose/.env

if [ \\"$1\\" = \\"up\\" ]; then
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"recreate\\" ]; then
  networkDown
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"down\\" ]; then
  networkDown
elif [ \\"$1\\" = \\"start\\" ]; then
  startNetwork
elif [ \\"$1\\" = \\"stop\\" ]; then
  stopNetwork
elif [ \\"$1\\" = \\"chaincodes\\" ] && [ \\"$2\\" = \\"install\\" ]; then
  installChaincodes
elif [ \\"$1\\" = \\"help\\" ]; then
  printHelp
elif [ \\"$1\\" = \\"--help\\" ]; then
  printHelp
else
  echo \\"No command specified\\"
  echo \\"Basic commands are: up, down, start, stop, recreate\\"
  echo \\"Also check: 'chaincodes install'\\"
  echo \\"Use 'help' or '--help' for more information\\"
fi
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/.env 1`] = `
"COMPOSE_PROJECT_NAME=network
FABRIC_VERSION=1.4.3
LOGGING_LEVEL=info

ROOT_CA_ADMIN_NAME=admin
ROOT_CA_ADMIN_PASSWORD=adminpw

ORG1_CA_ADMIN_NAME=admin
ORG1_CA_ADMIN_PASSWORD=adminpw

"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/commands-generated.sh 1`] = `
"SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

function installChaincodes() {
  
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F60E\\"
    chaincodeInstall \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" # TODO to mi sie nie podoba. a gdzie uprawnienia ?
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F618\\"
    chaincodeInstantiate \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\"
    
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer1\\" \\"U1F60E\\"
    chaincodeInstall \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer1.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" # TODO to mi sie nie podoba. a gdzie uprawnienia ?
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer1\\" \\"U1F618\\"
    chaincodeInstantiate \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer1.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\"
    
}

function generateArtifacts() {
  printHeadline \\"Generating basic configs\\" \\"U1F913\\"
  printItalics \\"Generating crypto material for org Orderer\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-root.yaml\\" \\"ordererOrganizations/root.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org1\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org1.yaml\\" \\"peerOrganizations/org1.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating genesis block\\" \\"U1F3E0\\"
  genesisBlockCreate \\"$BASEDIR/fabric-config\\" \\"$BASEDIR/fabric-config/config\\"
}

function startNetwork() {
  printHeadline \\"Starting network\\" \\"U1F680\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose up -d
  cd $CURRENT_DIR
  sleep 4
}

function stopNetwork() {
  printHeadline \\"Stopping network\\" \\"U1F68F\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose stop
  cd $CURRENT_DIR
  sleep 4
}

function generateChannelsArtifacts() {
    printHeadline \\"Generating config for 'my-channel1'\\" \\"U1F913\\"
  createChannelTx \\"my-channel1\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
  }

function installChannels() {
  
    
    printHeadline \\"Creating 'my-channel1' on Org1/peer0\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoin 'my-channel1' 'Org1MSP' 'peer0.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'orderer0.root.com:7050';\\"
  
    
    printItalics \\"Joining 'my-channel1' on  Org1/peer1\\" \\"U1F638\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoin 'my-channel1' 'Org1MSP' 'peer1.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'orderer0.root.com:7050';\\"
  
        }

function networkDown() {
  printHeadline \\"Destroying network\\" \\"U1F916\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose down
  cd $CURRENT_DIR

  printf \\"\\\\nRemoving chaincode containers & images... \\\\U1F5D1 \\\\n\\"
   
  docker rm -f $(docker ps -a | grep dev-peer0.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  docker rm -f $(docker ps -a | grep dev-peer1.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer1.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  printf \\"\\\\nRemoving generated configs... \\\\U1F5D1 \\\\n\\"
  rm -rf $BASEDIR/fabric-config/config
  rm -rf $BASEDIR/fabric-config/crypto-config

  printHeadline \\"Done! Network was purged\\" \\"U1F5D1\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/docker-compose.yaml 1`] = `
"version: '2.2'

networks:
  basic:

services:
  
  ca.root.com:
    container_name: ca.root.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.root.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.root.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7030:7054
    command: sh -c 'fabric-ca-server start -b \${ROOT_CA_ADMIN_NAME}:\${ROOT_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  orderer0.root.com:
    container_name: orderer0.root.com
    image: hyperledger/fabric-orderer:\${FABRIC_VERSION}
    environment:
      - ORDERER_GENERAL_LOGLEVEL=\${LOGGING_LEVEL}
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/config/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      - GODEBUG=netdns=go
      
    working_dir: /var/hyperledger/orderer
    command: orderer
    ports:
      - 7040:7050
    volumes:
      - ../fabric-config/config/:/var/hyperledger/config
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/msp/:/var/hyperledger/orderer/msp
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/tls/:/var/hyperledger/orderer/tls
    networks:
      - basic
    
  
  ca.org1.com:
    container_name: ca.org1.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org1.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7031:7054
    command: sh -c 'fabric-ca-server start -b \${ORG1_CA_ADMIN_NAME}:\${ORG1_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org1.com:
    container_name: cli.org1.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org1.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org1.com/msp
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
      
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org1.com:
    container_name: peer0.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7051:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org1.com:
    container_name: peer1.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer1.org1.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7052:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/base-functions.sh 1`] = `
"import util/log
import util/tryCatch

function certsGenerate() {
  local CONTAINER_NAME=certsGenerate

  local CONFIG_PATH=$1
  local CRYPTO_CONFIG_FILE_NAME=$2
  local ORG_PATH=$3
  local OUTPUT_PATH=$4
  local FULL_CERT_PATH=$OUTPUT_PATH$ORG_PATH

  echo \\"Generating certs...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CRYPTO_CONFIG_FILE_NAME: $CRYPTO_CONFIG_FILE_NAME\\"
  inputLog \\"ORG_PATH: $ORG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"FULL_CERT_PATH: $FULL_CERT_PATH\\"

  if [ -d \\"$FULL_CERT_PATH\\" ]; then
    echo \\"Can't generate certs, directory already exists : $FULL_CERT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME cryptogen generate --config=./fabric-config/$CRYPTO_CONFIG_FILE_NAME

    docker cp $CONTAINER_NAME:/crypto-config/. $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }

  removeContainer $CONTAINER_NAME
  for file in $(find $OUTPUT_PATH/ -iname *_sk); do dir=$(dirname $file); mv \${dir}/*_sk \${dir}/priv-key.pem; done
}

function genesisBlockCreate() {
  local CONTAINER_NAME=genesisBlockCreate

  local CONFIG_PATH=$1
  local OUTPUT_PATH=$2

  echo \\"Creating genesis block...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"

  if [ -d \\"$OUTPUT_PATH\\" ]; then
    echo \\"Cant't generate genesis block, directory already exists : $OUTPUT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile SoloOrdererGenesis -outputBlock ./config/genesis.block || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createChannelTx() {
  local CONTAINER_NAME=createChannelTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local CHANNEL_TX_PATH=$OUTPUT_PATH\\"/\\"$CHANNEL_NAME\\".tx\\"

  echo \\"Creating channelTx for $CHANNEL_NAME...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CONFIG_PROFILE: $CONFIG_PROFILE\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"CHANNEL_TX_PATH: $CHANNEL_TX_PATH\\"

  if [ -f \\"$CHANNEL_TX_PATH\\" ]; then
    echo \\"Can't create channel configuration, it already exists : $CHANNEL_TX_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputCreateChannelTx ./config/channel.tx -channelID \${CHANNEL_NAME} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/channel.tx $CHANNEL_TX_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createAnchorPeerUpdateTx() {
  local CONTAINER_NAME=createAnchorPeerUpdateTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local MSP=$5
  local ANCHOR_PEER_UPDATE_PATH=$OUTPUT_PATH\\"/\\"$MSP\\"anchors.tx\\"

  if [ -f \\"$ANCHOR_PEER_UPDATE_PATH\\" ]; then
    echo \\"Cant't create anchor peer update, it already exists : $ANCHOR_PEER_UPDATE_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputAnchorPeersUpdate ./config/\${MSP}anchors.tx -channelID \${CHANNEL_NAME} -asOrg \${MSP} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/\${MSP}anchors.tx $ANCHOR_PEER_UPDATE_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function chaincodeInstall() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"
  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation. Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiate() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate. Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function chaincodeInstallTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8
  local CA_CERT=\\"/var/hyperledger/cli/\\"$9

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation (TLS). Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiateTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}
  local CA_CERT=\\"/var/hyperledger/cli/\\"\${11}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate (TLS). Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function printHeadline() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Bold)============ %b %s %b ==============$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function printItalics() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Italics)==== %b %s %b ====$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function inputLog() {
  echo \\"$(UI.Color.DarkGray)   $1 $(UI.Color.Default)\\"
}

function certsRemove() {
  local CERTS_DIR_PATH=$1
  rm -rf \\"$CERTS_DIR_PATH\\"/*
}

function removeContainer() {
  CONTAINER_NAME=$1
  docker rm -f \\"$CONTAINER_NAME\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/base-help.sh 1`] = `
"function printHelp() {
  echo \\"Fabrikka is powered by SoftwareMill\\"

  echo \\"\\"
  echo \\"usage: ./fabric-compose.sh <command>\\"
  echo \\"\\"

  echo \\"Commands: \\"
  echo \\"\\"
  echo \\"./fabric-compose.sh up\\"
  echo -e \\"\\\\t Use for first run. Creates all needed artifacts (certs, genesis block) and starts network for the first time.\\"
  echo -e \\"\\\\t After 'up' commands start/stop are used to manage network and rerun to rerun it\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh down\\"
  echo -e \\"\\\\t Back to empty state - destorys created containers, prunes generated certificates, configs.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh start\\"
  echo -e \\"\\\\t Starts already created network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh stop\\"
  echo -e \\"\\\\t Stops already running network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh recreate\\"
  echo -e \\"\\\\t Fresh start - it destorys whole network, certs, configs and then reruns everything.\\"
  echo \\"\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/cli/channel_fns.sh 1`] = `
"function createChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-createChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx
  peer channel join -b \${CHANNEL_NAME}.block

  rm -rf $DIR_NAME
}

function createChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-createChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}

function fetchChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-fetchChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL}
  peer channel join -b \${CHANNEL_NAME}_newest.block

  rm -rf $DIR_NAME
}

function fetchChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-fetchChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL} --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}_newest.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Contains.sh 1`] = `
"Array::Contains() {
  local element
  for element in \\"\${@:2}\\"
  do
    [[ \\"$element\\" = \\"$1\\" ]] && return 0
  done
  return 1
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Intersect.sh 1`] = `
"import util/namedParameters util/type

Array::Intersect() {
  @required [array] arrayA
  @required [array] arrayB

  array intersection

  # http://stackoverflow.com/questions/2312762/compare-difference-of-two-arrays-in-bash
  for i in \\"\${arrayA[@]}\\"
  do
    local skip=
    for j in \\"\${arrayB[@]}\\"
    do
      [[ \\"$i\\" == \\"$j\\" ]] && { skip=1; break; }
    done
    [[ -n $skip ]] || intersection+=(\\"$i\\")
  done

  @get intersection
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/List.sh 1`] = `
"import util/namedParameters

## generates a list separated by new lines
Array::List() {
  @required [string] variableName
  [string] separator=$'\\\\n'

  local indirectAccess=\\"\${variableName}[*]\\"
  (
    local IFS=\\"$separator\\"
    echo \\"\${!indirectAccess}\\"
  )
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Reverse.sh 1`] = `
"import util/namedParameters

## TODO: consider making Parameters::Methods
## since this actually modifies parameters, not arrays

## static methods should be Array::Method, with capital letter

# static version
Array::Reverse() {
  [...rest] this

  local -i length=\${#this[@]}  #$(this length)
  local -a outArray
  local -i indexFromEnd
  local -i index

  for index in \\"\${!this[@]}\\"
  do
    indexFromEnd=$(( $length - 1 - $index ))
    outArray+=( \\"\${this[$indexFromEnd]}\\" )
  done

  @get outArray
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/GetSpaces.sh 1`] = `
"String::GetSpaces() {
  local howMany=\\"$1\\"

  if [[ \\"$howMany\\" -gt 0 ]]
  then
    ( printf \\"%*s\\" \\"$howMany\\" )
  fi
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/IsNumber.sh 1`] = `
"String::IsNumber() {
  local input=\\"$1\\"

  local regex='^-?[0-9]+([.][0-9]+)?$'
  if ! [[ \\"$input\\" =~ $regex ]]
  then
    return 1
  fi
  return 0
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/SanitizeForVariable.sh 1`] = `
"String::SanitizeForVariableName() {
  local type=\\"$1\\"
  echo \\"\${type//[^a-zA-Z0-9]/_}\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/SlashReplacement.sh 1`] = `
"String::ReplaceSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slash$slash/$slashReplacement}\\"
}

String::RestoreSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slashReplacement/$slash}\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/UUID.sh 1`] = `
"String::GenerateUUID() {
  ## https://gist.github.com/markusfisch/6110640
  local N B C='89ab'

  for (( N=0; N < 16; ++N ))
  do
    B=$(( $RANDOM%256 ))

    case $N in
      6)
        printf '4%x' $(( B%16 ))
      ;;
      8)
        printf '%c%x' \${C:$RANDOM%\${#C}:1} $(( B%16 ))
      ;;
      3 | 5 | 7 | 9)
        printf '%02x-' $B
      ;;
      *)
        printf '%02x' $B
      ;;
    esac
  done
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Color.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  alias UI.Color.Default=\\"echo \\\\$'\\\\033[0m'\\"

  alias UI.Color.Black=\\"echo \\\\$'\\\\033[0;30m'\\"
  alias UI.Color.Red=\\"echo \\\\$'\\\\033[0;31m'\\"
  alias UI.Color.Green=\\"echo \\\\$'\\\\033[0;32m'\\"
  alias UI.Color.Yellow=\\"echo \\\\$'\\\\033[0;33m'\\"
  alias UI.Color.Blue=\\"echo \\\\$'\\\\033[0;34m'\\"
  alias UI.Color.Magenta=\\"echo \\\\$'\\\\033[0;35m'\\"
  alias UI.Color.Cyan=\\"echo \\\\$'\\\\033[0;36m'\\"
  alias UI.Color.LightGray=\\"echo \\\\$'\\\\033[0;37m'\\"

  alias UI.Color.DarkGray=\\"echo \\\\$'\\\\033[0;90m'\\"
  alias UI.Color.LightRed=\\"echo \\\\$'\\\\033[0;91m'\\"
  alias UI.Color.LightGreen=\\"echo \\\\$'\\\\033[0;92m'\\"
  alias UI.Color.LightYellow=\\"echo \\\\$'\\\\033[0;93m'\\"
  alias UI.Color.LightBlue=\\"echo \\\\$'\\\\033[0;94m'\\"
  alias UI.Color.LightMagenta=\\"echo \\\\$'\\\\033[0;95m'\\"
  alias UI.Color.LightCyan=\\"echo \\\\$'\\\\033[0;96m'\\"
  alias UI.Color.White=\\"echo \\\\$'\\\\033[0;97m'\\"

  # flags
  alias UI.Color.Bold=\\"echo \\\\$'\\\\033[1m'\\"
  alias UI.Color.Dim=\\"echo \\\\$'\\\\033[2m'\\"
  alias UI.Color.Italics=\\"echo \\\\$'\\\\033[3m'\\"
  alias UI.Color.Underline=\\"echo \\\\$'\\\\033[4m'\\"
  alias UI.Color.Blink=\\"echo \\\\$'\\\\033[5m'\\"
  alias UI.Color.Invert=\\"echo \\\\$'\\\\033[7m'\\"
  alias UI.Color.Invisible=\\"echo \\\\$'\\\\033[8m'\\"

  alias UI.Color.NoBold=\\"echo \\\\$'\\\\033[21m'\\"
  alias UI.Color.NoDim=\\"echo \\\\$'\\\\033[22m'\\"
  alias UI.Color.NoItalics=\\"echo \\\\$'\\\\033[23m'\\"
  alias UI.Color.NoUnderline=\\"echo \\\\$'\\\\033[24m'\\"
  alias UI.Color.NoBlink=\\"echo \\\\$'\\\\033[25m'\\"
  alias UI.Color.NoInvert=\\"echo \\\\$'\\\\033[27m'\\"
  alias UI.Color.NoInvisible=\\"echo \\\\$'\\\\033[28m'\\"
else
  alias UI.Color.Default=\\"echo\\"

  alias UI.Color.Black=\\"echo\\"
  alias UI.Color.Red=\\"echo\\"
  alias UI.Color.Green=\\"echo\\"
  alias UI.Color.Yellow=\\"echo\\"
  alias UI.Color.Blue=\\"echo\\"
  alias UI.Color.Magenta=\\"echo\\"
  alias UI.Color.Cyan=\\"echo\\"
  alias UI.Color.LightGray=\\"echo\\"

  alias UI.Color.DarkGray=\\"echo\\"
  alias UI.Color.LightRed=\\"echo\\"
  alias UI.Color.LightGreen=\\"echo\\"
  alias UI.Color.LightYellow=\\"echo\\"
  alias UI.Color.LightBlue=\\"echo\\"
  alias UI.Color.LightMagenta=\\"echo\\"
  alias UI.Color.LightCyan=\\"echo\\"
  alias UI.Color.White=\\"echo\\"

  # flags
  alias UI.Color.Bold=\\"echo\\"
  alias UI.Color.Dim=\\"echo\\"
  alias UI.Color.Underline=\\"echo\\"
  alias UI.Color.Blink=\\"echo\\"
  alias UI.Color.Invert=\\"echo\\"
  alias UI.Color.Invisible=\\"echo\\"

  alias UI.Color.NoBold=\\"echo\\"
  alias UI.Color.NoDim=\\"echo\\"
  alias UI.Color.NoUnderline=\\"echo\\"
  alias UI.Color.NoBlink=\\"echo\\"
  alias UI.Color.NoInvert=\\"echo\\"
  alias UI.Color.NoInvisible=\\"echo\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  alias UI.Powerline.PointingArrow=\\"echo -e $'\\\\u27a1'\\"
  alias UI.Powerline.ArrowLeft=\\"echo -e $'\\\\u25c0'\\"
  alias UI.Powerline.ArrowRight=\\"echo -e $'\\\\u25b6'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo -e $'\\\\u2198'\\"
  alias UI.Powerline.ArrowDown=\\"echo -e $'\\\\u2B07'\\"
  alias UI.Powerline.PlusMinus=\\"echo -e $'\\\\ue00b1'\\"
  alias UI.Powerline.Branch=\\"echo -e $'\\\\ue0a0'\\"
  alias UI.Powerline.RefersTo=\\"echo -e $'\\\\u27a6'\\"
  alias UI.Powerline.OK=\\"echo -e $'\\\\u2714'\\"
  alias UI.Powerline.Fail=\\"echo -e $'\\\\u2718'\\"
  alias UI.Powerline.Lightning=\\"echo -e $'\\\\u26a1'\\"
  alias UI.Powerline.Cog=\\"echo -e $'\\\\u2699'\\"
  alias UI.Powerline.Heart=\\"echo -e $'\\\\u2764'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo -e $'\\\\u2b50'\\"
  alias UI.Powerline.Saxophone=\\"echo -e $'\\\\U1F3B7'\\"
  alias UI.Powerline.ThumbsUp=\\"echo -e $'\\\\U1F44D'\\"
else
  alias UI.Powerline.PointingArrow=\\"echo '~'\\"
  alias UI.Powerline.ArrowLeft=\\"echo '<'\\"
  alias UI.Powerline.ArrowRight=\\"echo '>'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo '>'\\"
  alias UI.Powerline.ArrowDown=\\"echo '_'\\"
  alias UI.Powerline.PlusMinus=\\"echo '+-'\\"
  alias UI.Powerline.Branch=\\"echo '|}'\\"
  alias UI.Powerline.RefersTo=\\"echo '*'\\"
  alias UI.Powerline.OK=\\"echo '+'\\"
  alias UI.Powerline.Fail=\\"echo 'x'\\"
  alias UI.Powerline.Lightning=\\"echo '!'\\"
  alias UI.Powerline.Cog=\\"echo '{*}'\\"
  alias UI.Powerline.Heart=\\"echo '<3'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo '*''\\"
  alias UI.Powerline.Saxophone=\\"echo '(YEAH)'\\"
  alias UI.Powerline.ThumbsUp=\\"echo '(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Color.var.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  UI_Color_Default=$'\\\\033[0m'

  UI_Color_Black=$'\\\\033[0;30m'
  UI_Color_Red=$'\\\\033[0;31m'
  UI_Color_Green=$'\\\\033[0;32m'
  UI_Color_Yellow=$'\\\\033[0;33m'
  UI_Color_Blue=$'\\\\033[0;34m'
  UI_Color_Magenta=$'\\\\033[0;35m'
  UI_Color_Cyan=$'\\\\033[0;36m'
  UI_Color_LightGray=$'\\\\033[0;37m'

  UI_Color_DarkGray=$'\\\\033[0;90m'
  UI_Color_LightRed=$'\\\\033[0;91m'
  UI_Color_LightGreen=$'\\\\033[0;92m'
  UI_Color_LightYellow=$'\\\\033[0;93m'
  UI_Color_LightBlue=$'\\\\033[0;94m'
  UI_Color_LightMagenta=$'\\\\033[0;95m'
  UI_Color_LightCyan=$'\\\\033[0;96m'
  UI_Color_White=$'\\\\033[0;97m'

  # flags
  UI_Color_Bold=$'\\\\033[1m'
  UI_Color_Dim=$'\\\\033[2m'
  UI_Color_Italics=$'\\\\033[3m'
  UI_Color_Underline=$'\\\\033[4m'
  UI_Color_Blink=$'\\\\033[5m'
  UI_Color_Invert=$'\\\\033[7m'
  UI_Color_Invisible=$'\\\\033[8m'

  UI_Color_NoBold=$'\\\\033[21m'
  UI_Color_NoDim=$'\\\\033[22m'
  UI_Color_NoItalics=$'\\\\033[23m'
  UI_Color_NoUnderline=$'\\\\033[24m'
  UI_Color_NoBlink=$'\\\\033[25m'
  UI_Color_NoInvert=$'\\\\033[27m'
  UI_Color_NoInvisible=$'\\\\033[28m'
else
  UI_Color_Default=\\"\\"

  UI_Color_Black=\\"\\"
  UI_Color_Red=\\"\\"
  UI_Color_Green=\\"\\"
  UI_Color_Yellow=\\"\\"
  UI_Color_Blue=\\"\\"
  UI_Color_Magenta=\\"\\"
  UI_Color_Cyan=\\"\\"
  UI_Color_LightGray=\\"\\"

  UI_Color_DarkGray=\\"\\"
  UI_Color_LightRed=\\"\\"
  UI_Color_LightGreen=\\"\\"
  UI_Color_LightYellow=\\"\\"
  UI_Color_LightBlue=\\"\\"
  UI_Color_LightMagenta=\\"\\"
  UI_Color_LightCyan=\\"\\"
  UI_Color_White=\\"\\"

  # flags
  UI_Color_Bold=\\"\\"
  UI_Color_Dim=\\"\\"
  UI_Color_Italics=\\"\\"
  UI_Color_Underline=\\"\\"
  UI_Color_Blink=\\"\\"
  UI_Color_Invert=\\"\\"
  UI_Color_Invisible=\\"\\"

  UI_Color_NoBold=\\"\\"
  UI_Color_NoDim=\\"\\"
  UI_Color_NoItalics=\\"\\"
  UI_Color_NoUnderline=\\"\\"
  UI_Color_NoBlink=\\"\\"
  UI_Color_NoInvert=\\"\\"
  UI_Color_NoInvisible=\\"\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  UI_Powerline_PointingArrow=$'\\\\u27a1'
  UI_Powerline_ArrowLeft=$'\\\\ue0b2'
  UI_Powerline_ArrowRight=$'\\\\ue0b0'
  UI_Powerline_ArrowRightDown=$'\\\\u2198'
  UI_Powerline_ArrowDown=$'\\\\u2B07'
  UI_Powerline_PlusMinus=$'\\\\ue00b1'
  UI_Powerline_Branch=$'\\\\ue0a0'
  UI_Powerline_RefersTo=$'\\\\u27a6'
  UI_Powerline_OK=$'\\\\u2714'
  UI_Powerline_Fail=$'\\\\u2718'
  UI_Powerline_Lightning=$'\\\\u26a1'
  UI_Powerline_Cog=$'\\\\u2699'
  UI_Powerline_Heart=$'\\\\u2764'

  # colorful
  UI_Powerline_Star=$'\\\\u2b50'
  UI_Powerline_Saxophone=$'\\\\U1F3B7'
  UI_Powerline_ThumbsUp=$'\\\\U1F44D'
else
  UI_Powerline_PointingArrow=\\"'~'\\"
  UI_Powerline_ArrowLeft=\\"'<'\\"
  UI_Powerline_ArrowRight=\\"'>'\\"
  UI_Powerline_ArrowRightDown=\\"'>'\\"
  UI_Powerline_ArrowDown=\\"'_'\\"
  UI_Powerline_PlusMinus=\\"'+-'\\"
  UI_Powerline_Branch=\\"'|}'\\"
  UI_Powerline_RefersTo=\\"'*'\\"
  UI_Powerline_OK=\\"'+'\\"
  UI_Powerline_Fail=\\"'x'\\"
  UI_Powerline_Lightning=\\"'!'\\"
  UI_Powerline_Cog=\\"'{*}'\\"
  UI_Powerline_Heart=\\"'<3'\\"

  # colorful
  UI_Powerline_Star=\\"'*''\\"
  UI_Powerline_Saxophone=\\"'(YEAH)'\\"
  UI_Powerline_ThumbsUp=\\"'(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Console.sh 1`] = `
"import UI/Color

Console::WriteStdErr() {
  # http://stackoverflow.com/questions/2990414/echo-that-outputs-to-stderr
  cat <<< \\"$*\\" 1>&2
  return
}

Console::WriteStdErrAnnotated() {
  local script=\\"$1\\"
  local lineNo=$2
  local color=$3
  local type=$4
  shift; shift; shift; shift

  Console::WriteStdErr \\"$color[$type] $(UI.Color.Blue)[\${script}:\${lineNo}]$(UI.Color.Default) $* \\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Cursor.sh 1`] = `
"import util/class

class:UI.Cursor() {
  # http://askubuntu.com/questions/366103/saving-more-corsor-positions-with-tput-in-bash-terminal
	# http://unix.stackexchange.com/questions/88296/get-vertical-cursor-position

	private integer x
	private integer y

  UI.Cursor.capture() {
    local x
    local y
    IFS=';' read -sdR -p $'\\\\E[6n' y x

    this y = $(( \${y#*[} - 1 ))
    this x = $(( \${x} - 1 ))

    @return
  }

  UI.Cursor.restore() {
    [integer] shift=1

    local -i totalHeight=$(tput lines)
    local -i y=$(this y)
    local -i x=$(this x)

    (( $y + 1 == $totalHeight )) && y+=-$shift

    tput cup $y $x

    @return
  }
}

Type::Initialize UI.Cursor
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/oo-bootstrap.sh 1`] = `
"#!/usr/bin/env bash

###########################
### BOOTSTRAP FUNCTIONS ###
###########################

if [[ -n \\"\${__INTERNAL_LOGGING__:-}\\" ]]
then
  alias DEBUG=\\":; \\"
else
  alias DEBUG=\\":; #\\"
fi

System::SourceHTTP() {
  local URL=\\"$1\\"
  local -i RETRIES=3
  shift

  if hash curl 2>/dev/null
  then
    builtin source <(curl --fail -sL --retry $RETRIES \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && curl --fail -sL --retry $RETRIES \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  else
    builtin source <(wget -t $RETRIES -O - -o /dev/null \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && wget -t $RETRIES -O - -o /dev/null \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  fi
  __oo__importedFiles+=( \\"$URL\\" )
}

System::SourcePath() {
  local libPath=\\"$1\\"
  shift
  # echo trying $libPath
  if [[ -d \\"$libPath\\" ]]
  then
    local file
    for file in \\"$libPath\\"/*.sh
    do
      System::SourceFile \\"$file\\" \\"$@\\"
    done
  else
    System::SourceFile \\"$libPath\\" \\"$@\\" || System::SourceFile \\"\${libPath}.sh\\" \\"$@\\"
  fi
}

declare -g __oo__fdPath=$(dirname <(echo))
declare -gi __oo__fdLength=$(( \${#__oo__fdPath} + 1 ))

System::ImportOne() {
  local libPath=\\"$1\\"
  local __oo__importParent=\\"\${__oo__importParent-}\\"
  local requestedPath=\\"$libPath\\"
  shift

  if [[ \\"$requestedPath\\" == 'github:'* ]]
  then
    requestedPath=\\"https://raw.githubusercontent.com/\${requestedPath:7}\\"
  elif [[ \\"$requestedPath\\" == './'* ]]
  then
    requestedPath=\\"\${requestedPath:2}\\"
  elif [[ \\"$requestedPath\\" == \\"$__oo__fdPath\\"* ]] # starts with /dev/fd
  then
    requestedPath=\\"\${requestedPath:$__oo__fdLength}\\"
  fi

  # [[ \\"$__oo__importParent\\" == 'http://'* || \\"$__oo__importParent\\" == 'https://'* ]] &&
  if [[ \\"$requestedPath\\" != 'http://'* && \\"$requestedPath\\" != 'https://'* ]]
  then
    requestedPath=\\"\${__oo__importParent}/\${requestedPath}\\"
  fi

  if [[ \\"$requestedPath\\" == 'http://'* || \\"$requestedPath\\" == 'https://'* ]]
  then
    __oo__importParent=$(dirname \\"$requestedPath\\") System::SourceHTTP \\"$requestedPath\\"
    return
  fi

  # try relative to parent script
  # try with parent
  # try without parent
  # try global library
  # try local library
  {
    local localPath=\\"$( cd \\"\${BASH_SOURCE[1]%/*}\\" && pwd )\\"
    localPath=\\"\${localPath}/\${libPath}\\"
    System::SourcePath \\"\${localPath}\\" \\"$@\\"
  } || \\\\
  System::SourcePath \\"\${requestedPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__libPath}/\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__path}/\${libPath}\\" \\"$@\\" || e=\\"Cannot import $libPath\\" throw
}

System::Import() {
  local libPath
  for libPath in \\"$@\\"
  do
    System::ImportOne \\"$libPath\\"
  done
}

File::GetAbsolutePath() {
  # http://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
  # $1 : relative filename
  local file=\\"$1\\"
  if [[ \\"$file\\" == \\"/\\"* ]]
  then
    echo \\"$file\\"
  else
    echo \\"$(cd \\"$(dirname \\"$file\\")\\" && pwd)/$(basename \\"$file\\")\\"
  fi
}

System::WrapSource() {
  local libPath=\\"$1\\"
  shift

  builtin source \\"$libPath\\" \\"$@\\" || throw \\"Unable to load $libPath\\"
}

System::SourceFile() {
  local libPath=\\"$1\\"
  shift

  # DEBUG subject=level3 Log \\"Trying to load from: \${libPath}\\"
  [[ ! -f \\"$libPath\\" ]] && return 1 # && e=\\"Cannot import $libPath\\" throw

  libPath=\\"$(File::GetAbsolutePath \\"$libPath\\")\\"

  # echo \\"importing $libPath\\"

  # [ -e \\"$libPath\\" ] && echo \\"Trying to load from: \${libPath}\\"
  if [[ -f \\"$libPath\\" ]]
  then
    ## if already imported let's return
    # if declare -f \\"Array::Contains\\" &> /dev/null &&
    if [[ \\"\${__oo__allowFileReloading-}\\" != true ]] && [[ ! -z \\"\${__oo__importedFiles[*]}\\" ]] && Array::Contains \\"$libPath\\" \\"\${__oo__importedFiles[@]}\\"
    then
      # DEBUG subject=level3 Log \\"File previously imported: \${libPath}\\"
      return 0
    fi

    # DEBUG subject=level2 Log \\"Importing: $libPath\\"

    __oo__importedFiles+=( \\"$libPath\\" )
    __oo__importParent=$(dirname \\"$libPath\\") System::WrapSource \\"$libPath\\" \\"$@\\"
    # eval \\"$(<\\"$libPath\\")\\"

  else
    :
    # DEBUG subject=level2 Log \\"File doesn't exist when importing: $libPath\\"
  fi
}

System::Bootstrap() {
  ## note: aliases are visible inside functions only if
  ## they were initialized AFTER they were created
  ## this is the reason why we have to load files in a specific order
  if ! System::Import Array/Contains
  then
    cat <<< \\"FATAL ERROR: Unable to bootstrap (missing lib directory?)\\" 1>&2
    exit 1
  fi
}

########################
### INITIALZE SYSTEM ###
########################

# From: http://wiki.bash-hackers.org/scripting/debuggingtips
export PS4='+(\${BASH_SOURCE##*/}:\${LINENO}): \${FUNCNAME[0]:+\${FUNCNAME[0]}(): }'

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail

shopt -s expand_aliases
declare -g __oo__libPath=\\"$( cd \\"\${BASH_SOURCE[0]%/*}\\" && pwd )\\"
declare -g __oo__path=\\"\${__oo__libPath}/..\\"
declare -ag __oo__importedFiles

## stubs in case either exception or log is not loaded
namespace() { :; }
throw() { eval 'cat <<< \\"Exception: $e ($*)\\" 1>&2; read -s;'; }

System::Bootstrap

alias import=\\"__oo__allowFileReloading=false System::Import\\"
alias source=\\"__oo__allowFileReloading=true System::ImportOne\\"
alias .=\\"__oo__allowFileReloading=true System::ImportOne\\"

declare -g __oo__bootstrapped=true
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/bash4.sh 1`] = `
"[[ \\"\${BASH_VERSINFO[0]}\\" -lt 4 ]] && echo \\"The module you are trying to load requires bash >= 4\\" && exit 1 || true
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/class.sh 1`] = `
"namespace util/type
import util/type String/SanitizeForVariable
# ------------------------ #

Type::DefineProperty() {
  local visibility=\\"$1\\"
  local class=\\"$2\\"
  local type=\\"$3\\"
  local property=\\"$4\\"
  local assignment=\\"$5\\"
  local defaultValue=\\"$6\\"

  class=\\"\${class//[^a-zA-Z0-9]/_}\\"

  eval \\"__\${class}_property_names+=( '$property' )\\"
  eval \\"__\${class}_property_types+=( '$type' )\\"
  eval \\"__\${class}_property_visibilities+=( '$visibility' )\\"
  # if [[ \\"$assignment\\" == '=' && ! -z \\"$defaultValue\\" ]]
  # then
    eval \\"__\${class}_property_defaults+=( \\\\\\"\\\\$defaultValue\\\\\\" )\\"
  # fi
}

private() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty private $class \\"$@\\"
}

public() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty public $class \\"$@\\"
}

Type::Initialize() {
  local name=\\"$1\\"
  local style=\\"\${2:-default}\\"

  Function::Exists class:$name && class:$name || true

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"

  case \\"$style\\" in
    'primitive') ;;
    'static')
      declare -Ag __oo_static_instance_\${name}=\\"$(Type::Construct $name)\\"
      eval \\"\${name}\\"'(){ '\\"Type::Handle __oo_static_instance_\${name}\\"' \\"$@\\"; }'
    ;;
    *)
      ## add alias for parameters
      alias [$name]=\\"_type=$name Variable::TrapAssign local -A\\"

      ## add alias for creating vars
      alias $name=\\"_type=$name Type::TrapAssign declare -A\\"
    ;;
  esac
}

Type::InitializeStatic() {
  local name=\\"$1\\"

  Type::Initialize \\"$name\\" static
}

Type::Construct() {
  local type=\\"$1\\"
  local typeSanitized=$(String::SanitizeForVariableName $type)
  local assignToVariable=\\"$2\\"

  if [[ ! -z \\"\${__constructor_recursion+x}\\" ]]
  then
    __constructor_recursion=$(( \${__constructor_recursion} + 1 ))
  fi

  local -A constructedType=( [__object_type]=\\"$type\\" )
  # else
  #   echo \\"$assignToVariable[__object_type]=\\\\\\"$type\\\\\\"\\"
  # fi

  if Variable::Exists \\"__\${typeSanitized}_property_names\\"
  then
    local propertyIndexesIndirect=\\"__\${typeSanitized}_property_names[@]\\"
    local -i propertyIndex=0
    local propertyName
    for propertyName in \\"\${!propertyIndexesIndirect}\\"
    do
      # local propertyNameIndirect=__\${typeSanitized}_property_names[$propertyIndex]
      # local propertyName=\\"\${!propertyNameIndirect}\\"

      local propertyTypeIndirect=__\${typeSanitized}_property_types[$propertyIndex]
      local propertyType=\\"\${!propertyTypeIndirect}\\"

      local defaultValueIndirect=__\${typeSanitized}_property_defaults[$propertyIndex]
      local defaultValue=\\"\${!defaultValueIndirect}\\"

      if [[ $propertyType == 'boolean' ]] && [[ \\"$defaultValue\\" == 'false' || \\"$defaultValue\\" == 'true' ]]
      then
        defaultValue=\\"\${__primitive_extension_fingerprint__boolean}:$defaultValue\\"
      fi

      local constructedPropertyDefinition=\\"$defaultValue\\"

      DEBUG Log \\"iterating type: \${typeSanitized}, property: [$propertyIndex] $propertyName = $defaultValue\\"

      ## AUTOMATICALLY CONSTRUCTS THE PROPERTIES:
      # case \\"$propertyType\\" in
      #   'array'|'map'|'string'|'integer'|'integerArray') ;;
      #       # 'integer') constructedPropertyDefinition=\\"\${__integer_fingerprint}$defaultValue\\" ;;
      #       # 'integerArray') constructedPropertyDefinition=\\"\${__integer_array_fingerprint}$defaultValue\\" ;;
      #   * )
      #     if [[ -z \\"$defaultValue\\" && \\"$__constructor_recursion\\" -lt 15 ]]
      #     then
      #       constructedPropertyDefinition=$(Type::Construct \\"$propertyType\\")
      #     fi
      #   ;;
      # esac

      if [[ ! -z \\"$constructedPropertyDefinition\\" ]]
      then
        ## initialize non-empty fields

        DEBUG Log \\"Will exec: constructedType+=( [\\\\\\"$propertyName\\\\\\"]=\\\\\\"$constructedPropertyDefinition\\\\\\" )\\"
        constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )
        # eval 'constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )'
      fi

      propertyIndex+=1
    done
  fi

  if [[ -z \\"$assignToVariable\\" ]]
  then
    Variable::PrintDeclaration constructedType
  else
    local constructedIndex
    for constructedIndex in \\"\${!constructedType[@]}\\"
    do
      eval \\"$assignToVariable[\\\\\\"\\\\$constructedIndex\\\\\\"]=\\\\\\"\\\\\${constructedType[\\\\\\"\\\\$constructedIndex\\\\\\"]}\\\\\\"\\"
    done
  fi
}

alias new='Type::Construct'
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/command.sh 1`] = `
"# no dependencies

Command::GetType() {
  local name=\\"$1\\"
  local typeMatch=$(type -t \\"$name\\" 2> /dev/null || true)
  echo \\"$typeMatch\\"
}

Command::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" || \\"$typeMatch\\" == \\"function\\" || \\"$typeMatch\\" == \\"builtin\\" ]]
}

Alias::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" ]]
}

Function::Exists(){
  local name=\\"$1\\"
  declare -f \\"$name\\" &> /dev/null
}

Function::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'function' \\"$startsWith\\" || true
}

Function::InjectCode() {
  local functionName=\\"$1\\"
  local injectBefore=\\"$2\\"
  local injectAfter=\\"$3\\"
  local body=$(declare -f \\"$functionName\\")
  body=\\"\${body#*{}\\" # trim start
  body=\\"\${body%\\\\}}\\" # trim end
  local enter=$'\\\\n'
  eval \\"\${functionName}() { \${enter}\${injectBefore}\${body}\${injectAfter}\${enter} }\\"
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/exception.sh 1`] = `
"namespace util/exception
import String/GetSpaces String/SlashReplacement UI/Color UI/Console

#########################
### HANDLE EXCEPTIONS ###
#########################

trap \\"__EXCEPTION_TYPE__=\\\\\\"\\\\$_\\\\\\" command_not_found_handle \\\\$? \\\\$BASH_COMMAND\\" ERR
set -o errtrace  # trace ERR through 'time command' and other functions

# unalias throw 2> /dev/null || true
unset -f throw 2> /dev/null || true
alias throw=\\"__EXCEPTION_TYPE__=\\\\\${e:-Manually invoked} command_not_found_handle\\"

Exception::CustomCommandHandler() {
  ## this method can be overridden to create a custom, unknown command handler
  return 1
}

Exception::FillExceptionWithTraceElements() {
  local IFS=$'\\\\n'
  for traceElement in $(Exception::DumpBacktrace \${skipBacktraceCount:-3})
  do
    exception+=( \\"$traceElement\\" )
  done
}

command_not_found_handle() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  # ignore the error from the catch subshell itself
  if [[ \\"$*\\" = '( set -'*'; true'* ]] ## TODO: refine with a regex and test
  then
    return 0
  fi

  Exception::CustomCommandHandler \\"$@\\" && return 0 || true

  local exit_code=\\"\${1}\\"
  shift || true # there might have not been any parameter, in which case \\"shift\\" would fail
  local script=\\"\${BASH_SOURCE[1]#./}\\"
  local lineNo=\\"\${BASH_LINENO[0]}\\"
  local undefinedObject=\\"$*\\"
  local type=\\"\${__EXCEPTION_TYPE__:-\\"Undefined command\\"}\\"

  if [[ \\"$undefinedObject\\" == \\"(\\"*\\")\\" ]]
  then
    type=\\"Subshell returned a non-zero value\\"
  fi

  if [[ -z \\"$undefinedObject\\" ]]
  then
    undefinedObject=\\"$type\\"
  fi

  if [[ $__oo__insideTryCatch -gt 0 ]]
  then
    subject=level3 Log \\"inside Try No.: $__oo__insideTryCatch\\"

    if [[ ! -s $__oo__storedExceptionLineFile ]]; then
      echo \\"$lineNo\\" > $__oo__storedExceptionLineFile
    fi
    if [[ ! -s $__oo__storedExceptionFile ]]; then
      echo \\"$undefinedObject\\" > $__oo__storedExceptionFile
    fi
    if [[ ! -s $__oo__storedExceptionSourceFile ]]; then
      echo \\"$script\\" > $__oo__storedExceptionSourceFile
    fi
    if [[ ! -s $__oo__storedExceptionBacktraceFile ]]; then
      Exception::DumpBacktrace 2 > $__oo__storedExceptionBacktraceFile
    fi

    return 1 # needs to be return 1
  fi

  if [[ $BASH_SUBSHELL -ge 25 ]] ## TODO: configurable
  then
    echo \\"ERROR: Call stack exceeded (25).\\"
    Exception::ContinueOrBreak || exit 1
  fi

  local -a exception=( \\"$lineNo\\" \\"$undefinedObject\\" \\"$script\\" )

  Exception::FillExceptionWithTraceElements

  Console::WriteStdErr
  Console::WriteStdErr \\" $(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Bold)UNCAUGHT EXCEPTION: $(UI.Color.LightRed)\${type} $(UI.Color.Yellow)$(UI.Color.Italics)(\${exit_code})$(UI.Color.Default)\\"
  Exception::PrintException \\"\${exception[@]}\\"

  Exception::ContinueOrBreak
}

Exception::PrintException() {
  #    [...rest] exception
  local -a exception=(\\"$@\\")

  local -i backtraceIndentationLevel=\${backtraceIndentationLevel:-0}

  local -i counter=0
  local -i backtraceNo=0

  local -a backtraceLine
  local -a backtraceCommand
  local -a backtraceFile

  #for traceElement in Exception::GetLastException
  while [[ $counter -lt \${#exception[@]} ]]
  do
    backtraceLine[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceCommand[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceFile[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1

    backtraceNo+=1
  done

  local -i index=1

  while [[ $index -lt $backtraceNo ]]
  do
    Console::WriteStdErr \\"$(Exception::FormatExceptionSegment \\"\${backtraceFile[$index]}\\" \\"\${backtraceLine[$index]}\\" \\"\${backtraceCommand[($index - 1)]}\\" $(( $index + $backtraceIndentationLevel )) )\\"
    index+=1
  done
}

Exception::CanHighlight() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  if [[ \\"$errLine\\" == *\\"$stringToMarkWithoutSlash\\"* ]]
  then
    return 0
  else
    return 1
  fi
}

Exception::HighlightPart() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
  local underlinedObjectInLine=\\"\${errLine/$stringToMarkWithoutSlash/$underlinedObject}\\"

  # Bring back the slash:
  underlinedObjectInLine=\\"$(String::RestoreSlashes \\"$underlinedObjectInLine\\")\\"

  # Trimming:
  underlinedObjectInLine=\\"\${underlinedObjectInLine#\\"\${underlinedObjectInLine%%[![:space:]]*}\\"}\\" # \\"

  echo \\"$underlinedObjectInLine\\"
}

Exception::GetUnderlinedPart() {
  #    [string] stringToMark
  local stringToMark=\\"$1\\"

  echo \\"$(UI.Color.LightGreen)$(UI.Powerline.RefersTo) $(UI.Color.Magenta)$(UI.Color.Underline)$stringToMark$(UI.Color.White)$(UI.Color.NoUnderline)\\"
}

Exception::FormatExceptionSegment() {
  local script=\\"$1\\"
  local -i lineNo=\\"$2\\"
  local stringToMark=\\"$3\\"
  local -i callPosition=\\"\${4:-1}\\"
  #    [string] script
  #    [integer] lineNo
  #    [string] stringToMark
  #    [integer] callPosition=1

  local errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  local originalErrLine=\\"$errLine\\"

  local -i linesTried=0

  ## TODO: when line ends with slash \\\\ it is a multiline statement
  ## TODO: when eval or alias
  # In case it's a multiline eval, sometimes bash gives a line that's offset by a few
  while [[ $linesTried -lt 5 && $lineNo -gt 0 ]] && ! Exception::CanHighlight \\"$errLine\\" \\"$stringToMark\\"
  do
    linesTried+=1
    lineNo+=-1
    errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  done

  # Cut out the path, leave the script name
  script=\\"\${script##*/}\\"

  local prefix=\\"   $(UI.Powerline.Branch)$(String::GetSpaces $(($callPosition * 3 - 3)) || true) \\"

  if [[ $linesTried -ge 5 ]]
  then
    # PRINT THE ORGINAL OBJECT AND ORIGINAL LINE #
    #local underlinedObject=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"
    local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
    echo \\"\${prefix}$(UI.Color.White)\${underlinedObject}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
    prefix=\\"$prefix$(UI.Powerline.Fail) \\"
    errLine=\\"$originalErrLine\\"
  fi

  local underlinedObjectInLine=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"

  echo \\"\${prefix}$(UI.Color.White)\${underlinedObjectInLine}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
}

Exception::ContinueOrBreak() (
  ## TODO: Exceptions that happen in commands that are piped to others do not HALT the execution
  ## TODO: Add a workaround for this ^
  ## probably it's enough to -pipefail, check for a pipe in command_not_found - and if yes - return 1

  # if in a terminal
  if [ -t 0 ]
  then
    trap \\"stty sane; exit 1\\" INT
    Console::WriteStdErr
    Console::WriteStdErr \\" $(UI.Color.Yellow)$(UI.Powerline.Lightning)$(UI.Color.White) Press $(UI.Color.Bold)[CTRL+C]$(UI.Color.White) to exit or $(UI.Color.Bold)[Return]$(UI.Color.White) to continue execution.\\"
    read -s
    Console::WriteStdErr \\"$(UI.Color.Blue)$(UI.Powerline.Cog)$(UI.Color.White)  Continuing...$(UI.Color.Default)\\"
    return 0
  else
    Console::WriteStdErr
    exit 1
  fi
)

Exception::DumpBacktrace() {
  local -i startFrom=\\"\${1:-1}\\"
  #    [integer] startFrom=1
  # inspired by: http://stackoverflow.com/questions/64786/error-handling-in-bash

  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local -i i=0

  while caller $i > /dev/null
  do
    if (( $i + 1 >= $startFrom ))
    then
      local -a trace=( $(caller $i) )

      echo \\"\${trace[0]}\\"
      echo \\"\${trace[1]}\\"
      echo \\"\${trace[@]:2}\\"
    fi
    i+=1
  done
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/exits.sh 1`] = `
"#!/usr/bin/env bash
#
# exits
#
# Those values are come from /usr/include/sysexits.h
#

# successful termination
Util_ExitCode_OK=0
Util_ExitCode_USAGE=64  # command line usage error
Util_ExitCode_DATAERR=65  # data format error
Util_ExitCode_NOINPUT=66  # cannot open input
Util_ExitCode_NOUSER=67  # addressee unknown
Util_ExitCode_NOHOST=68  # host name unknown
Util_ExitCode_UNAVAILABLE=69  # service unavailable
Util_ExitCode_SOFTWARE=70  # internal software error
Util_ExitCode_OSERR=71  # system error (e.g., can't fork)
Util_ExitCode_OSFILE=72  # critical OS file missing
Util_ExitCode_CANTCREAT=73  # can't create (user) output file
Util_ExitCode_IOERR=74  # input/output error
Util_ExitCode_TEMPFAIL=75  # temp failure; user is invited to retry
Util_ExitCode_PROTOCOL=76  # remote error in protocol
Util_ExitCode_NOPERM=77  # permission denied
Util_ExitCode_CONFIG=78  # configuration error
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/log.sh 1`] = `
"import util/bash4
import UI/Color UI/Console

declare -Ag __oo__logScopes
declare -Ag __oo__logScopeOutputs
declare -Ag __oo__logDisabledFilter
declare -Ag __oo__loggers

Log::NameScope() {
  local scopeName=\\"$1\\"
  local script=\\"\${BASH_SOURCE[1]}\\"
  __oo__logScopes[\\"$script\\"]=\\"$scopeName\\"
}

Log::AddOutput() {
  local scopeName=\\"$1\\"
  local outputType=\\"\${2:-STDERR}\\"
  __oo__logScopeOutputs[\\"$scopeName\\"]+=\\"$outputType;\\"
}

Log::ResetOutputsAndFilters() {
  local scopeName=\\"$1\\"
  unset __oo__logScopeOutputs[\\"$scopeName\\"]
  unset __oo__logDisabledFilter[\\"$scopeName\\"]
}

Log::ResetAllOutputsAndFilters() {
  unset __oo__logScopeOutputs
  unset __oo__logDisabledFilter
  declare -Ag __oo__logScopeOutputs
  declare -Ag __oo__logDisabledFilter
}

Log::DisableFilter() {
  __oo__logDisabledFilter[\\"$1\\"]=true
}

Log() {
  local callingFunction=\\"\${FUNCNAME[1]}\\"
  local callingScript=\\"\${BASH_SOURCE[1]}\\"
  local scope
  if [[ ! -z \\"\${__oo__logScopes[\\"$callingScript\\"]}\\" ]]
  then
    scope=\\"\${__oo__logScopes[\\"$callingScript\\"]}\\"
  else # just the filename without extension
    scope=\\"\${callingScript##*/}\\"
    scope=\\"\${scope%.*}\\"
  fi
  local loggerList
  local loggers
  local logger
  local logged

  if [[ ! -z \\"$subject\\" ]]
  then
    if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\"
    fi

    loggers=( \${loggerList//;/ } )
    for logger in \\"\${loggers[@]}\\"
    do
      subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      logged=true
    done
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope/$callingFunction\\"]} == true || \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
          subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
          logged=true
      done
    fi
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
        subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      done
    fi
  fi
}

Log::RegisterLogger() {
  local logger=\\"$1\\"
  local method=\\"$2\\"
  __oo__loggers[\\"$logger\\"]=\\"$method\\"
}

Log::Using() {
  local logger=\\"$1\\"
  shift
  if [[ ! -z \${__oo__loggers[\\"$logger\\"]} ]]
  then
      \${__oo__loggers[\\"$logger\\"]} \\"$@\\"
  fi
}

Logger::DEBUG() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) DEBUG \\"$@\\"
}
Logger::ERROR() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Red) ERROR \\"$@\\"
}
Logger::INFO() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Blue) INFO \\"$@\\"
}
Logger::WARN() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) WARN \\"$@\\"
}
Logger::CUSTOM() {
    Console::WriteStdErr \\"$(UI.Color.Yellow)[\${subject^^}] $(UI.Color.Default)$* \\"
}
Logger::DETAILED() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) \\"\${subject^^}\\" \\"$@\\"
}

Log::RegisterLogger STDERR Console::WriteStdErr
Log::RegisterLogger DEBUG Logger::DEBUG
Log::RegisterLogger ERROR Logger::ERROR
Log::RegisterLogger INFO Logger::INFO
Log::RegisterLogger WARN Logger::WARN
Log::RegisterLogger CUSTOM Logger::CUSTOM
Log::RegisterLogger DETAILED Logger::DETAILED

alias namespace=\\"Log::NameScope\\"
namespace oo/log
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/namedParameters.sh 1`] = `
"namespace oo/type
import util/variable

# depends on modules: variable, exception

declare -g ref=D10F7FB728364261BB50A7E818D537C4
declare -g var=A04FB7D7594E479B8CD8D90C5014E37A

# TODO: required parameters
Variable::TrapAssignNumberedParameter() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift
  #  Log \\"TRAP: \${commandWithArgs[@]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* || \\"$command\\" == \\"_isRequired=\\"* || \\"$command\\" == \\"_isReadOnly=\\"*  || \\"$command\\" == \\"_noHandle=\\"* || \\"$command\\" == \\"_isGlobal=\\"* ]]
  then
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __assign_next=true
    DEBUG subject=\\"parameters-assign\\" Log \\"Will assign next one\\"

    local nextAssignment=$(( \${__assign_paramNo:-0} + 1 ))
    if [[ \\"\${!nextAssignment-}\\" == \\"$ref:\\"* ]]
    then
      DEBUG subject=\\"parameters-reference\\" Log \\"next param ($nextAssignment) is an object reference\\"
      __assign_parameters=\\"-n\\"
    ## TODO: type checking
    else
      __assign_parameters=\\"\\"
    fi
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* || $varDeclaration == '\${__assign'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"
  # TODO: checking for parameter existence or default value

  if [[ \\"\${__assign_varType:-null}\\" != \\"null\\" ]]
  then
    local requiredType=\\"$__assign_varType\\" ## TODO: use this information
    [[ $__assign_parameters == '-n' ]] && __assign_varType=\\"reference\\"

    DEBUG subject=\\"parameters-setting\\" Log \\"SETTING: [$__assign_varType] $__assign_varName = \\\\$$__assign_paramNo [rq:$__assign_valueRequired]\\" # [val:\${!__assign_paramNo}]
    # subject=\\"parameters-setting\\" Log --

    if [[ \\"$__assign_valueRequired\\" == 'true' && -z \\"\${!__assign_paramNo+x}\\" ]]
    then
      e=\\"Value is required for the parameter $__assign_varName ($__assign_paramNo) of type [$__assign_varType]\\" throw
    fi

    unset __assign_valueRequired __assign_valueReadOnly

    local indirectAccess=\\"$__assign_paramNo\\"

    if [[ \\"\${!indirectAccess-}\\" == \\"$var:\\"* ]]
    then
      local realVarName=\\"\${!indirectAccess#*$var:}\\"
      if Variable::Exists \\"$realVarName\\"
      then
        local __declaration
        local __declaration_type
        Variable::ExportDeclarationAndTypeToVariables \\"$realVarName\\" __declaration
        # Log realVarName \\"\${!indirectAccess#*$var:}\\" type \\"$declaration_type vs $__assign_varType\\" declaration: \\"$__declaration\\" vs \\"$(Variable::PrintDeclaration \\"$realVarName\\")\\"
        indirectAccess=__declaration

        if [[ \\"$__declaration_type\\" != \\"$__assign_varType\\" && \\"$__assign_varType\\" != 'params' && \\"$__assign_varType\\" != 'rest' ]]
        then
          e=\\"Passed in variable: ($__assign_paramNo) $__assign_varName is of different than its required type [required: $__assign_varType] [actual: $__declaration_type]\\" throw
        fi
      fi
    fi

    case \\"$__assign_varType\\" in
      'params')
      # passing array:
        eval \\"__assign_arrLength=$__assign_arrLength\\"
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo:$__assign_arrLength}\\\\\\" )\\"

        ## TODO: foreach param expand $var: indirectAccess
        __assign_paramNo+=$(($__assign_arrLength - 1))
        unset __assign_arrLength
      ;;
      'rest')
      ## TODO: foreach param expand $var: indirectAccess
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo}\\\\\\" )\\"
      ;;
      'boolean')
        DEBUG Log passed \\"\${!indirectAccess}\\", default \\"\${__assign_varValue}\\"
        local boolean_fingerprint=\\"\${__primitive_extension_fingerprint__boolean:+__primitive_extension_fingerprint__boolean:}\\"

        if [[ ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"\${boolean_fingerprint}\\"* ]]
          then
            __assign_varValue=\\"\${!indirectAccess}\\"
          elif [[ \\"\${!indirectAccess}\\" == 'true' || \\"\${!indirectAccess}\\" == 'false' ]]
          then
            __assign_varValue=\\"\${boolean_fingerprint}\${!indirectAccess}\\"
          else
            __assign_varValue=\\"\${boolean_fingerprint}false\\"
          fi
        elif [[ \\"\${__assign_varValue}\\" == 'true' || \\"\${__assign_varValue}\\" == 'false' ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}\${__assign_varValue}\\"
        elif [[ \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}true\\" && \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}false\\" ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}false\\"
        fi
        eval \\"$__assign_varName=\\\\\\"\${__assign_varValue}\\\\\\"\\"
      ;;
      'string'|'integer'|'reference')
        if [[ \\"$__assign_varType\\" == \\"reference\\" || ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"$ref:\\"* ]]
          then
            local refVarName=\\"\${!indirectAccess#*$ref:}\\"
            eval \\"$__assign_varName=$refVarName\\"
          else
            DEBUG Log \\"Will eval $__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
            # escape $indirectAccess with \\\\\\"
            # local escapedAssignment=\\"\${!indirectAccess}\\"
            # escapedAssignment=\\"\${escapedAssignment//\\\\\\"/\\\\\\\\\\\\\\"}\\"
            # execute=\\"$__assign_varName=\\\\\\"$escapedAssignment\\\\\\"\\"
            eval \\"$__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          fi

        # DEBUG subject=\\"parameters-executing\\" Log \\"EXECUTING: $execute\\"
        fi
      ;;
      *) # 'array'|'map'|objects
        if [[ ! -z \\"\${!indirectAccess}\\" ]]
        then
          eval \\"local -$(Variable::GetDeclarationFlagFromType '$__assign_varType') tempMap=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          local index
          local value

          ## copy the array / map item by item
          for index in \\"\${!tempMap[@]}\\"
          do
            eval \\"$__assign_varName[\\\\$index]=\\\\\\"\\\\\${tempMap[\\\\$index]}\\\\\\"\\"
          done

          unset index value tempMap
        fi
      ;;
    esac

    unset __assign_varType
    unset __assign_parameters

    if [[ \\"$__assign_valueGlobal\\" == \\"true\\" ]]; then
      local declaration=\\"$(declare -p $__assign_varName)\\"
      declaration=\\"\${declaration/declare/declare -g}\\"
      eval \\"$declaration\\"
    fi
    unset __assign_valueGlobal

    if [[ \\"$__assign_noHandle\\" != 'true' && ! -z \${__oo__bootstrapped+x} ]] && declare -f 'Type::CreateHandlerFunction' &> /dev/null
    then
      DEBUG Log \\"Will create handle for $__assign_varName\\"
      Type::CreateHandlerFunction \\"$__assign_varName\\" # 2> /dev/null || true
    fi
  fi

  if [[ \\"$command\\" != \\"local\\" || \\"\${__assign_next-}\\" != \\"true\\" ]]
  then
    __assign_normalCodeStarted+=1

    DEBUG subject=\\"parameters-nopass\\" Log \\"NOPASS \${commandWithArgs[*]}\\"
    DEBUG subject=\\"parameters-nopass\\" Log \\"normal code count ($__assign_normalCodeStarted)\\"
  # subject=\\"parameters-nopass\\" Log --
  else
    unset __assign_next

    __assign_normalCodeStarted=0
    __assign_varName=\\"$varName\\"
    __assign_varValue=\\"$varValue\\"
    __assign_varType=\\"$__capture_type\\"
    __assign_arrLength=\\"$__capture_arrLength\\"
    __assign_valueRequired=\\"$__capture_valueRequired\\"
    __assign_valueReadOnly=\\"$__capture_valueReadOnly\\"
    __assign_valueGlobal=\\"$__capture_valueGlobal\\"
    __assign_noHandle=\\"$__capture_noHandle\\"

    DEBUG subject=\\"parameters-pass\\" Log \\"PASS \${commandWithArgs[*]}\\"
    # subject=\\"parameters-pass\\" Log --

    __assign_paramNo+=1
  fi
}

Variable::InTrapCaptureParameters() {
  DEBUG subject=\\"parameters\\" Log \\"Capturing Type $_type\\"
  # subject=\\"parameters\\" Log --

  __capture_type=\\"$_type\\"
  __capture_arrLength=\\"\${l-'\${#@}'}\\"
  __capture_valueRequired=\\"\${_isRequired-false}\\"
  __capture_valueReadOnly=\\"\${_isReadOnly-false}\\"
  __capture_valueGlobal=\\"\${_isGlobal-false}\\"
  __capture_noHandle=\\"\${_noHandle-false}\\"
}

## ARGUMENT RESOLVERS ##

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Variable::TrapAssign='Variable::InTrapCaptureParameters; local -i __assign_normalCodeStarted=0; trap \\"declare -i __assign_paramNo; Variable::TrapAssignNumberedParameter \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__assign_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __assign_varType __assign_varName __assign_varValue __assign_paramNo __assign_valueRequired __assign_valueReadOnly __assign_valueGlobal __assign_noHandle\\" DEBUG; true; true; '
alias [reference]='_type=reference Variable::TrapAssign local -n'
alias Variable::TrapAssignLocal='Variable::TrapAssign local \${__assign_parameters}'
alias [string]=\\"_type=string Variable::TrapAssignLocal\\"
# alias [string]=\\"_type=string Variable::TrapAssign local \\\\\${__assign_parameters}\\"
alias [integer]='_type=integer Variable::TrapAssign local \${__assign_parameters:--i}'
alias [array]='_type=array Variable::TrapAssign local \${__assign_parameters:--a}'
alias [map]='_type=map Variable::TrapAssign local \${__assign_parameters:--A}'
# TODO: alias [integerArray]='_type=array Variable::TrapAssign local \${__assign_parameters:--ai}'
alias [boolean]='_type=boolean Variable::TrapAssignLocal'
alias [string[]]='_type=params Variable::TrapAssignLocal'
alias [string[1]]='l=1 _type=params Variable::TrapAssignLocal'
alias [string[2]]='l=2 _type=params Variable::TrapAssignLocal'
alias [string[3]]='l=3 _type=params Variable::TrapAssignLocal'
alias [string[4]]='l=4 _type=params Variable::TrapAssignLocal'
alias [string[5]]='l=5 _type=params Variable::TrapAssignLocal'
alias [string[6]]='l=6 _type=params Variable::TrapAssignLocal'
alias [string[7]]='l=7 _type=params Variable::TrapAssignLocal'
alias [string[8]]='l=8 _type=params Variable::TrapAssignLocal'
alias [string[9]]='l=9 _type=params Variable::TrapAssignLocal'
alias [string[10]]='l=10 _type=params Variable::TrapAssignLocal'
alias [...rest]='_type=rest Variable::TrapAssignLocal'
alias @required='_isRequired=true'
alias @handleless='_noHandle=true'
alias @global='_isGlobal=true'
# TODO: alias @readonly='_isReadOnly=true '
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/pipe.sh 1`] = `
"# no dependencies

Pipe::Capture() {
  read -r -d '' $1 || true
}

Pipe::CaptureFaithful() {
  IFS= read -r -d '' $1 || true
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/test.sh 1`] = `
"import util/class util/tryCatch UI/Cursor

class:Test() {
  private UI.Cursor onStartCursor
  private string groupName
  public string errors
  # public boolean errors = false

  Test.Start() {
    [string] verb
    [string] description

    this onStartCursor capture
    echo \\"$(UI.Color.Yellow)$(UI.Powerline.PointingArrow) $(UI.Color.Yellow)[$(UI.Color.LightGray)$(UI.Color.Bold)TEST$(UI.Color.NoBold)$(UI.Color.Yellow)] $(UI.Color.White)\${verb} \${description}$(UI.Color.Default)\\"
    @return
  }

  Test.OK() {
    [string] printInPlace=true

    [[ $printInPlace == true ]] && this onStartCursor restore

    echo \\"$(UI.Color.Green)$(UI.Powerline.OK) $(UI.Color.Yellow)[ $(UI.Color.Green)$(UI.Color.Bold)OK$(UI.Color.NoBold) $(UI.Color.Yellow)]$(UI.Color.Default)\\"
    @return
  }

  Test.EchoedOK() {
    this OK false
  }

  Test.Fail() {
    [string] line
    [string] error
    [string] source
    echo \\"$(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Yellow)[$(UI.Color.Red)$(UI.Color.Bold)FAIL$(UI.Color.NoBold)$(UI.Color.Yellow)]$(UI.Color.Default) in $(UI.Color.Yellow)\${source}$(UI.Color.Default):$(UI.Color.Blue)\${line}$(UI.Color.Default) $(UI.Powerline.RefersTo) $(UI.Color.Red)\${error}$(UI.Color.Default)\\"
    @return
  }

  Test.DisplaySummary() {
    if [[ $(this errors) == true ]]
    # if this errors
    then
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Red)There were errors $(UI.Color.Default)$(UI.Powerline.Lightning)\\"
      this errors = false
    else
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Yellow)Test group completed successfully $(UI.Color.Default)$(UI.Powerline.ThumbsUp)\\"
    fi
    @return
  }

  Test.NewGroup() {
    [string] groupName

    echo \\"$(UI.Powerline.ArrowRight)\\" $(UI.Color.Magenta)Testing [$(UI.Color.White)\${groupName}$(UI.Color.Magenta)]: $(UI.Color.Default)

    this groupName = \\"$groupName\\"

    @return
  }
}

Type::InitializeStatic Test

### TODO: special case for static classes
### for storage use a generated variable name (hash of class name?)
### for execution use class' name, e.g. Test Start

alias describe='Test NewGroup'
alias summary='Test DisplaySummary'
alias caught=\\"echo \\\\\\"CAUGHT: $(UI.Color.Red)\\\\$__BACKTRACE_COMMAND__$(UI.Color.Default) in \\\\$__BACKTRACE_SOURCE__:\\\\$__BACKTRACE_LINE__\\\\\\"\\"
alias it=\\"Test Start it\\"
alias expectPass=\\"Test OK; catch { Test errors = true; Test Fail \\\\\\"\\\\\${__EXCEPTION__[@]}\\\\\\"; }\\"
alias expectOutputPass=\\"Test EchoedOK; catch { Test errors = true; Test Fail; }\\"
alias expectFail='catch { caught; Test EchoedOK; }; test $? -eq 1 && Test errors = false; '
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/tryCatch.sh 1`] = `
"# no dependencies
declare -ig __oo__insideTryCatch=0
declare -g __oo__presetShellOpts=\\"$-\\"

# in case try-catch is nested, we set +e before so the parent handler doesn't catch us instead
alias try='[[ $__oo__insideTryCatch -eq 0 ]] || __oo__presetShellOpts=\\"$(echo $- | sed 's/[is]//g')\\"; __oo__insideTryCatch+=1; set +e; ( set -e; true; '
alias catch='); declare __oo__tryResult=$?; __oo__insideTryCatch+=-1; [[ $__oo__insideTryCatch -lt 1 ]] || set -\${__oo__presetShellOpts:-e} && Exception::Extract $__oo__tryResult || '

Exception::SetupTemp() {
  declare -g __oo__storedExceptionLineFile=\\"$(mktemp -t stored_exception_line.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionSourceFile=\\"$(mktemp -t stored_exception_source.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionBacktraceFile=\\"$(mktemp -t stored_exception_backtrace.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionFile=\\"$(mktemp -t stored_exception.$$.XXXXXXXXXX)\\"
}

Exception::CleanUp() {
  local exitVal=$?
  rm -f $__oo__storedExceptionLineFile $__oo__storedExceptionSourceFile $__oo__storedExceptionBacktraceFile $__oo__storedExceptionFile || exit 1
  exit $exitVal
}

Exception::ResetStore() {
  > $__oo__storedExceptionLineFile
  > $__oo__storedExceptionFile
  > $__oo__storedExceptionSourceFile
  > $__oo__storedExceptionBacktraceFile
}

Exception::GetLastException() {
  if [[ -s $__oo__storedExceptionFile ]]
  then
    cat $__oo__storedExceptionLineFile
    cat $__oo__storedExceptionFile
    cat $__oo__storedExceptionSourceFile
    cat $__oo__storedExceptionBacktraceFile

    Exception::ResetStore
  else
    echo -e \\"\${BASH_LINENO[1]}\\\\n \\\\n\${BASH_SOURCE[2]#./}\\"
  fi
}

Exception::Extract() {
  local retVal=$1
  unset __oo__tryResult

  if [[ $retVal -gt 0 ]]
  then
    local IFS=$'\\\\n'
    __EXCEPTION__=( $(Exception::GetLastException) )

    local -i counter=0
    local -i backtraceNo=0

    while [[ $counter -lt \${#__EXCEPTION__[@]} ]]
    do
      __BACKTRACE_LINE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_COMMAND__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_SOURCE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      backtraceNo+=1
    done

    return 1 # so that we may continue with a \\"catch\\"
  fi
  return 0
}

Exception::SetupTemp
trap Exception::CleanUp EXIT INT TERM
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/type.sh 1`] = `
"namespace util/type

import util/bash4
import Array/Contains String/SanitizeForVariable
import util/namedParameters util/pipe util/variable util/command

declare -g __primitive_extension_declaration=2D6A822E
declare -g __primitive_extension_fingerprint__boolean=\${__primitive_extension_declaration}36884C70843578D37E6773C4
declare -g __return_separator=52A586A48E074BB6812DCFDC790841F5
declare -g __oo__type_handler_functions=()
declare -g __oo__variableMethodPrefix=\\"$var:\\"

# /**
#   * Code like: Variable::ExportDeclarationAndTypeToVariables
#   * TODO: Merge parts
#   */
Type::GetTypeOfVariable() {
  local variableName=\\"$1\\"
  local dereferrence=\\"\${2:-true}\\"

  local regex=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p \\"\${variableName}\\" 2> /dev/null || true)

  [[ -z \\"$definition\\" ]] && e=\\"Variable not defined\\" throw
  if [[ \\"$definition\\" =~ $regex ]]
  then
    local variableType
    local primitiveType=\${BASH_REMATCH[1]}

    local objectTypeIndirect=\\"$variableName[__object_type]\\"
    if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
    then
      DEBUG Log \\"typeof $variableName: Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
      variableType=\\"\${!objectTypeIndirect}\\"
    else
      variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
      DEBUG Log \\"typeof $variableName: Primitive Type $primitiveType Resolved \${variableType}\\"
    fi

    if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
    then
      local dereferrencedVariableName=$(Variable::PrintDeclaration \\"$variableName\\" false)
      variableType=$(Type::GetTypeOfVariable \\"$dereferrencedVariableName\\")
    fi

    if [[ \\"$variableType\\" == 'string' ]]
    then
      local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
      if [[ ! -z \\"$extensionType\\" ]]
      then
        variableType=\\"$extensionType\\"
      fi
    fi

    DEBUG Log \\"Variable $variableName is typeof $variableType\\"

    echo \\"$variableType\\"
  fi
}

Type::IsPrimitive() {
  local type=\\"$1\\"

  case \\"$type\\" in
    'array'|'map'|'string'|'integer'|'boolean'|'integerArray'|'reference') ## TODO: reference should be resolved
      return 0 ;;
    * )
      return 1 ;;
  esac
}

## Returns a matching __primitive_extension_fingerprint__*
## Or nothing
Type::GetPrimitiveExtensionFromVariable() {
  local variableName=\\"$1\\"

  if [[ \\"\${!variableName}\\" != \\"$__primitive_extension_declaration\\"* ]]
  then
    return
  fi

  local prefix=__primitive_extension_fingerprint__
  local extensionType
  for extensionType in $(Variable::GetAllStartingWith $prefix)
  do
    local fingerprint=\${!extensionType}
    if [[ \\"\${!variableName}\\" == \\"$fingerprint\\"* ]]
    then
      extensionType=\${extensionType##$prefix}
      echo \\"$extensionType\\"
      return
    fi
  done
}

Type::GetPrimitiveExtensionFingerprint() {
  local type=\\"$1\\"

  local fingerprintVariable=\\"__primitive_extension_fingerprint__\${type}\\"
  printf \\"\${!fingerprintVariable}\\"
}

Type::CreateHandlerFunction() {
  local variableName=\\"$1\\"

  if [[ -z $variableName ]]
  then
    subject=WARN Log \\"No variable specified when trying to create a handle.\\"
    return
  fi

  ## don't allow creating a handler if a command/function/alias of such name already exists
  ## unless it is a handler already (keeps track)

  if ! Command::Exists \\"\${__oo__variableMethodPrefix}\${variableName}\\"
  then
    DEBUG Log \\"creating handler for $variableName\\"
    ## declare method with the name of the var ##
    eval \\"\${__oo__variableMethodPrefix}\${variableName}() { Type::Handle $variableName \\\\\\"\\\\$@\\\\\\"; }\\"
    __oo__type_handler_functions+=( \\"\${variableName}\\" )

  elif ! Array::Contains \\"\${variableName}\\" \\"\${__oo__type_handler_functions[@]}\\"
  then
    ## TODO: a way to solve this is to store the original functions
    ## and temporairly override it, returning back to the old formula in @return
    subject=WARN Log \\"Unable to create a handle for '$variableName'. A command of the same name already exists.\\"
  fi

  Type::RunFunctionGarbageCollector
}

Type::RunFunctionGarbageCollector() {
  local -a variables=( $(compgen -A 'variable' || true) )

  local index
  local handler
  for index in \\"\${!__oo__type_handler_functions[@]}\\"
  do
    handler=\\"\${__oo__type_handler_functions[$index]}\\"

    local exists=
    for variable in \\"\${variables[@]}\\"
    do
      # Log \\"comparing: \${variable} == $handler\\"
      [[ \\"$variable\\" == \\"$handler\\" ]] && { exists=1; break; }
    done
    ## unset all the functions that don't have corresponding variables
    if [[ ! -n $exists ]]
    then
      DEBUG Log \\"Unsetting handler for $handler\\"
      unset -f \\"\${__oo__variableMethodPrefix}\${handler}\\"
      unset __oo__type_handler_functions[$index]
    else
      DEBUG Log \\"not deleting: handler and variable exists: \${variable}\\"
    fi
  done
}

Type::InjectThisResolutionIfNeeded() {
  local methodName=\\"$1\\"

  local methodBody=$(declare -f \\"$methodName\\" || true)

  if [[ -z \\"$methodBody\\" ]]
  then
    e=\\"Method $methodName is not defined.\\" throw
    return
  fi

  if [[ \\"$methodBody\\" != *'@resolve:this'* && \\"$methodBody\\" != *'__local_return_self_and_result=false'* ]]
  then
    DEBUG Log \\"Injecting @this resolution to: $methodName\\"
    DEBUG [[ \\"$methodName\\" == \\"Human\\"* ]] && Log \\"$methodBody\\"

    if [[ \\"$methodBody\\" != *'@return'* ]]
    then
      Function::InjectCode \\"$methodName\\" '@resolve:this' '@return'
    else
      Function::InjectCode \\"$methodName\\" '@resolve:this'
    fi
  fi
}

Type::ConvertAllOfTypeToMethodsIfNeeded() {
  local type=\\"$1\\"

  local -a methods=( $(Function::GetAllStartingWith \\"\${type}.\\") )
  local method

  for method in \\"\${methods[@]}\\"
  do
    Type::InjectThisResolutionIfNeeded \\"$method\\"
  done
}

Type::InitializePrimitive() {
  local name=\\"$1\\"

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"
}

Type::TrapAndCreate() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift

  # Log \\"\${commandWithArgs[*]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* ]]
  then
    # set +x
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __typeCreate_next=true
    # Console::WriteStdErr \\"Will assign next one\\"
    # set +x
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"

  # TODO: make this better, otherwise edge case bug:
  if [[ \\"$varValue\\" == \\"$varName\\" ]]
  then
    # Log \\"equal $varName=$varValue\\"
    local varValue=\\"\\"
  fi

  if [[ ! -z $__typeCreate_varType ]]
  then

    local __primitive_extension_fingerprint__boolean=\${__primitive_extension_fingerprint__boolean:-2D6A822E36884C70843578D37E6773C4}
    # Console::WriteStdErr \\"SETTING $__typeCreate_varName = \\\\$$__typeCreate_paramNo\\"
    # Console::WriteStdErr --
    #Console::WriteStdErr $tempName

    DEBUG Log \\"creating: $__typeCreate_varName ($__typeCreate_varType) = $__typeCreate_varValue\\"

    if [[ -z \\"$__typeCreate_varValue\\" ]]
    then
      case \\"$__typeCreate_varType\\" in
        'array'|'map') eval \\"$__typeCreate_varName=()\\" ;;
        'string') eval \\"$__typeCreate_varName=''\\" ;;
        'integer') eval \\"$__typeCreate_varName=0\\" ;;
        'boolean') eval \\"$__typeCreate_varName=\${__primitive_extension_fingerprint__boolean}:false\\" ;;
        * )
        # Log \\"constructing: $__typeCreate_varName ($__typeCreate_varType) = $(__constructor_recursion=0 Type::Construct $__typeCreate_varType)\\"

          __constructor_recursion=0 Type::Construct \\"$__typeCreate_varType\\" \\"$__typeCreate_varName\\"

          DEBUG Log \\"constructed: $(@get $__typeCreate_varName)\\"
        ;;
      esac
    else
      case \\"$__typeCreate_varType\\" in
        'boolean')
          if [[ \\"\${__typeCreate_varValue}\\" != 'true' && \\"\${__typeCreate_varValue}\\" != 'false' ]]
          then
            __typeCreate_varValue='false'
          fi
          eval \\"$__typeCreate_varName=\\\\\\"\${__primitive_extension_fingerprint__boolean}:\${__typeCreate_varValue}\\\\\\"\\" ;;
      ## TODO: add case of setting value already with fingerprint
        *) ;;
      esac
    fi

    Type::CreateHandlerFunction \\"$__typeCreate_varName\\"

    ## IMPORTANT: TRAP won't work inside a TRAP, so such a constructor couldn't

    # case \\"$__typeCreate_varType\\" in
    #   'array'|'map'|'string'|'integer') ;;
    #   *)
    #     if Function::Exists \${__typeCreate_varType}.constructor
    #     then
    #       # __typeCreate_runConstructor=\${__typeCreate_varName}
    #       # Log __typeCreate_runConstructor $__typeCreate_runConstructor
    #       \${__typeCreate_varName} constructor
    #     fi
    #     # local return
    #     # Object.New $__typeCreate_varType $__typeCreate_varName
    #     # eval \\"$__typeCreate_varName=$return\\"
    #   ;;
    # esac

    # __oo__objects+=( $__typeCreate_varName )

    unset __typeCreate_varType
    unset __typeCreate_varValue
  fi

  if [[ \\"$command\\" != \\"declare\\" || \\"$__typeCreate_next\\" != \\"true\\" ]]
  then
    __typeCreate_normalCodeStarted+=1

  # Console::WriteStdErr \\"NOPASS \${commandWithArgs[*]}\\"
  # Console::WriteStdErr \\"normal code count ($__typeCreate_normalCodeStarted)\\"
  # Console::WriteStdErr --
  else
    unset __typeCreate_next

    __typeCreate_normalCodeStarted=0
    __typeCreate_varName=\\"$varName\\"
    __typeCreate_varValue=\\"$varValue\\"
    __typeCreate_varType=\\"$__capture_type\\"
    __typeCreate_arrLength=\\"$__capture_arrLength\\"

    # Console::WriteStdErr \\"PASS \${commandWithArgs[*]}\\"
    # Console::WriteStdErr --

    __typeCreate_paramNo+=1
  fi
  # set +x
}

Type::CaptureParams() {
    # Console::WriteStdErr \\"Capturing Type $_type\\"
    # Console::WriteStdErr --

    __capture_type=\\"$_type\\"
}

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Type::TrapAssign='Type::CaptureParams; declare -i __typeCreate_normalCodeStarted=0; trap \\"declare -i __typeCreate_paramNo; Type::TrapAndCreate \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__typeCreate_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __typeCreate_varType __typeCreate_varName __typeCreate_varValue __typeCreate_paramNo\\" DEBUG; true; true; '
alias reference='_type=reference Type::TrapAssign declare -n'
alias string='_type=string Type::TrapAssign declare'
alias boolean='_type=boolean Type::TrapAssign declare'
alias integer='_type=integer Type::TrapAssign declare -i'
alias array='_type=array Type::TrapAssign declare -a'
alias integerArray='_type=integerArray Type::TrapAssign declare -ai'
alias map='_type=map Type::TrapAssign declare -A'
#alias global:reference='_type=reference Type::TrapAssign declare -ng'
#alias global:string='_type=string Type::TrapAssign declare -g'
#alias global:integer='_type=integer Type::TrapAssign declare -ig'
#alias global:array='_type=array Type::TrapAssign declare -ag'
#alias global:map='_type=map Type::TrapAssign declare -Ag'

##############################

# for use in the object's methods
this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:() {
  Type::Handle \\"$@\\"
  # Type::Handle $1 \\"\${@:2}\\"
}

@return() {
  local variableName=\\"$1\\"
  local thisName=\\"\${2:-this}\\"

  local __return_declaration
  local __return_declaration_type

  ## if not returning anything, just update the self
  if [[ ! -z \\"$variableName\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $variableName __return_declaration
  elif [[ ! -z \\"\${monad+x}\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $thisName __return_declaration
  fi

  if [[ \\"\${__local_return_self_and_result}\\" == \\"true\\" || \\"\${__return_self_and_result}\\" == \\"true\\" ]]
  then
    # Log \\"returning heavy\\"
    local -a __return=(\\"$(Variable::PrintDeclaration $thisName)\\" \\"$__return_declaration\\" \\"$__return_declaration_type\\")

    printf \${__return_separator:-52A586A48E074BB6812DCFDC790841F5}
    Variable::PrintDeclaration __return
    # __modifiedThis=\\"$(Variable::PrintDeclaration this)\\"
  elif [[ \\"\${#__return_declaration}\\" -gt 0 ]]
  then
    echo \\"$__return_declaration\\"
  fi

  Type::RunFunctionGarbageCollector
}

@return:value() {
  local value=\\"$@\\"
  @return value
}

# ------------------------ #
# STACK HANDLING #
# ------------------------ #

Type::ExecuteMethod() {
  local type=\\"$1\\"
  local variableName=\\"$2\\"
  local method=\\"$3\\"

  shift; shift; shift;

  Type::InjectThisResolutionIfNeeded \\"$type.$method\\"

  thisReference=$variableName thisReferenceType=\\"$type\\" $type.$method \\"$@\\"
}

# /**
#  * used inside Type::Handle() for getting out the return value and updating this
#  */
Type::RunCurrentStack() {
  DEBUG Log \\"will execute: $method (\${params[@]})\\"

  if [[ ! -z \\"$returnValueDefinition\\" && \\"$affectTheInitialVariable\\" == 'false' ]]
  then
    local -$(Variable::GetDeclarationFlagFromType $returnValueType) \\"__self=$returnValueDefinition\\"
    variableName=__self
  fi

  # Log \\"Will assign: result=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\")\\"
  local resultString=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\" || { local falseBool=\\"\${__primitive_extension_fingerprint__boolean}:false\\"; __return_self_and_result=true @return falseBool $variableName; })
  # || echo \\"\${__return_separator}specialBool:\${__primitive_extension_fingerprint__boolean}:false\\"

  ## TODO: some problem here sometimes
  DEBUG Log \\"Result string: START | $resultString | END\\"

  local echoed=

  if [[ -z \\"$resultString\\" || \\"$resultString\\" != *\\"$__return_separator\\"* ]]
  then
    ## if resultString does not contain return_separator, use all as returnString and nothing as echo
    ## TODO: debug these situations if all ok.
    # theoretically, this is when no @return is present
    # or when no return separator provided - we use the echoed output as the result
    #
    ## implicit \\"string\\"
    local -a result=( \\"$(@get $variableName)\\" \\"$(@get resultString)\\" \\"string\\" )
  else
    # echo everything before the first occurrence of the separator
    echoed=\\"\${resultString%%$__return_separator*}\\"

    DEBUG [[ ! -z \\"$echoed\\" ]] && Log \\"Echoed: START | $(@get echoed) | END\\"

    # the result is everything after the first occurrence of the separator
    resultString=\\"\${resultString#*$__return_separator}\\"

    # Log \\"resultString: $resultString\\"
    local -a result=$resultString
    # eval \\"local -a result=$resultString\\"
  fi

  unset __self

  # declare -p result
  local assignResult=\\"\${result[0]}\\"

  DEBUG Log \\"Assign Result:\\"
  DEBUG Log \\"START $assignResult END\\"
  # declare -p assignResult

  local typeParam=$(Variable::GetDeclarationFlagFromType $type)

  DEBUG Log \\"Will eval: | $variableName=$assignResult |\\"
  # [[ \\"\${assignResult}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1

  if [[ \\"$typeParam\\" =~ [aA] ]]
  then
    # update the object
    eval \\"$variableName=$assignResult\\"
  else
    ## TODO: use the primitive extension fingerprint here, not in the methods themselves
    # assignResult=\\"$(Type::GetPrimitiveExtensionFingerprint $type):$assignResult\\"
    eval \\"$variableName=\\\\\\"\\\\$assignResult\\\\\\"\\"
  fi

  # update the result
  returnValueDefinition=\\"\${result[1]}\\"
  returnValueType=\\"\${result[2]}\\"

  # Log \\"returned: $returnValueType: $returnValueDefinition\\"

  # switch context for the next command
  if [[ \\"$assignResult\\" != \\"\${returnValueDefinition}\\" ]]
  then
    affectTheInitialVariable=false
    type=\\"$returnValueType\\" # $(Variable::GetPrimitiveTypeFromDeclarationFlag $returnValueType)
  fi

  printf %s \\"$echoed\\"

  ## cleanup vars:
  method=''
  params=()

  # TODO: this should work directly but doesn't
  # eval $variableName=\\\\$assignResult
}

Type::RunGetter() {
  local variableName=\\"$1\\"
  local type=\\"$2\\"

  if Function::Exists \\"$type.__getter__\\"
  then
    __return_self_and_result=false Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"__getter__\\"
  else
    @get \\"$variableName\\"
  fi
}

## TODO: private handling should be reimplemented - only this() should be able to access private entries
Type::Handle() {
  local variableName=\\"$1\\"
  local type=$(Type::GetTypeOfVariable \\"\${variableName}\\")
  local affectTheInitialVariable=true
  local -a propertyTree=(\\"$1\\")

  if [[ \\"$type\\" == \\"undefined\\" ]]
  then
    e=\\"No variable named: $variableName\\" throw
    return
  fi

  shift

  local returnValueDefinition
  local returnValueType

  local currentPropertyVisibility=public

  local multiExpression=false

  if [[ \\"$1\\" == ':' ]]
  then
    multiExpression=true
    shift
  fi

  DEBUG subject=\\"type handling\\" Log \\"START ANALYZING: type: $type | variable: $variableName $@\\"
  DEBUG subject=\\"type handling\\" Log \\"WHAT: $(declare -p $variableName)\\"

  # Log multiExpression $multiExpression

  if [[ $# -gt 0 ]]
  then
    local method
    local -a params
    local mode=method
    local prevMode
    local prevModeNext
    local bracketsStarted=false
    local -i closingBracketCount=0

    while [[ $# -gt 0 ]]
    do
      if [[ \\"$__access_private\\" != \\"true\\" && \\"$currentPropertyVisibility\\" == \\"private\\" ]]
      then
        e=\\"Trying to access a private property: $method\\" throw
        return
      fi

      prevModeNext=$mode

      if [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '{' ]]
      then
        if [[ $bracketsStarted == 'true' ]]
        then
          ## handle edge case of '}' as actual parameter
          while (( closingBracketCount+=-1 ))
          do
            params+=( '}' )
          done

          Type::RunCurrentStack
        fi
        bracketsStarted=true
        # mode=params
      elif [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '}' ]]
      then
        closingBracketCount+=1
        mode=method
        prevModeNext=params
      elif [[ \\"$mode\\" == 'params' ]]
      then
        params+=(\\"$1\\")
      elif [[ \\"$mode\\" == 'method' ]]
      then
        # Log $(@get __\${type}_property_names | array.indexOf $1) $1 idx
        # Log $(@get __\${type}_property_names | array.contains $1 && echo t)

        # Log index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${1})

        local typeSanitized=$(String::SanitizeForVariableName \${type})
        # local typeSanitized=\\"\${type//[^a-zA-Z0-9]/_}\\"

        if Variable::Exists __\${typeSanitized}_property_names &&
            @get __\${typeSanitized}_property_names | __return_self_and_result=false array.contains $1
        then
          # stack now belongs to selected property:
          local property=\\"$1\\"

          DEBUG Log found index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${property})
          # Log prop: $property of [$(@get __\${type}_property_names)]

          ## TODO: theoretically, we could get rid of: __return_self_and_result=false
          local -i index=$(@get __\${typeSanitized}_property_names | __return_self_and_result=false array.indexOf \${property})

          if [[ $index -ge 0 ]]
          then
            DEBUG Log \\"traversing to a child property $property of type $type\\"

            local newType=__\${typeSanitized}_property_types[$index]
            type=\${!newType}
            local typeParam=$(Variable::GetDeclarationFlagFromType $type)

            local currentPropertyVisibilityIndirect=__\${typeSanitized}_property_visibilities[$index]
            currentPropertyVisibility=\${!currentPropertyVisibilityIndirect}

            local propertyValueIndirect=$variableName[$property]

            if [[ -z \\"\${!propertyValueIndirect}\\" && \\"$typeParam\\" =~ [aA] ]]
            then
              local -$typeParam \\"__$property=()\\"
            else
              ## TODO: check if this preserves spaces correctly
              local -$typeParam \\"__$property=\${!propertyValueIndirect}\\"

              if ! Type::IsPrimitive \\"$type\\"
              then
                eval \\"__$property[__object_type]=\\\\\\"\\\\$type\\\\\\"\\"
              fi
            fi

            DEBUG Log \\".$property new $type value is: \\" # \${propertyValueIndirect} vs '\${!propertyValueIndirect}'
            DEBUG Log \\"$(declare -p __$property)\\"
            # affectTheInitialVariable=false

            ## TODO: variableName needs to be unique (add count at the end)
            ## in case the same property is nested
            variableName=__$property

            propertyTree+=(\\"$property\\")

            prevModeNext=property
          fi
          ### /selectProperty
        else
          mode=params
          method=\\"$1\\"
        fi
      fi
      prevMode=$prevModeNext

      DEBUG subject=\\"type handling\\" Log \\"iter: $1 | prevMode: $prevMode | mode: $mode | type: $type | variable: $variableName | method: $method | #params: \${#params[@]}\\"

      shift
    done

    if [[ \\"\${#method}\\" -gt 0 ]]
    then
      # Log 'running stack for:' $variableName
      Type::RunCurrentStack
      # Log 'output was:' \\"\${!variableName}\\"
      ## TODO: this does not work: (false boolean should return fail)
      [[ \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1 # && Log \\"LALALALA\\"
    elif [[ \\"$prevMode\\" == 'property' ]]
    then
      if [[ \\"$currentPropertyVisibility\\" == 'public' || \\"$__access_private\\" == \\"true\\" ]]
      then
        DEBUG subject='property' Log 'print out the property' $variableName
        ## print out the property or run the getter
        Type::RunGetter $variableName $type
      else
        e=\\"Property is private\\" throw
      fi
    fi

    ## TODO: shouldn't this be an elif ?
    # finally echo the latest return value if not empty
    if [[ ! -z \\"$returnValueDefinition\\" ]]
    then
      echo \\"$returnValueDefinition\\"
    fi

    ## UPDATE THE OBJECT RECURSIVELY:
    local -i propertyTreeLength=\${#propertyTree[@]}
    if [[ \${#propertyTree[@]} -gt 1 ]]
    then
      # Log PropertyTree: $(@get propertyTree)
      local -a reversedPropertyTree=$(@get propertyTree | __return_self_and_result=false array.reverse)

      local -i i=$propertyTreeLength
      local property
      local parent
      for parent in \\"\${reversedPropertyTree[@]}\\"
      do
        ## recursively insert the children into parents

        i+=-1
        (( $i == $propertyTreeLength - 1 )) && property=$parent && continue

        local parentVarName=__$parent

        (( $i == 0 )) && parentVarName=$parent

        local propertyDefinition=\\"$(@get __$property)\\"
        # Log \\"Will eval: $parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"
        eval \\"$parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"

        DEBUG Log \\"SETTING: ($i) $parentVarName.$property = \\\\\\"$propertyDefinition\\\\\\"\\"

        property=$parent
      done
    fi
  else
    #@get $variableName
    Type::RunGetter $variableName $type
  fi
}

## TODO: take note of what variables have handler functions in a global variable
## in @resolve:this save the list and then compare it in a @return
## -- or better yet -- to it in the parent that executes the method
## before and after execution

## question - how to add @resolve:this to all methods without explicitly stating it?

## \\"garbage collect\\", i.e. remove all the new references so they don't pollute the global scope

## note: declaration needs to be trimmed,
## since bash adds an enter at the end, hence %?
alias @resolve:this=\\"
  local __local_return_self_and_result=false
  [[ \\\\$__return_self_and_result == 'true' ]] && local __local_return_self_and_result=true && local __return_self_and_result=false
  # TODO: local __access_private_members_of=
  if [[ -z \\\\\${__use_this_transparently+x} ]];
  then
    local __declaration;
    local __declaration_type;

    if [[ ! -z \\\\\\"\\\\\${useReturnValueDefinition}\\\\\\" ]];
    then
      # subject='@resolve:this' Log 'using: ReturnValueDefinition'
      __declaration=\\\\\\"\\\\$returnValueDefinition\\\\\\"
      __declaration_type=\\\\$returnValueType
    elif [[ -z \\\\\${thisReference+x} && ! -t 0 ]];
    then
      # subject='@resolve:this' Log 'using: pipe'
      Pipe::Capture __declaration;
      __declaration_type=\\\\\${FUNCNAME[0]%.*}
      DEBUG Log capturing via pipe \\\\\${__declaration_type}
    else
      # subject='@resolve:this' Log 'using: thisReference:' $ \\\\$thisReference type: \\\\$thisReferenceType
      Variable::ExportDeclarationAndTypeToVariables \\\\$thisReference __declaration;
      __declaration_type=\\\\\\"\\\\$thisReferenceType\\\\\\"
      unset thisReference;
    fi;

    local typeParam=\\\\$(Variable::GetDeclarationFlagFromType \\\\\\"\\\\\${__declaration_type}\\\\\\" '-');
    # subject='@resolve:this' Log \\\\$__declaration_type = \\\\$typeParam = \\\\$__declaration

    # TODO: does it preserve spaces properly?
    local -\\\\$typeParam this=\\\\\${__declaration};

    ## add type for objects that don't have them set explicitly
    if [[ \\\\$typeParam == 'A' && \\\\$__declaration_type != 'map' && -z \\\\\${this[__object_type]+x} ]]
    then
      # Log setting object type
      this[__object_type]=\\\\\\"\\\\$__declaration_type\\\\\\"
    fi

    unset __declaration;
    unset __declaration_type;
  fi
  \\"

# ------------------------ #

import TypePrimitives
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/variable.sh 1`] = `
"import util/command
namespace util/variable

declare __declaration_type ## for Variable::ExportDeclarationAndTypeToVariables (?)

Variable::Exists() {
  local variableName=\\"$1\\"
  declare -p \\"$variableName\\" &> /dev/null
}

Variable::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'variable' \\"$startsWith\\" || true
}

Variable::GetDeclarationFlagFromType() {
  DEBUG subject=\\"GetParamFromType\\" Log 'getting param from type' \\"$@\\"

  local typeInfo=\\"$1\\"
  local fallback=\\"$2\\"

  if [[ \\"$typeInfo\\" == \\"map\\" ]] || Function::Exists \\"class:\${typeInfo}\\"
  then
    echo A
  else
    case \\"$typeInfo\\" in
      \\"reference\\")
        echo n
      ;;
      \\"array\\")
        echo a
      ;;
      \\"string\\" | \\"boolean\\")
        echo -
      ;;
      \\"integer\\")
        echo i
      ;;
      \\"integerArray\\")
        echo ai
      ;;
      *)
        echo \\"\${fallback:-A}\\"
      ;;
    esac
  fi
}

Variable::GetPrimitiveTypeFromDeclarationFlag() {
  local typeInfo=\\"$1\\"

  case \\"$typeInfo\\" in
    \\"n\\"*)
      echo reference
    ;;
    \\"a\\"*)
      echo array
    ;;
    \\"A\\"*)
      echo map
    ;;
    \\"i\\"*)
      echo integer
    ;;
    \\"ai\\"*)
      echo integerArray
    ;;
    \\"Ai\\"*)
      echo integerMap
    ;;
    *)
      echo string
    ;;
  esac
}

Variable::ExportDeclarationAndTypeToVariables() {
  local variableName=\\"$1\\"
  local targetVariable=\\"$2\\"
  local dereferrence=\\"\${3:-true}\\"

  # TODO: rename for a safer, less common variablename so parents can output to declaration
  local declaration
  local regexArray=\\"declare -([a-zA-Z-]+) $variableName='(.*)'\\"
  local regex=\\"declare -([a-zA-Z-]+) $variableName=\\\\\\"(.*)\\\\\\"\\"
  local regexArrayBash4_4=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p $variableName 2> /dev/null || true)

  local escaped=\\"'\\\\\\\\\\\\'\\"
  local escapedQuotes='\\\\\\\\\\"'
  local singleQuote='\\"'

  local doubleSlashes='\\\\\\\\\\\\\\\\'
  local singleSlash='\\\\'

  [[ -z \\"$definition\\" ]] && e=\\"Variable $variableName not defined\\" throw

  if [[ \\"$definition\\" =~ $regexArray ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\"
  elif [[ \\"$definition\\" =~ $regex ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\" ## TODO: is this transformation needed?
    declaration=\\"\${declaration//$escapedQuotes/$singleQuote}\\"
    declaration=\\"\${declaration//$doubleSlashes/$singleSlash}\\"
  elif [[ \\"$definition\\" =~ $regexArrayBash4_4 ]]
  then
    declaration=\\"\${BASH_REMATCH[2]}\\"
  fi

  local variableType

  DEBUG Log \\"Variable Is $variableName = $definition ==== \${BASH_REMATCH[1]}\\"

  local primitiveType=\${BASH_REMATCH[1]}

  local objectTypeIndirect=\\"$variableName[__object_type]\\"
  if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
  then
    DEBUG Log \\"Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
    variableType=\\"\${!objectTypeIndirect}\\"
  # elif [[ ! -z \${__primitive_extension_fingerprint__boolean+x} && \\"$primitiveType\\" == '-' && \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}\\"* ]]
  # then
  #   variableType=\\"boolean\\"
  else
    variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
    DEBUG Log \\"Primitive Type $primitiveType Resolved \${variableType}\\"
  fi

  if [[ \\"$variableType\\" == 'string' ]] && Function::Exists 'Type::GetPrimitiveExtensionFromVariable'
  then
    local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
    if [[ ! -z \\"$extensionType\\" ]]
    then
      variableType=\\"$extensionType\\"
    fi
  fi

  DEBUG Log \\"Variable $variableName is typeof $variableType\\"

  if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
  then
    local dereferrencedVariableName=\\"$declaration\\"
    Variable::ExportDeclarationAndTypeToVariables \\"$dereferrencedVariableName\\" \\"$targetVariable\\" \\"$dereferrence\\"
  else
    eval \\"$targetVariable=\\\\\\"\\\\$declaration\\\\\\"\\"
    eval \\"\${targetVariable}_type=\\\\$variableType\\"
  fi
}

Variable::PrintDeclaration() {
  local variableName=\\"\${1}\\"
  local dereferrence=\\"\${2:-true}\\"

  local __declaration
  local __declaration_type
  Variable::ExportDeclarationAndTypeToVariables \\"$variableName\\" __declaration \\"$dereferrence\\"
  echo \\"$__declaration\\"
}

alias @get='Variable::PrintDeclaration'
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-config/.gitignore 1`] = `
"/config
/crypto-config
"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-config/configtx.yaml 1`] = `
"################################################################################
#   SECTION: Capabilities
################################################################################
Capabilities:
    Channel: &ChannelCapabilities
        V1_4_3: true
    Orderer: &OrdererCapabilities
        V1_4_2: true
    Application: &ApplicationCapabilities
        V1_4_2: true

################################################################################
#   CHANNEL Defaults
################################################################################
Channel: &ChannelDefaults
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: \\"ANY Readers\\"
        Writers:
            Type: ImplicitMeta
            Rule: \\"ANY Writers\\"
        Admins:
            Type: ImplicitMeta
            Rule: \\"MAJORITY Admins\\"
    Capabilities:
        <<: *ChannelCapabilities

################################################################################
#   Section: Organizations
################################################################################
Organizations:
    - &OrdererOrg
        Name: Orderer
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/root.com/msp 
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.com/msp
        AnchorPeers:
            - Host: peer0.org1.com
              Port: 7051

################################################################################
#   SECTION: Application
################################################################################
Application: &ApplicationDefaults
    Organizations:
    Capabilities:
        <<: *ApplicationCapabilities

################################################################################
#   SECTION: Orderer
################################################################################
Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses: 
        - orderer0.root.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Organizations:

################################################################################
#   Profile
################################################################################
# https://github:com/hyperledger/fabric/blob/master/sampleconfig/configtx.yaml

Profiles:
    SoloOrdererGenesis:
        <<: *ChannelDefaults
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations: 
                    - *Org1
    AllOrgChannel:
        <<: *ChannelDefaults
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations: 
                - *Org1
            Capabilities:
                <<: *ApplicationCapabilities

"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-config/crypto-config-org1.yaml 1`] = `
"PeerOrgs:
  - Name: Org1
    Domain: org1.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabric-config/crypto-config-root.yaml 1`] = `
"OrdererOrgs:
  - Name: Orderer
    Domain: root.com
    Specs: 
      - Hostname: orderer0
    "
`;

exports[`e2e/__tmp__/sample-01 should create proper e2e/__tmp__/sample-01/fabrikkaConfig-1org-1channel-1chaincode.json 1`] = `
"{
  \\"fabrikkaVersion\\": \\"alpha-0.0.1\\",
  \\"fileVersion\\": \\"0.1\\",
  \\"networkSettings\\": {
    \\"fabricVersion\\": \\"1.4.3\\",
    \\"tls\\": false
  },
  \\"rootOrg\\": {
    \\"organization\\": {
      \\"key\\": \\"root\\",
      \\"name\\": \\"Orderer\\",
      \\"mspName\\": \\"OrdererMSP\\",
      \\"domain\\": \\"root.com\\"
    },
    \\"ca\\": {
      \\"prefix\\": \\"ca\\"
    },
    \\"orderer\\": {
      \\"prefix\\": \\"orderer\\",
      \\"consensus\\": \\"solo\\",
      \\"instances\\": 1
    }
  },
  \\"orgs\\": [
    {
      \\"organization\\": {
        \\"key\\": \\"org1\\",
        \\"name\\": \\"Org1\\",
        \\"mspName\\": \\"Org1MSP\\",
        \\"domain\\": \\"org1.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    }
  ],
  \\"channels\\": [
    {
      \\"key\\": \\"channel1\\",
      \\"name\\": \\"my-channel1\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer0\\",
            \\"peer1\\"
          ]
        }
      ]
    }
  ],
  \\"chaincodes\\": [
    {
      \\"name\\": \\"chaincode1\\",
      \\"version\\": \\"0.0.1\\",
      \\"lang\\": \\"java\\",
      \\"channel\\": \\"channel1\\",
      \\"init\\": \\"{'Args':[]}\\",
      \\"endorsement\\": \\"AND ('Org1.member')\\",
      \\"directory\\": \\"chaincode1\\"
    }
  ]
}
"
`;

exports[`e2e/__tmp__/sample-01 should create proper files 1`] = `
Array [
  "e2e/__tmp__/sample-01/fabric-compose.sh",
  "e2e/__tmp__/sample-01/fabric-compose/.env",
  "e2e/__tmp__/sample-01/fabric-compose/commands-generated.sh",
  "e2e/__tmp__/sample-01/fabric-compose/docker-compose.yaml",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/base-functions.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/base-help.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/cli/channel_fns.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Contains.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Intersect.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/List.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/Array/Reverse.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/GetSpaces.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/IsNumber.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/SanitizeForVariable.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/SlashReplacement.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/String/UUID.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Color.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Color.var.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Console.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/UI/Cursor.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/oo-bootstrap.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/bash4.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/class.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/command.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/exception.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/exits.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/log.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/namedParameters.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/pipe.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/test.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/tryCatch.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/type.sh",
  "e2e/__tmp__/sample-01/fabric-compose/scripts/lib/util/variable.sh",
  "e2e/__tmp__/sample-01/fabric-config/.gitignore",
  "e2e/__tmp__/sample-01/fabric-config/configtx.yaml",
  "e2e/__tmp__/sample-01/fabric-config/crypto-config-org1.yaml",
  "e2e/__tmp__/sample-01/fabric-config/crypto-config-root.yaml",
  "e2e/__tmp__/sample-01/fabrikkaConfig-1org-1channel-1chaincode.json",
]
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose.sh 1`] = `
"#!/bin/bash
SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

source \\"$BASEDIR\\"/fabric-compose/scripts/lib/oo-bootstrap.sh

source \\"$BASEDIR\\"/fabric-compose/scripts/base-help.sh
source \\"$BASEDIR\\"/fabric-compose/scripts/base-functions.sh
source \\"$BASEDIR\\"/fabric-compose/commands-generated.sh

source \\"$BASEDIR\\"/fabric-compose/.env

if [ \\"$1\\" = \\"up\\" ]; then
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"recreate\\" ]; then
  networkDown
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"down\\" ]; then
  networkDown
elif [ \\"$1\\" = \\"start\\" ]; then
  startNetwork
elif [ \\"$1\\" = \\"stop\\" ]; then
  stopNetwork
elif [ \\"$1\\" = \\"chaincodes\\" ] && [ \\"$2\\" = \\"install\\" ]; then
  installChaincodes
elif [ \\"$1\\" = \\"help\\" ]; then
  printHelp
elif [ \\"$1\\" = \\"--help\\" ]; then
  printHelp
else
  echo \\"No command specified\\"
  echo \\"Basic commands are: up, down, start, stop, recreate\\"
  echo \\"Also check: 'chaincodes install'\\"
  echo \\"Use 'help' or '--help' for more information\\"
fi
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/.env 1`] = `
"COMPOSE_PROJECT_NAME=network
FABRIC_VERSION=1.4.3
LOGGING_LEVEL=info

ROOT_CA_ADMIN_NAME=admin
ROOT_CA_ADMIN_PASSWORD=adminpw

ORG1_CA_ADMIN_NAME=admin
ORG1_CA_ADMIN_PASSWORD=adminpw

ORG2_CA_ADMIN_NAME=admin
ORG2_CA_ADMIN_PASSWORD=adminpw

"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/commands-generated.sh 1`] = `
"SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

function installChaincodes() {
  
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F60E\\"
    chaincodeInstall \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" # TODO to mi sie nie podoba. a gdzie uprawnienia ?
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F618\\"
    chaincodeInstantiate \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\"
    
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org2/peer0\\" \\"U1F60E\\"
    chaincodeInstall \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org2.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org2.com\\" # TODO to mi sie nie podoba. a gdzie uprawnienia ?
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org2/peer0\\" \\"U1F618\\"
    chaincodeInstantiate \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org2.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org2.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\"
    
}

function generateArtifacts() {
  printHeadline \\"Generating basic configs\\" \\"U1F913\\"
  printItalics \\"Generating crypto material for org Orderer\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-root.yaml\\" \\"ordererOrganizations/root.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org1\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org1.yaml\\" \\"peerOrganizations/org1.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org2\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org2.yaml\\" \\"peerOrganizations/org2.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating genesis block\\" \\"U1F3E0\\"
  genesisBlockCreate \\"$BASEDIR/fabric-config\\" \\"$BASEDIR/fabric-config/config\\"
}

function startNetwork() {
  printHeadline \\"Starting network\\" \\"U1F680\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose up -d
  cd $CURRENT_DIR
  sleep 4
}

function stopNetwork() {
  printHeadline \\"Stopping network\\" \\"U1F68F\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose stop
  cd $CURRENT_DIR
  sleep 4
}

function generateChannelsArtifacts() {
    printHeadline \\"Generating config for 'my-channel1'\\" \\"U1F913\\"
  createChannelTx \\"my-channel1\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
    printHeadline \\"Generating config for 'my-channel2'\\" \\"U1F913\\"
  createChannelTx \\"my-channel2\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
  }

function installChannels() {
  
    
    printHeadline \\"Creating 'my-channel1' on Org1/peer0\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoin 'my-channel1' 'Org1MSP' 'peer0.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'orderer0.root.com:7050';\\"
  
        
    printItalics \\"Joining 'my-channel1' on  Org2/peer0\\" \\"U1F638\\"
    docker exec -i cli.org2.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoin 'my-channel1' 'Org2MSP' 'peer0.org2.com:7051' 'crypto/users/Admin@org2.com/msp' 'orderer0.root.com:7050';\\"
  
        
    
    printHeadline \\"Creating 'my-channel2' on Org1/peer1\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoin 'my-channel2' 'Org1MSP' 'peer1.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'orderer0.root.com:7050';\\"
  
        
    printItalics \\"Joining 'my-channel2' on  Org2/peer1\\" \\"U1F638\\"
    docker exec -i cli.org2.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoin 'my-channel2' 'Org2MSP' 'peer1.org2.com:7051' 'crypto/users/Admin@org2.com/msp' 'orderer0.root.com:7050';\\"
  
        }

function networkDown() {
  printHeadline \\"Destroying network\\" \\"U1F916\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose down
  cd $CURRENT_DIR

  printf \\"\\\\nRemoving chaincode containers & images... \\\\U1F5D1 \\\\n\\"
   
  docker rm -f $(docker ps -a | grep dev-peer0.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  docker rm -f $(docker ps -a | grep dev-peer0.org2.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org2.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  printf \\"\\\\nRemoving generated configs... \\\\U1F5D1 \\\\n\\"
  rm -rf $BASEDIR/fabric-config/config
  rm -rf $BASEDIR/fabric-config/crypto-config

  printHeadline \\"Done! Network was purged\\" \\"U1F5D1\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/docker-compose.yaml 1`] = `
"version: '2.2'

networks:
  basic:

services:
  
  ca.root.com:
    container_name: ca.root.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.root.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.root.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7030:7054
    command: sh -c 'fabric-ca-server start -b \${ROOT_CA_ADMIN_NAME}:\${ROOT_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  orderer0.root.com:
    container_name: orderer0.root.com
    image: hyperledger/fabric-orderer:\${FABRIC_VERSION}
    environment:
      - ORDERER_GENERAL_LOGLEVEL=\${LOGGING_LEVEL}
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/config/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      - GODEBUG=netdns=go
      
    working_dir: /var/hyperledger/orderer
    command: orderer
    ports:
      - 7040:7050
    volumes:
      - ../fabric-config/config/:/var/hyperledger/config
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/msp/:/var/hyperledger/orderer/msp
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/tls/:/var/hyperledger/orderer/tls
    networks:
      - basic
    
  
  ca.org1.com:
    container_name: ca.org1.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org1.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7031:7054
    command: sh -c 'fabric-ca-server start -b \${ORG1_CA_ADMIN_NAME}:\${ORG1_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org1.com:
    container_name: cli.org1.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org1.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org1.com/msp
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
      
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org1.com:
    container_name: peer0.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7051:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org1.com:
    container_name: peer1.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer1.org1.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7052:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
  
  ca.org2.com:
    container_name: ca.org2.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org2.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org2.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7032:7054
    command: sh -c 'fabric-ca-server start -b \${ORG2_CA_ADMIN_NAME}:\${ORG2_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org2.com:
    container_name: cli.org2.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org2.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org2.com/msp
      - CORE_PEER_ADDRESS=peer0.org2.com:7051
      
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org2.com:
    container_name: peer0.org2.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org2.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_ADDRESS=peer0.org2.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7061:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer0.org2.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer0.org2.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org2.com:
    container_name: peer1.org2.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org2.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_ADDRESS=peer1.org2.com:7051
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7062:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer1.org2.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer1.org2.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/base-functions.sh 1`] = `
"import util/log
import util/tryCatch

function certsGenerate() {
  local CONTAINER_NAME=certsGenerate

  local CONFIG_PATH=$1
  local CRYPTO_CONFIG_FILE_NAME=$2
  local ORG_PATH=$3
  local OUTPUT_PATH=$4
  local FULL_CERT_PATH=$OUTPUT_PATH$ORG_PATH

  echo \\"Generating certs...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CRYPTO_CONFIG_FILE_NAME: $CRYPTO_CONFIG_FILE_NAME\\"
  inputLog \\"ORG_PATH: $ORG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"FULL_CERT_PATH: $FULL_CERT_PATH\\"

  if [ -d \\"$FULL_CERT_PATH\\" ]; then
    echo \\"Can't generate certs, directory already exists : $FULL_CERT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME cryptogen generate --config=./fabric-config/$CRYPTO_CONFIG_FILE_NAME

    docker cp $CONTAINER_NAME:/crypto-config/. $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }

  removeContainer $CONTAINER_NAME
  for file in $(find $OUTPUT_PATH/ -iname *_sk); do dir=$(dirname $file); mv \${dir}/*_sk \${dir}/priv-key.pem; done
}

function genesisBlockCreate() {
  local CONTAINER_NAME=genesisBlockCreate

  local CONFIG_PATH=$1
  local OUTPUT_PATH=$2

  echo \\"Creating genesis block...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"

  if [ -d \\"$OUTPUT_PATH\\" ]; then
    echo \\"Cant't generate genesis block, directory already exists : $OUTPUT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile SoloOrdererGenesis -outputBlock ./config/genesis.block || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createChannelTx() {
  local CONTAINER_NAME=createChannelTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local CHANNEL_TX_PATH=$OUTPUT_PATH\\"/\\"$CHANNEL_NAME\\".tx\\"

  echo \\"Creating channelTx for $CHANNEL_NAME...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CONFIG_PROFILE: $CONFIG_PROFILE\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"CHANNEL_TX_PATH: $CHANNEL_TX_PATH\\"

  if [ -f \\"$CHANNEL_TX_PATH\\" ]; then
    echo \\"Can't create channel configuration, it already exists : $CHANNEL_TX_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputCreateChannelTx ./config/channel.tx -channelID \${CHANNEL_NAME} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/channel.tx $CHANNEL_TX_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createAnchorPeerUpdateTx() {
  local CONTAINER_NAME=createAnchorPeerUpdateTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local MSP=$5
  local ANCHOR_PEER_UPDATE_PATH=$OUTPUT_PATH\\"/\\"$MSP\\"anchors.tx\\"

  if [ -f \\"$ANCHOR_PEER_UPDATE_PATH\\" ]; then
    echo \\"Cant't create anchor peer update, it already exists : $ANCHOR_PEER_UPDATE_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputAnchorPeersUpdate ./config/\${MSP}anchors.tx -channelID \${CHANNEL_NAME} -asOrg \${MSP} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/\${MSP}anchors.tx $ANCHOR_PEER_UPDATE_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function chaincodeInstall() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"
  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation. Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiate() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate. Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function chaincodeInstallTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8
  local CA_CERT=\\"/var/hyperledger/cli/\\"$9

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation (TLS). Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiateTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}
  local CA_CERT=\\"/var/hyperledger/cli/\\"\${11}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate (TLS). Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function printHeadline() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Bold)============ %b %s %b ==============$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function printItalics() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Italics)==== %b %s %b ====$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function inputLog() {
  echo \\"$(UI.Color.DarkGray)   $1 $(UI.Color.Default)\\"
}

function certsRemove() {
  local CERTS_DIR_PATH=$1
  rm -rf \\"$CERTS_DIR_PATH\\"/*
}

function removeContainer() {
  CONTAINER_NAME=$1
  docker rm -f \\"$CONTAINER_NAME\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/base-help.sh 1`] = `
"function printHelp() {
  echo \\"Fabrikka is powered by SoftwareMill\\"

  echo \\"\\"
  echo \\"usage: ./fabric-compose.sh <command>\\"
  echo \\"\\"

  echo \\"Commands: \\"
  echo \\"\\"
  echo \\"./fabric-compose.sh up\\"
  echo -e \\"\\\\t Use for first run. Creates all needed artifacts (certs, genesis block) and starts network for the first time.\\"
  echo -e \\"\\\\t After 'up' commands start/stop are used to manage network and rerun to rerun it\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh down\\"
  echo -e \\"\\\\t Back to empty state - destorys created containers, prunes generated certificates, configs.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh start\\"
  echo -e \\"\\\\t Starts already created network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh stop\\"
  echo -e \\"\\\\t Stops already running network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh recreate\\"
  echo -e \\"\\\\t Fresh start - it destorys whole network, certs, configs and then reruns everything.\\"
  echo \\"\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/cli/channel_fns.sh 1`] = `
"function createChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-createChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx
  peer channel join -b \${CHANNEL_NAME}.block

  rm -rf $DIR_NAME
}

function createChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-createChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}

function fetchChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-fetchChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL}
  peer channel join -b \${CHANNEL_NAME}_newest.block

  rm -rf $DIR_NAME
}

function fetchChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-fetchChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL} --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}_newest.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Contains.sh 1`] = `
"Array::Contains() {
  local element
  for element in \\"\${@:2}\\"
  do
    [[ \\"$element\\" = \\"$1\\" ]] && return 0
  done
  return 1
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Intersect.sh 1`] = `
"import util/namedParameters util/type

Array::Intersect() {
  @required [array] arrayA
  @required [array] arrayB

  array intersection

  # http://stackoverflow.com/questions/2312762/compare-difference-of-two-arrays-in-bash
  for i in \\"\${arrayA[@]}\\"
  do
    local skip=
    for j in \\"\${arrayB[@]}\\"
    do
      [[ \\"$i\\" == \\"$j\\" ]] && { skip=1; break; }
    done
    [[ -n $skip ]] || intersection+=(\\"$i\\")
  done

  @get intersection
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/List.sh 1`] = `
"import util/namedParameters

## generates a list separated by new lines
Array::List() {
  @required [string] variableName
  [string] separator=$'\\\\n'

  local indirectAccess=\\"\${variableName}[*]\\"
  (
    local IFS=\\"$separator\\"
    echo \\"\${!indirectAccess}\\"
  )
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Reverse.sh 1`] = `
"import util/namedParameters

## TODO: consider making Parameters::Methods
## since this actually modifies parameters, not arrays

## static methods should be Array::Method, with capital letter

# static version
Array::Reverse() {
  [...rest] this

  local -i length=\${#this[@]}  #$(this length)
  local -a outArray
  local -i indexFromEnd
  local -i index

  for index in \\"\${!this[@]}\\"
  do
    indexFromEnd=$(( $length - 1 - $index ))
    outArray+=( \\"\${this[$indexFromEnd]}\\" )
  done

  @get outArray
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/GetSpaces.sh 1`] = `
"String::GetSpaces() {
  local howMany=\\"$1\\"

  if [[ \\"$howMany\\" -gt 0 ]]
  then
    ( printf \\"%*s\\" \\"$howMany\\" )
  fi
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/IsNumber.sh 1`] = `
"String::IsNumber() {
  local input=\\"$1\\"

  local regex='^-?[0-9]+([.][0-9]+)?$'
  if ! [[ \\"$input\\" =~ $regex ]]
  then
    return 1
  fi
  return 0
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/SanitizeForVariable.sh 1`] = `
"String::SanitizeForVariableName() {
  local type=\\"$1\\"
  echo \\"\${type//[^a-zA-Z0-9]/_}\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/SlashReplacement.sh 1`] = `
"String::ReplaceSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slash$slash/$slashReplacement}\\"
}

String::RestoreSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slashReplacement/$slash}\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/UUID.sh 1`] = `
"String::GenerateUUID() {
  ## https://gist.github.com/markusfisch/6110640
  local N B C='89ab'

  for (( N=0; N < 16; ++N ))
  do
    B=$(( $RANDOM%256 ))

    case $N in
      6)
        printf '4%x' $(( B%16 ))
      ;;
      8)
        printf '%c%x' \${C:$RANDOM%\${#C}:1} $(( B%16 ))
      ;;
      3 | 5 | 7 | 9)
        printf '%02x-' $B
      ;;
      *)
        printf '%02x' $B
      ;;
    esac
  done
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Color.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  alias UI.Color.Default=\\"echo \\\\$'\\\\033[0m'\\"

  alias UI.Color.Black=\\"echo \\\\$'\\\\033[0;30m'\\"
  alias UI.Color.Red=\\"echo \\\\$'\\\\033[0;31m'\\"
  alias UI.Color.Green=\\"echo \\\\$'\\\\033[0;32m'\\"
  alias UI.Color.Yellow=\\"echo \\\\$'\\\\033[0;33m'\\"
  alias UI.Color.Blue=\\"echo \\\\$'\\\\033[0;34m'\\"
  alias UI.Color.Magenta=\\"echo \\\\$'\\\\033[0;35m'\\"
  alias UI.Color.Cyan=\\"echo \\\\$'\\\\033[0;36m'\\"
  alias UI.Color.LightGray=\\"echo \\\\$'\\\\033[0;37m'\\"

  alias UI.Color.DarkGray=\\"echo \\\\$'\\\\033[0;90m'\\"
  alias UI.Color.LightRed=\\"echo \\\\$'\\\\033[0;91m'\\"
  alias UI.Color.LightGreen=\\"echo \\\\$'\\\\033[0;92m'\\"
  alias UI.Color.LightYellow=\\"echo \\\\$'\\\\033[0;93m'\\"
  alias UI.Color.LightBlue=\\"echo \\\\$'\\\\033[0;94m'\\"
  alias UI.Color.LightMagenta=\\"echo \\\\$'\\\\033[0;95m'\\"
  alias UI.Color.LightCyan=\\"echo \\\\$'\\\\033[0;96m'\\"
  alias UI.Color.White=\\"echo \\\\$'\\\\033[0;97m'\\"

  # flags
  alias UI.Color.Bold=\\"echo \\\\$'\\\\033[1m'\\"
  alias UI.Color.Dim=\\"echo \\\\$'\\\\033[2m'\\"
  alias UI.Color.Italics=\\"echo \\\\$'\\\\033[3m'\\"
  alias UI.Color.Underline=\\"echo \\\\$'\\\\033[4m'\\"
  alias UI.Color.Blink=\\"echo \\\\$'\\\\033[5m'\\"
  alias UI.Color.Invert=\\"echo \\\\$'\\\\033[7m'\\"
  alias UI.Color.Invisible=\\"echo \\\\$'\\\\033[8m'\\"

  alias UI.Color.NoBold=\\"echo \\\\$'\\\\033[21m'\\"
  alias UI.Color.NoDim=\\"echo \\\\$'\\\\033[22m'\\"
  alias UI.Color.NoItalics=\\"echo \\\\$'\\\\033[23m'\\"
  alias UI.Color.NoUnderline=\\"echo \\\\$'\\\\033[24m'\\"
  alias UI.Color.NoBlink=\\"echo \\\\$'\\\\033[25m'\\"
  alias UI.Color.NoInvert=\\"echo \\\\$'\\\\033[27m'\\"
  alias UI.Color.NoInvisible=\\"echo \\\\$'\\\\033[28m'\\"
else
  alias UI.Color.Default=\\"echo\\"

  alias UI.Color.Black=\\"echo\\"
  alias UI.Color.Red=\\"echo\\"
  alias UI.Color.Green=\\"echo\\"
  alias UI.Color.Yellow=\\"echo\\"
  alias UI.Color.Blue=\\"echo\\"
  alias UI.Color.Magenta=\\"echo\\"
  alias UI.Color.Cyan=\\"echo\\"
  alias UI.Color.LightGray=\\"echo\\"

  alias UI.Color.DarkGray=\\"echo\\"
  alias UI.Color.LightRed=\\"echo\\"
  alias UI.Color.LightGreen=\\"echo\\"
  alias UI.Color.LightYellow=\\"echo\\"
  alias UI.Color.LightBlue=\\"echo\\"
  alias UI.Color.LightMagenta=\\"echo\\"
  alias UI.Color.LightCyan=\\"echo\\"
  alias UI.Color.White=\\"echo\\"

  # flags
  alias UI.Color.Bold=\\"echo\\"
  alias UI.Color.Dim=\\"echo\\"
  alias UI.Color.Underline=\\"echo\\"
  alias UI.Color.Blink=\\"echo\\"
  alias UI.Color.Invert=\\"echo\\"
  alias UI.Color.Invisible=\\"echo\\"

  alias UI.Color.NoBold=\\"echo\\"
  alias UI.Color.NoDim=\\"echo\\"
  alias UI.Color.NoUnderline=\\"echo\\"
  alias UI.Color.NoBlink=\\"echo\\"
  alias UI.Color.NoInvert=\\"echo\\"
  alias UI.Color.NoInvisible=\\"echo\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  alias UI.Powerline.PointingArrow=\\"echo -e $'\\\\u27a1'\\"
  alias UI.Powerline.ArrowLeft=\\"echo -e $'\\\\u25c0'\\"
  alias UI.Powerline.ArrowRight=\\"echo -e $'\\\\u25b6'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo -e $'\\\\u2198'\\"
  alias UI.Powerline.ArrowDown=\\"echo -e $'\\\\u2B07'\\"
  alias UI.Powerline.PlusMinus=\\"echo -e $'\\\\ue00b1'\\"
  alias UI.Powerline.Branch=\\"echo -e $'\\\\ue0a0'\\"
  alias UI.Powerline.RefersTo=\\"echo -e $'\\\\u27a6'\\"
  alias UI.Powerline.OK=\\"echo -e $'\\\\u2714'\\"
  alias UI.Powerline.Fail=\\"echo -e $'\\\\u2718'\\"
  alias UI.Powerline.Lightning=\\"echo -e $'\\\\u26a1'\\"
  alias UI.Powerline.Cog=\\"echo -e $'\\\\u2699'\\"
  alias UI.Powerline.Heart=\\"echo -e $'\\\\u2764'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo -e $'\\\\u2b50'\\"
  alias UI.Powerline.Saxophone=\\"echo -e $'\\\\U1F3B7'\\"
  alias UI.Powerline.ThumbsUp=\\"echo -e $'\\\\U1F44D'\\"
else
  alias UI.Powerline.PointingArrow=\\"echo '~'\\"
  alias UI.Powerline.ArrowLeft=\\"echo '<'\\"
  alias UI.Powerline.ArrowRight=\\"echo '>'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo '>'\\"
  alias UI.Powerline.ArrowDown=\\"echo '_'\\"
  alias UI.Powerline.PlusMinus=\\"echo '+-'\\"
  alias UI.Powerline.Branch=\\"echo '|}'\\"
  alias UI.Powerline.RefersTo=\\"echo '*'\\"
  alias UI.Powerline.OK=\\"echo '+'\\"
  alias UI.Powerline.Fail=\\"echo 'x'\\"
  alias UI.Powerline.Lightning=\\"echo '!'\\"
  alias UI.Powerline.Cog=\\"echo '{*}'\\"
  alias UI.Powerline.Heart=\\"echo '<3'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo '*''\\"
  alias UI.Powerline.Saxophone=\\"echo '(YEAH)'\\"
  alias UI.Powerline.ThumbsUp=\\"echo '(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Color.var.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  UI_Color_Default=$'\\\\033[0m'

  UI_Color_Black=$'\\\\033[0;30m'
  UI_Color_Red=$'\\\\033[0;31m'
  UI_Color_Green=$'\\\\033[0;32m'
  UI_Color_Yellow=$'\\\\033[0;33m'
  UI_Color_Blue=$'\\\\033[0;34m'
  UI_Color_Magenta=$'\\\\033[0;35m'
  UI_Color_Cyan=$'\\\\033[0;36m'
  UI_Color_LightGray=$'\\\\033[0;37m'

  UI_Color_DarkGray=$'\\\\033[0;90m'
  UI_Color_LightRed=$'\\\\033[0;91m'
  UI_Color_LightGreen=$'\\\\033[0;92m'
  UI_Color_LightYellow=$'\\\\033[0;93m'
  UI_Color_LightBlue=$'\\\\033[0;94m'
  UI_Color_LightMagenta=$'\\\\033[0;95m'
  UI_Color_LightCyan=$'\\\\033[0;96m'
  UI_Color_White=$'\\\\033[0;97m'

  # flags
  UI_Color_Bold=$'\\\\033[1m'
  UI_Color_Dim=$'\\\\033[2m'
  UI_Color_Italics=$'\\\\033[3m'
  UI_Color_Underline=$'\\\\033[4m'
  UI_Color_Blink=$'\\\\033[5m'
  UI_Color_Invert=$'\\\\033[7m'
  UI_Color_Invisible=$'\\\\033[8m'

  UI_Color_NoBold=$'\\\\033[21m'
  UI_Color_NoDim=$'\\\\033[22m'
  UI_Color_NoItalics=$'\\\\033[23m'
  UI_Color_NoUnderline=$'\\\\033[24m'
  UI_Color_NoBlink=$'\\\\033[25m'
  UI_Color_NoInvert=$'\\\\033[27m'
  UI_Color_NoInvisible=$'\\\\033[28m'
else
  UI_Color_Default=\\"\\"

  UI_Color_Black=\\"\\"
  UI_Color_Red=\\"\\"
  UI_Color_Green=\\"\\"
  UI_Color_Yellow=\\"\\"
  UI_Color_Blue=\\"\\"
  UI_Color_Magenta=\\"\\"
  UI_Color_Cyan=\\"\\"
  UI_Color_LightGray=\\"\\"

  UI_Color_DarkGray=\\"\\"
  UI_Color_LightRed=\\"\\"
  UI_Color_LightGreen=\\"\\"
  UI_Color_LightYellow=\\"\\"
  UI_Color_LightBlue=\\"\\"
  UI_Color_LightMagenta=\\"\\"
  UI_Color_LightCyan=\\"\\"
  UI_Color_White=\\"\\"

  # flags
  UI_Color_Bold=\\"\\"
  UI_Color_Dim=\\"\\"
  UI_Color_Italics=\\"\\"
  UI_Color_Underline=\\"\\"
  UI_Color_Blink=\\"\\"
  UI_Color_Invert=\\"\\"
  UI_Color_Invisible=\\"\\"

  UI_Color_NoBold=\\"\\"
  UI_Color_NoDim=\\"\\"
  UI_Color_NoItalics=\\"\\"
  UI_Color_NoUnderline=\\"\\"
  UI_Color_NoBlink=\\"\\"
  UI_Color_NoInvert=\\"\\"
  UI_Color_NoInvisible=\\"\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  UI_Powerline_PointingArrow=$'\\\\u27a1'
  UI_Powerline_ArrowLeft=$'\\\\ue0b2'
  UI_Powerline_ArrowRight=$'\\\\ue0b0'
  UI_Powerline_ArrowRightDown=$'\\\\u2198'
  UI_Powerline_ArrowDown=$'\\\\u2B07'
  UI_Powerline_PlusMinus=$'\\\\ue00b1'
  UI_Powerline_Branch=$'\\\\ue0a0'
  UI_Powerline_RefersTo=$'\\\\u27a6'
  UI_Powerline_OK=$'\\\\u2714'
  UI_Powerline_Fail=$'\\\\u2718'
  UI_Powerline_Lightning=$'\\\\u26a1'
  UI_Powerline_Cog=$'\\\\u2699'
  UI_Powerline_Heart=$'\\\\u2764'

  # colorful
  UI_Powerline_Star=$'\\\\u2b50'
  UI_Powerline_Saxophone=$'\\\\U1F3B7'
  UI_Powerline_ThumbsUp=$'\\\\U1F44D'
else
  UI_Powerline_PointingArrow=\\"'~'\\"
  UI_Powerline_ArrowLeft=\\"'<'\\"
  UI_Powerline_ArrowRight=\\"'>'\\"
  UI_Powerline_ArrowRightDown=\\"'>'\\"
  UI_Powerline_ArrowDown=\\"'_'\\"
  UI_Powerline_PlusMinus=\\"'+-'\\"
  UI_Powerline_Branch=\\"'|}'\\"
  UI_Powerline_RefersTo=\\"'*'\\"
  UI_Powerline_OK=\\"'+'\\"
  UI_Powerline_Fail=\\"'x'\\"
  UI_Powerline_Lightning=\\"'!'\\"
  UI_Powerline_Cog=\\"'{*}'\\"
  UI_Powerline_Heart=\\"'<3'\\"

  # colorful
  UI_Powerline_Star=\\"'*''\\"
  UI_Powerline_Saxophone=\\"'(YEAH)'\\"
  UI_Powerline_ThumbsUp=\\"'(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Console.sh 1`] = `
"import UI/Color

Console::WriteStdErr() {
  # http://stackoverflow.com/questions/2990414/echo-that-outputs-to-stderr
  cat <<< \\"$*\\" 1>&2
  return
}

Console::WriteStdErrAnnotated() {
  local script=\\"$1\\"
  local lineNo=$2
  local color=$3
  local type=$4
  shift; shift; shift; shift

  Console::WriteStdErr \\"$color[$type] $(UI.Color.Blue)[\${script}:\${lineNo}]$(UI.Color.Default) $* \\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Cursor.sh 1`] = `
"import util/class

class:UI.Cursor() {
  # http://askubuntu.com/questions/366103/saving-more-corsor-positions-with-tput-in-bash-terminal
	# http://unix.stackexchange.com/questions/88296/get-vertical-cursor-position

	private integer x
	private integer y

  UI.Cursor.capture() {
    local x
    local y
    IFS=';' read -sdR -p $'\\\\E[6n' y x

    this y = $(( \${y#*[} - 1 ))
    this x = $(( \${x} - 1 ))

    @return
  }

  UI.Cursor.restore() {
    [integer] shift=1

    local -i totalHeight=$(tput lines)
    local -i y=$(this y)
    local -i x=$(this x)

    (( $y + 1 == $totalHeight )) && y+=-$shift

    tput cup $y $x

    @return
  }
}

Type::Initialize UI.Cursor
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/oo-bootstrap.sh 1`] = `
"#!/usr/bin/env bash

###########################
### BOOTSTRAP FUNCTIONS ###
###########################

if [[ -n \\"\${__INTERNAL_LOGGING__:-}\\" ]]
then
  alias DEBUG=\\":; \\"
else
  alias DEBUG=\\":; #\\"
fi

System::SourceHTTP() {
  local URL=\\"$1\\"
  local -i RETRIES=3
  shift

  if hash curl 2>/dev/null
  then
    builtin source <(curl --fail -sL --retry $RETRIES \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && curl --fail -sL --retry $RETRIES \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  else
    builtin source <(wget -t $RETRIES -O - -o /dev/null \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && wget -t $RETRIES -O - -o /dev/null \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  fi
  __oo__importedFiles+=( \\"$URL\\" )
}

System::SourcePath() {
  local libPath=\\"$1\\"
  shift
  # echo trying $libPath
  if [[ -d \\"$libPath\\" ]]
  then
    local file
    for file in \\"$libPath\\"/*.sh
    do
      System::SourceFile \\"$file\\" \\"$@\\"
    done
  else
    System::SourceFile \\"$libPath\\" \\"$@\\" || System::SourceFile \\"\${libPath}.sh\\" \\"$@\\"
  fi
}

declare -g __oo__fdPath=$(dirname <(echo))
declare -gi __oo__fdLength=$(( \${#__oo__fdPath} + 1 ))

System::ImportOne() {
  local libPath=\\"$1\\"
  local __oo__importParent=\\"\${__oo__importParent-}\\"
  local requestedPath=\\"$libPath\\"
  shift

  if [[ \\"$requestedPath\\" == 'github:'* ]]
  then
    requestedPath=\\"https://raw.githubusercontent.com/\${requestedPath:7}\\"
  elif [[ \\"$requestedPath\\" == './'* ]]
  then
    requestedPath=\\"\${requestedPath:2}\\"
  elif [[ \\"$requestedPath\\" == \\"$__oo__fdPath\\"* ]] # starts with /dev/fd
  then
    requestedPath=\\"\${requestedPath:$__oo__fdLength}\\"
  fi

  # [[ \\"$__oo__importParent\\" == 'http://'* || \\"$__oo__importParent\\" == 'https://'* ]] &&
  if [[ \\"$requestedPath\\" != 'http://'* && \\"$requestedPath\\" != 'https://'* ]]
  then
    requestedPath=\\"\${__oo__importParent}/\${requestedPath}\\"
  fi

  if [[ \\"$requestedPath\\" == 'http://'* || \\"$requestedPath\\" == 'https://'* ]]
  then
    __oo__importParent=$(dirname \\"$requestedPath\\") System::SourceHTTP \\"$requestedPath\\"
    return
  fi

  # try relative to parent script
  # try with parent
  # try without parent
  # try global library
  # try local library
  {
    local localPath=\\"$( cd \\"\${BASH_SOURCE[1]%/*}\\" && pwd )\\"
    localPath=\\"\${localPath}/\${libPath}\\"
    System::SourcePath \\"\${localPath}\\" \\"$@\\"
  } || \\\\
  System::SourcePath \\"\${requestedPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__libPath}/\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__path}/\${libPath}\\" \\"$@\\" || e=\\"Cannot import $libPath\\" throw
}

System::Import() {
  local libPath
  for libPath in \\"$@\\"
  do
    System::ImportOne \\"$libPath\\"
  done
}

File::GetAbsolutePath() {
  # http://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
  # $1 : relative filename
  local file=\\"$1\\"
  if [[ \\"$file\\" == \\"/\\"* ]]
  then
    echo \\"$file\\"
  else
    echo \\"$(cd \\"$(dirname \\"$file\\")\\" && pwd)/$(basename \\"$file\\")\\"
  fi
}

System::WrapSource() {
  local libPath=\\"$1\\"
  shift

  builtin source \\"$libPath\\" \\"$@\\" || throw \\"Unable to load $libPath\\"
}

System::SourceFile() {
  local libPath=\\"$1\\"
  shift

  # DEBUG subject=level3 Log \\"Trying to load from: \${libPath}\\"
  [[ ! -f \\"$libPath\\" ]] && return 1 # && e=\\"Cannot import $libPath\\" throw

  libPath=\\"$(File::GetAbsolutePath \\"$libPath\\")\\"

  # echo \\"importing $libPath\\"

  # [ -e \\"$libPath\\" ] && echo \\"Trying to load from: \${libPath}\\"
  if [[ -f \\"$libPath\\" ]]
  then
    ## if already imported let's return
    # if declare -f \\"Array::Contains\\" &> /dev/null &&
    if [[ \\"\${__oo__allowFileReloading-}\\" != true ]] && [[ ! -z \\"\${__oo__importedFiles[*]}\\" ]] && Array::Contains \\"$libPath\\" \\"\${__oo__importedFiles[@]}\\"
    then
      # DEBUG subject=level3 Log \\"File previously imported: \${libPath}\\"
      return 0
    fi

    # DEBUG subject=level2 Log \\"Importing: $libPath\\"

    __oo__importedFiles+=( \\"$libPath\\" )
    __oo__importParent=$(dirname \\"$libPath\\") System::WrapSource \\"$libPath\\" \\"$@\\"
    # eval \\"$(<\\"$libPath\\")\\"

  else
    :
    # DEBUG subject=level2 Log \\"File doesn't exist when importing: $libPath\\"
  fi
}

System::Bootstrap() {
  ## note: aliases are visible inside functions only if
  ## they were initialized AFTER they were created
  ## this is the reason why we have to load files in a specific order
  if ! System::Import Array/Contains
  then
    cat <<< \\"FATAL ERROR: Unable to bootstrap (missing lib directory?)\\" 1>&2
    exit 1
  fi
}

########################
### INITIALZE SYSTEM ###
########################

# From: http://wiki.bash-hackers.org/scripting/debuggingtips
export PS4='+(\${BASH_SOURCE##*/}:\${LINENO}): \${FUNCNAME[0]:+\${FUNCNAME[0]}(): }'

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail

shopt -s expand_aliases
declare -g __oo__libPath=\\"$( cd \\"\${BASH_SOURCE[0]%/*}\\" && pwd )\\"
declare -g __oo__path=\\"\${__oo__libPath}/..\\"
declare -ag __oo__importedFiles

## stubs in case either exception or log is not loaded
namespace() { :; }
throw() { eval 'cat <<< \\"Exception: $e ($*)\\" 1>&2; read -s;'; }

System::Bootstrap

alias import=\\"__oo__allowFileReloading=false System::Import\\"
alias source=\\"__oo__allowFileReloading=true System::ImportOne\\"
alias .=\\"__oo__allowFileReloading=true System::ImportOne\\"

declare -g __oo__bootstrapped=true
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/bash4.sh 1`] = `
"[[ \\"\${BASH_VERSINFO[0]}\\" -lt 4 ]] && echo \\"The module you are trying to load requires bash >= 4\\" && exit 1 || true
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/class.sh 1`] = `
"namespace util/type
import util/type String/SanitizeForVariable
# ------------------------ #

Type::DefineProperty() {
  local visibility=\\"$1\\"
  local class=\\"$2\\"
  local type=\\"$3\\"
  local property=\\"$4\\"
  local assignment=\\"$5\\"
  local defaultValue=\\"$6\\"

  class=\\"\${class//[^a-zA-Z0-9]/_}\\"

  eval \\"__\${class}_property_names+=( '$property' )\\"
  eval \\"__\${class}_property_types+=( '$type' )\\"
  eval \\"__\${class}_property_visibilities+=( '$visibility' )\\"
  # if [[ \\"$assignment\\" == '=' && ! -z \\"$defaultValue\\" ]]
  # then
    eval \\"__\${class}_property_defaults+=( \\\\\\"\\\\$defaultValue\\\\\\" )\\"
  # fi
}

private() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty private $class \\"$@\\"
}

public() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty public $class \\"$@\\"
}

Type::Initialize() {
  local name=\\"$1\\"
  local style=\\"\${2:-default}\\"

  Function::Exists class:$name && class:$name || true

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"

  case \\"$style\\" in
    'primitive') ;;
    'static')
      declare -Ag __oo_static_instance_\${name}=\\"$(Type::Construct $name)\\"
      eval \\"\${name}\\"'(){ '\\"Type::Handle __oo_static_instance_\${name}\\"' \\"$@\\"; }'
    ;;
    *)
      ## add alias for parameters
      alias [$name]=\\"_type=$name Variable::TrapAssign local -A\\"

      ## add alias for creating vars
      alias $name=\\"_type=$name Type::TrapAssign declare -A\\"
    ;;
  esac
}

Type::InitializeStatic() {
  local name=\\"$1\\"

  Type::Initialize \\"$name\\" static
}

Type::Construct() {
  local type=\\"$1\\"
  local typeSanitized=$(String::SanitizeForVariableName $type)
  local assignToVariable=\\"$2\\"

  if [[ ! -z \\"\${__constructor_recursion+x}\\" ]]
  then
    __constructor_recursion=$(( \${__constructor_recursion} + 1 ))
  fi

  local -A constructedType=( [__object_type]=\\"$type\\" )
  # else
  #   echo \\"$assignToVariable[__object_type]=\\\\\\"$type\\\\\\"\\"
  # fi

  if Variable::Exists \\"__\${typeSanitized}_property_names\\"
  then
    local propertyIndexesIndirect=\\"__\${typeSanitized}_property_names[@]\\"
    local -i propertyIndex=0
    local propertyName
    for propertyName in \\"\${!propertyIndexesIndirect}\\"
    do
      # local propertyNameIndirect=__\${typeSanitized}_property_names[$propertyIndex]
      # local propertyName=\\"\${!propertyNameIndirect}\\"

      local propertyTypeIndirect=__\${typeSanitized}_property_types[$propertyIndex]
      local propertyType=\\"\${!propertyTypeIndirect}\\"

      local defaultValueIndirect=__\${typeSanitized}_property_defaults[$propertyIndex]
      local defaultValue=\\"\${!defaultValueIndirect}\\"

      if [[ $propertyType == 'boolean' ]] && [[ \\"$defaultValue\\" == 'false' || \\"$defaultValue\\" == 'true' ]]
      then
        defaultValue=\\"\${__primitive_extension_fingerprint__boolean}:$defaultValue\\"
      fi

      local constructedPropertyDefinition=\\"$defaultValue\\"

      DEBUG Log \\"iterating type: \${typeSanitized}, property: [$propertyIndex] $propertyName = $defaultValue\\"

      ## AUTOMATICALLY CONSTRUCTS THE PROPERTIES:
      # case \\"$propertyType\\" in
      #   'array'|'map'|'string'|'integer'|'integerArray') ;;
      #       # 'integer') constructedPropertyDefinition=\\"\${__integer_fingerprint}$defaultValue\\" ;;
      #       # 'integerArray') constructedPropertyDefinition=\\"\${__integer_array_fingerprint}$defaultValue\\" ;;
      #   * )
      #     if [[ -z \\"$defaultValue\\" && \\"$__constructor_recursion\\" -lt 15 ]]
      #     then
      #       constructedPropertyDefinition=$(Type::Construct \\"$propertyType\\")
      #     fi
      #   ;;
      # esac

      if [[ ! -z \\"$constructedPropertyDefinition\\" ]]
      then
        ## initialize non-empty fields

        DEBUG Log \\"Will exec: constructedType+=( [\\\\\\"$propertyName\\\\\\"]=\\\\\\"$constructedPropertyDefinition\\\\\\" )\\"
        constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )
        # eval 'constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )'
      fi

      propertyIndex+=1
    done
  fi

  if [[ -z \\"$assignToVariable\\" ]]
  then
    Variable::PrintDeclaration constructedType
  else
    local constructedIndex
    for constructedIndex in \\"\${!constructedType[@]}\\"
    do
      eval \\"$assignToVariable[\\\\\\"\\\\$constructedIndex\\\\\\"]=\\\\\\"\\\\\${constructedType[\\\\\\"\\\\$constructedIndex\\\\\\"]}\\\\\\"\\"
    done
  fi
}

alias new='Type::Construct'
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/command.sh 1`] = `
"# no dependencies

Command::GetType() {
  local name=\\"$1\\"
  local typeMatch=$(type -t \\"$name\\" 2> /dev/null || true)
  echo \\"$typeMatch\\"
}

Command::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" || \\"$typeMatch\\" == \\"function\\" || \\"$typeMatch\\" == \\"builtin\\" ]]
}

Alias::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" ]]
}

Function::Exists(){
  local name=\\"$1\\"
  declare -f \\"$name\\" &> /dev/null
}

Function::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'function' \\"$startsWith\\" || true
}

Function::InjectCode() {
  local functionName=\\"$1\\"
  local injectBefore=\\"$2\\"
  local injectAfter=\\"$3\\"
  local body=$(declare -f \\"$functionName\\")
  body=\\"\${body#*{}\\" # trim start
  body=\\"\${body%\\\\}}\\" # trim end
  local enter=$'\\\\n'
  eval \\"\${functionName}() { \${enter}\${injectBefore}\${body}\${injectAfter}\${enter} }\\"
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/exception.sh 1`] = `
"namespace util/exception
import String/GetSpaces String/SlashReplacement UI/Color UI/Console

#########################
### HANDLE EXCEPTIONS ###
#########################

trap \\"__EXCEPTION_TYPE__=\\\\\\"\\\\$_\\\\\\" command_not_found_handle \\\\$? \\\\$BASH_COMMAND\\" ERR
set -o errtrace  # trace ERR through 'time command' and other functions

# unalias throw 2> /dev/null || true
unset -f throw 2> /dev/null || true
alias throw=\\"__EXCEPTION_TYPE__=\\\\\${e:-Manually invoked} command_not_found_handle\\"

Exception::CustomCommandHandler() {
  ## this method can be overridden to create a custom, unknown command handler
  return 1
}

Exception::FillExceptionWithTraceElements() {
  local IFS=$'\\\\n'
  for traceElement in $(Exception::DumpBacktrace \${skipBacktraceCount:-3})
  do
    exception+=( \\"$traceElement\\" )
  done
}

command_not_found_handle() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  # ignore the error from the catch subshell itself
  if [[ \\"$*\\" = '( set -'*'; true'* ]] ## TODO: refine with a regex and test
  then
    return 0
  fi

  Exception::CustomCommandHandler \\"$@\\" && return 0 || true

  local exit_code=\\"\${1}\\"
  shift || true # there might have not been any parameter, in which case \\"shift\\" would fail
  local script=\\"\${BASH_SOURCE[1]#./}\\"
  local lineNo=\\"\${BASH_LINENO[0]}\\"
  local undefinedObject=\\"$*\\"
  local type=\\"\${__EXCEPTION_TYPE__:-\\"Undefined command\\"}\\"

  if [[ \\"$undefinedObject\\" == \\"(\\"*\\")\\" ]]
  then
    type=\\"Subshell returned a non-zero value\\"
  fi

  if [[ -z \\"$undefinedObject\\" ]]
  then
    undefinedObject=\\"$type\\"
  fi

  if [[ $__oo__insideTryCatch -gt 0 ]]
  then
    subject=level3 Log \\"inside Try No.: $__oo__insideTryCatch\\"

    if [[ ! -s $__oo__storedExceptionLineFile ]]; then
      echo \\"$lineNo\\" > $__oo__storedExceptionLineFile
    fi
    if [[ ! -s $__oo__storedExceptionFile ]]; then
      echo \\"$undefinedObject\\" > $__oo__storedExceptionFile
    fi
    if [[ ! -s $__oo__storedExceptionSourceFile ]]; then
      echo \\"$script\\" > $__oo__storedExceptionSourceFile
    fi
    if [[ ! -s $__oo__storedExceptionBacktraceFile ]]; then
      Exception::DumpBacktrace 2 > $__oo__storedExceptionBacktraceFile
    fi

    return 1 # needs to be return 1
  fi

  if [[ $BASH_SUBSHELL -ge 25 ]] ## TODO: configurable
  then
    echo \\"ERROR: Call stack exceeded (25).\\"
    Exception::ContinueOrBreak || exit 1
  fi

  local -a exception=( \\"$lineNo\\" \\"$undefinedObject\\" \\"$script\\" )

  Exception::FillExceptionWithTraceElements

  Console::WriteStdErr
  Console::WriteStdErr \\" $(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Bold)UNCAUGHT EXCEPTION: $(UI.Color.LightRed)\${type} $(UI.Color.Yellow)$(UI.Color.Italics)(\${exit_code})$(UI.Color.Default)\\"
  Exception::PrintException \\"\${exception[@]}\\"

  Exception::ContinueOrBreak
}

Exception::PrintException() {
  #    [...rest] exception
  local -a exception=(\\"$@\\")

  local -i backtraceIndentationLevel=\${backtraceIndentationLevel:-0}

  local -i counter=0
  local -i backtraceNo=0

  local -a backtraceLine
  local -a backtraceCommand
  local -a backtraceFile

  #for traceElement in Exception::GetLastException
  while [[ $counter -lt \${#exception[@]} ]]
  do
    backtraceLine[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceCommand[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceFile[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1

    backtraceNo+=1
  done

  local -i index=1

  while [[ $index -lt $backtraceNo ]]
  do
    Console::WriteStdErr \\"$(Exception::FormatExceptionSegment \\"\${backtraceFile[$index]}\\" \\"\${backtraceLine[$index]}\\" \\"\${backtraceCommand[($index - 1)]}\\" $(( $index + $backtraceIndentationLevel )) )\\"
    index+=1
  done
}

Exception::CanHighlight() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  if [[ \\"$errLine\\" == *\\"$stringToMarkWithoutSlash\\"* ]]
  then
    return 0
  else
    return 1
  fi
}

Exception::HighlightPart() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
  local underlinedObjectInLine=\\"\${errLine/$stringToMarkWithoutSlash/$underlinedObject}\\"

  # Bring back the slash:
  underlinedObjectInLine=\\"$(String::RestoreSlashes \\"$underlinedObjectInLine\\")\\"

  # Trimming:
  underlinedObjectInLine=\\"\${underlinedObjectInLine#\\"\${underlinedObjectInLine%%[![:space:]]*}\\"}\\" # \\"

  echo \\"$underlinedObjectInLine\\"
}

Exception::GetUnderlinedPart() {
  #    [string] stringToMark
  local stringToMark=\\"$1\\"

  echo \\"$(UI.Color.LightGreen)$(UI.Powerline.RefersTo) $(UI.Color.Magenta)$(UI.Color.Underline)$stringToMark$(UI.Color.White)$(UI.Color.NoUnderline)\\"
}

Exception::FormatExceptionSegment() {
  local script=\\"$1\\"
  local -i lineNo=\\"$2\\"
  local stringToMark=\\"$3\\"
  local -i callPosition=\\"\${4:-1}\\"
  #    [string] script
  #    [integer] lineNo
  #    [string] stringToMark
  #    [integer] callPosition=1

  local errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  local originalErrLine=\\"$errLine\\"

  local -i linesTried=0

  ## TODO: when line ends with slash \\\\ it is a multiline statement
  ## TODO: when eval or alias
  # In case it's a multiline eval, sometimes bash gives a line that's offset by a few
  while [[ $linesTried -lt 5 && $lineNo -gt 0 ]] && ! Exception::CanHighlight \\"$errLine\\" \\"$stringToMark\\"
  do
    linesTried+=1
    lineNo+=-1
    errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  done

  # Cut out the path, leave the script name
  script=\\"\${script##*/}\\"

  local prefix=\\"   $(UI.Powerline.Branch)$(String::GetSpaces $(($callPosition * 3 - 3)) || true) \\"

  if [[ $linesTried -ge 5 ]]
  then
    # PRINT THE ORGINAL OBJECT AND ORIGINAL LINE #
    #local underlinedObject=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"
    local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
    echo \\"\${prefix}$(UI.Color.White)\${underlinedObject}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
    prefix=\\"$prefix$(UI.Powerline.Fail) \\"
    errLine=\\"$originalErrLine\\"
  fi

  local underlinedObjectInLine=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"

  echo \\"\${prefix}$(UI.Color.White)\${underlinedObjectInLine}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
}

Exception::ContinueOrBreak() (
  ## TODO: Exceptions that happen in commands that are piped to others do not HALT the execution
  ## TODO: Add a workaround for this ^
  ## probably it's enough to -pipefail, check for a pipe in command_not_found - and if yes - return 1

  # if in a terminal
  if [ -t 0 ]
  then
    trap \\"stty sane; exit 1\\" INT
    Console::WriteStdErr
    Console::WriteStdErr \\" $(UI.Color.Yellow)$(UI.Powerline.Lightning)$(UI.Color.White) Press $(UI.Color.Bold)[CTRL+C]$(UI.Color.White) to exit or $(UI.Color.Bold)[Return]$(UI.Color.White) to continue execution.\\"
    read -s
    Console::WriteStdErr \\"$(UI.Color.Blue)$(UI.Powerline.Cog)$(UI.Color.White)  Continuing...$(UI.Color.Default)\\"
    return 0
  else
    Console::WriteStdErr
    exit 1
  fi
)

Exception::DumpBacktrace() {
  local -i startFrom=\\"\${1:-1}\\"
  #    [integer] startFrom=1
  # inspired by: http://stackoverflow.com/questions/64786/error-handling-in-bash

  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local -i i=0

  while caller $i > /dev/null
  do
    if (( $i + 1 >= $startFrom ))
    then
      local -a trace=( $(caller $i) )

      echo \\"\${trace[0]}\\"
      echo \\"\${trace[1]}\\"
      echo \\"\${trace[@]:2}\\"
    fi
    i+=1
  done
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/exits.sh 1`] = `
"#!/usr/bin/env bash
#
# exits
#
# Those values are come from /usr/include/sysexits.h
#

# successful termination
Util_ExitCode_OK=0
Util_ExitCode_USAGE=64  # command line usage error
Util_ExitCode_DATAERR=65  # data format error
Util_ExitCode_NOINPUT=66  # cannot open input
Util_ExitCode_NOUSER=67  # addressee unknown
Util_ExitCode_NOHOST=68  # host name unknown
Util_ExitCode_UNAVAILABLE=69  # service unavailable
Util_ExitCode_SOFTWARE=70  # internal software error
Util_ExitCode_OSERR=71  # system error (e.g., can't fork)
Util_ExitCode_OSFILE=72  # critical OS file missing
Util_ExitCode_CANTCREAT=73  # can't create (user) output file
Util_ExitCode_IOERR=74  # input/output error
Util_ExitCode_TEMPFAIL=75  # temp failure; user is invited to retry
Util_ExitCode_PROTOCOL=76  # remote error in protocol
Util_ExitCode_NOPERM=77  # permission denied
Util_ExitCode_CONFIG=78  # configuration error
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/log.sh 1`] = `
"import util/bash4
import UI/Color UI/Console

declare -Ag __oo__logScopes
declare -Ag __oo__logScopeOutputs
declare -Ag __oo__logDisabledFilter
declare -Ag __oo__loggers

Log::NameScope() {
  local scopeName=\\"$1\\"
  local script=\\"\${BASH_SOURCE[1]}\\"
  __oo__logScopes[\\"$script\\"]=\\"$scopeName\\"
}

Log::AddOutput() {
  local scopeName=\\"$1\\"
  local outputType=\\"\${2:-STDERR}\\"
  __oo__logScopeOutputs[\\"$scopeName\\"]+=\\"$outputType;\\"
}

Log::ResetOutputsAndFilters() {
  local scopeName=\\"$1\\"
  unset __oo__logScopeOutputs[\\"$scopeName\\"]
  unset __oo__logDisabledFilter[\\"$scopeName\\"]
}

Log::ResetAllOutputsAndFilters() {
  unset __oo__logScopeOutputs
  unset __oo__logDisabledFilter
  declare -Ag __oo__logScopeOutputs
  declare -Ag __oo__logDisabledFilter
}

Log::DisableFilter() {
  __oo__logDisabledFilter[\\"$1\\"]=true
}

Log() {
  local callingFunction=\\"\${FUNCNAME[1]}\\"
  local callingScript=\\"\${BASH_SOURCE[1]}\\"
  local scope
  if [[ ! -z \\"\${__oo__logScopes[\\"$callingScript\\"]}\\" ]]
  then
    scope=\\"\${__oo__logScopes[\\"$callingScript\\"]}\\"
  else # just the filename without extension
    scope=\\"\${callingScript##*/}\\"
    scope=\\"\${scope%.*}\\"
  fi
  local loggerList
  local loggers
  local logger
  local logged

  if [[ ! -z \\"$subject\\" ]]
  then
    if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\"
    fi

    loggers=( \${loggerList//;/ } )
    for logger in \\"\${loggers[@]}\\"
    do
      subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      logged=true
    done
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope/$callingFunction\\"]} == true || \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
          subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
          logged=true
      done
    fi
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
        subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      done
    fi
  fi
}

Log::RegisterLogger() {
  local logger=\\"$1\\"
  local method=\\"$2\\"
  __oo__loggers[\\"$logger\\"]=\\"$method\\"
}

Log::Using() {
  local logger=\\"$1\\"
  shift
  if [[ ! -z \${__oo__loggers[\\"$logger\\"]} ]]
  then
      \${__oo__loggers[\\"$logger\\"]} \\"$@\\"
  fi
}

Logger::DEBUG() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) DEBUG \\"$@\\"
}
Logger::ERROR() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Red) ERROR \\"$@\\"
}
Logger::INFO() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Blue) INFO \\"$@\\"
}
Logger::WARN() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) WARN \\"$@\\"
}
Logger::CUSTOM() {
    Console::WriteStdErr \\"$(UI.Color.Yellow)[\${subject^^}] $(UI.Color.Default)$* \\"
}
Logger::DETAILED() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) \\"\${subject^^}\\" \\"$@\\"
}

Log::RegisterLogger STDERR Console::WriteStdErr
Log::RegisterLogger DEBUG Logger::DEBUG
Log::RegisterLogger ERROR Logger::ERROR
Log::RegisterLogger INFO Logger::INFO
Log::RegisterLogger WARN Logger::WARN
Log::RegisterLogger CUSTOM Logger::CUSTOM
Log::RegisterLogger DETAILED Logger::DETAILED

alias namespace=\\"Log::NameScope\\"
namespace oo/log
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/namedParameters.sh 1`] = `
"namespace oo/type
import util/variable

# depends on modules: variable, exception

declare -g ref=D10F7FB728364261BB50A7E818D537C4
declare -g var=A04FB7D7594E479B8CD8D90C5014E37A

# TODO: required parameters
Variable::TrapAssignNumberedParameter() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift
  #  Log \\"TRAP: \${commandWithArgs[@]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* || \\"$command\\" == \\"_isRequired=\\"* || \\"$command\\" == \\"_isReadOnly=\\"*  || \\"$command\\" == \\"_noHandle=\\"* || \\"$command\\" == \\"_isGlobal=\\"* ]]
  then
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __assign_next=true
    DEBUG subject=\\"parameters-assign\\" Log \\"Will assign next one\\"

    local nextAssignment=$(( \${__assign_paramNo:-0} + 1 ))
    if [[ \\"\${!nextAssignment-}\\" == \\"$ref:\\"* ]]
    then
      DEBUG subject=\\"parameters-reference\\" Log \\"next param ($nextAssignment) is an object reference\\"
      __assign_parameters=\\"-n\\"
    ## TODO: type checking
    else
      __assign_parameters=\\"\\"
    fi
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* || $varDeclaration == '\${__assign'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"
  # TODO: checking for parameter existence or default value

  if [[ \\"\${__assign_varType:-null}\\" != \\"null\\" ]]
  then
    local requiredType=\\"$__assign_varType\\" ## TODO: use this information
    [[ $__assign_parameters == '-n' ]] && __assign_varType=\\"reference\\"

    DEBUG subject=\\"parameters-setting\\" Log \\"SETTING: [$__assign_varType] $__assign_varName = \\\\$$__assign_paramNo [rq:$__assign_valueRequired]\\" # [val:\${!__assign_paramNo}]
    # subject=\\"parameters-setting\\" Log --

    if [[ \\"$__assign_valueRequired\\" == 'true' && -z \\"\${!__assign_paramNo+x}\\" ]]
    then
      e=\\"Value is required for the parameter $__assign_varName ($__assign_paramNo) of type [$__assign_varType]\\" throw
    fi

    unset __assign_valueRequired __assign_valueReadOnly

    local indirectAccess=\\"$__assign_paramNo\\"

    if [[ \\"\${!indirectAccess-}\\" == \\"$var:\\"* ]]
    then
      local realVarName=\\"\${!indirectAccess#*$var:}\\"
      if Variable::Exists \\"$realVarName\\"
      then
        local __declaration
        local __declaration_type
        Variable::ExportDeclarationAndTypeToVariables \\"$realVarName\\" __declaration
        # Log realVarName \\"\${!indirectAccess#*$var:}\\" type \\"$declaration_type vs $__assign_varType\\" declaration: \\"$__declaration\\" vs \\"$(Variable::PrintDeclaration \\"$realVarName\\")\\"
        indirectAccess=__declaration

        if [[ \\"$__declaration_type\\" != \\"$__assign_varType\\" && \\"$__assign_varType\\" != 'params' && \\"$__assign_varType\\" != 'rest' ]]
        then
          e=\\"Passed in variable: ($__assign_paramNo) $__assign_varName is of different than its required type [required: $__assign_varType] [actual: $__declaration_type]\\" throw
        fi
      fi
    fi

    case \\"$__assign_varType\\" in
      'params')
      # passing array:
        eval \\"__assign_arrLength=$__assign_arrLength\\"
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo:$__assign_arrLength}\\\\\\" )\\"

        ## TODO: foreach param expand $var: indirectAccess
        __assign_paramNo+=$(($__assign_arrLength - 1))
        unset __assign_arrLength
      ;;
      'rest')
      ## TODO: foreach param expand $var: indirectAccess
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo}\\\\\\" )\\"
      ;;
      'boolean')
        DEBUG Log passed \\"\${!indirectAccess}\\", default \\"\${__assign_varValue}\\"
        local boolean_fingerprint=\\"\${__primitive_extension_fingerprint__boolean:+__primitive_extension_fingerprint__boolean:}\\"

        if [[ ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"\${boolean_fingerprint}\\"* ]]
          then
            __assign_varValue=\\"\${!indirectAccess}\\"
          elif [[ \\"\${!indirectAccess}\\" == 'true' || \\"\${!indirectAccess}\\" == 'false' ]]
          then
            __assign_varValue=\\"\${boolean_fingerprint}\${!indirectAccess}\\"
          else
            __assign_varValue=\\"\${boolean_fingerprint}false\\"
          fi
        elif [[ \\"\${__assign_varValue}\\" == 'true' || \\"\${__assign_varValue}\\" == 'false' ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}\${__assign_varValue}\\"
        elif [[ \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}true\\" && \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}false\\" ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}false\\"
        fi
        eval \\"$__assign_varName=\\\\\\"\${__assign_varValue}\\\\\\"\\"
      ;;
      'string'|'integer'|'reference')
        if [[ \\"$__assign_varType\\" == \\"reference\\" || ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"$ref:\\"* ]]
          then
            local refVarName=\\"\${!indirectAccess#*$ref:}\\"
            eval \\"$__assign_varName=$refVarName\\"
          else
            DEBUG Log \\"Will eval $__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
            # escape $indirectAccess with \\\\\\"
            # local escapedAssignment=\\"\${!indirectAccess}\\"
            # escapedAssignment=\\"\${escapedAssignment//\\\\\\"/\\\\\\\\\\\\\\"}\\"
            # execute=\\"$__assign_varName=\\\\\\"$escapedAssignment\\\\\\"\\"
            eval \\"$__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          fi

        # DEBUG subject=\\"parameters-executing\\" Log \\"EXECUTING: $execute\\"
        fi
      ;;
      *) # 'array'|'map'|objects
        if [[ ! -z \\"\${!indirectAccess}\\" ]]
        then
          eval \\"local -$(Variable::GetDeclarationFlagFromType '$__assign_varType') tempMap=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          local index
          local value

          ## copy the array / map item by item
          for index in \\"\${!tempMap[@]}\\"
          do
            eval \\"$__assign_varName[\\\\$index]=\\\\\\"\\\\\${tempMap[\\\\$index]}\\\\\\"\\"
          done

          unset index value tempMap
        fi
      ;;
    esac

    unset __assign_varType
    unset __assign_parameters

    if [[ \\"$__assign_valueGlobal\\" == \\"true\\" ]]; then
      local declaration=\\"$(declare -p $__assign_varName)\\"
      declaration=\\"\${declaration/declare/declare -g}\\"
      eval \\"$declaration\\"
    fi
    unset __assign_valueGlobal

    if [[ \\"$__assign_noHandle\\" != 'true' && ! -z \${__oo__bootstrapped+x} ]] && declare -f 'Type::CreateHandlerFunction' &> /dev/null
    then
      DEBUG Log \\"Will create handle for $__assign_varName\\"
      Type::CreateHandlerFunction \\"$__assign_varName\\" # 2> /dev/null || true
    fi
  fi

  if [[ \\"$command\\" != \\"local\\" || \\"\${__assign_next-}\\" != \\"true\\" ]]
  then
    __assign_normalCodeStarted+=1

    DEBUG subject=\\"parameters-nopass\\" Log \\"NOPASS \${commandWithArgs[*]}\\"
    DEBUG subject=\\"parameters-nopass\\" Log \\"normal code count ($__assign_normalCodeStarted)\\"
  # subject=\\"parameters-nopass\\" Log --
  else
    unset __assign_next

    __assign_normalCodeStarted=0
    __assign_varName=\\"$varName\\"
    __assign_varValue=\\"$varValue\\"
    __assign_varType=\\"$__capture_type\\"
    __assign_arrLength=\\"$__capture_arrLength\\"
    __assign_valueRequired=\\"$__capture_valueRequired\\"
    __assign_valueReadOnly=\\"$__capture_valueReadOnly\\"
    __assign_valueGlobal=\\"$__capture_valueGlobal\\"
    __assign_noHandle=\\"$__capture_noHandle\\"

    DEBUG subject=\\"parameters-pass\\" Log \\"PASS \${commandWithArgs[*]}\\"
    # subject=\\"parameters-pass\\" Log --

    __assign_paramNo+=1
  fi
}

Variable::InTrapCaptureParameters() {
  DEBUG subject=\\"parameters\\" Log \\"Capturing Type $_type\\"
  # subject=\\"parameters\\" Log --

  __capture_type=\\"$_type\\"
  __capture_arrLength=\\"\${l-'\${#@}'}\\"
  __capture_valueRequired=\\"\${_isRequired-false}\\"
  __capture_valueReadOnly=\\"\${_isReadOnly-false}\\"
  __capture_valueGlobal=\\"\${_isGlobal-false}\\"
  __capture_noHandle=\\"\${_noHandle-false}\\"
}

## ARGUMENT RESOLVERS ##

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Variable::TrapAssign='Variable::InTrapCaptureParameters; local -i __assign_normalCodeStarted=0; trap \\"declare -i __assign_paramNo; Variable::TrapAssignNumberedParameter \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__assign_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __assign_varType __assign_varName __assign_varValue __assign_paramNo __assign_valueRequired __assign_valueReadOnly __assign_valueGlobal __assign_noHandle\\" DEBUG; true; true; '
alias [reference]='_type=reference Variable::TrapAssign local -n'
alias Variable::TrapAssignLocal='Variable::TrapAssign local \${__assign_parameters}'
alias [string]=\\"_type=string Variable::TrapAssignLocal\\"
# alias [string]=\\"_type=string Variable::TrapAssign local \\\\\${__assign_parameters}\\"
alias [integer]='_type=integer Variable::TrapAssign local \${__assign_parameters:--i}'
alias [array]='_type=array Variable::TrapAssign local \${__assign_parameters:--a}'
alias [map]='_type=map Variable::TrapAssign local \${__assign_parameters:--A}'
# TODO: alias [integerArray]='_type=array Variable::TrapAssign local \${__assign_parameters:--ai}'
alias [boolean]='_type=boolean Variable::TrapAssignLocal'
alias [string[]]='_type=params Variable::TrapAssignLocal'
alias [string[1]]='l=1 _type=params Variable::TrapAssignLocal'
alias [string[2]]='l=2 _type=params Variable::TrapAssignLocal'
alias [string[3]]='l=3 _type=params Variable::TrapAssignLocal'
alias [string[4]]='l=4 _type=params Variable::TrapAssignLocal'
alias [string[5]]='l=5 _type=params Variable::TrapAssignLocal'
alias [string[6]]='l=6 _type=params Variable::TrapAssignLocal'
alias [string[7]]='l=7 _type=params Variable::TrapAssignLocal'
alias [string[8]]='l=8 _type=params Variable::TrapAssignLocal'
alias [string[9]]='l=9 _type=params Variable::TrapAssignLocal'
alias [string[10]]='l=10 _type=params Variable::TrapAssignLocal'
alias [...rest]='_type=rest Variable::TrapAssignLocal'
alias @required='_isRequired=true'
alias @handleless='_noHandle=true'
alias @global='_isGlobal=true'
# TODO: alias @readonly='_isReadOnly=true '
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/pipe.sh 1`] = `
"# no dependencies

Pipe::Capture() {
  read -r -d '' $1 || true
}

Pipe::CaptureFaithful() {
  IFS= read -r -d '' $1 || true
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/test.sh 1`] = `
"import util/class util/tryCatch UI/Cursor

class:Test() {
  private UI.Cursor onStartCursor
  private string groupName
  public string errors
  # public boolean errors = false

  Test.Start() {
    [string] verb
    [string] description

    this onStartCursor capture
    echo \\"$(UI.Color.Yellow)$(UI.Powerline.PointingArrow) $(UI.Color.Yellow)[$(UI.Color.LightGray)$(UI.Color.Bold)TEST$(UI.Color.NoBold)$(UI.Color.Yellow)] $(UI.Color.White)\${verb} \${description}$(UI.Color.Default)\\"
    @return
  }

  Test.OK() {
    [string] printInPlace=true

    [[ $printInPlace == true ]] && this onStartCursor restore

    echo \\"$(UI.Color.Green)$(UI.Powerline.OK) $(UI.Color.Yellow)[ $(UI.Color.Green)$(UI.Color.Bold)OK$(UI.Color.NoBold) $(UI.Color.Yellow)]$(UI.Color.Default)\\"
    @return
  }

  Test.EchoedOK() {
    this OK false
  }

  Test.Fail() {
    [string] line
    [string] error
    [string] source
    echo \\"$(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Yellow)[$(UI.Color.Red)$(UI.Color.Bold)FAIL$(UI.Color.NoBold)$(UI.Color.Yellow)]$(UI.Color.Default) in $(UI.Color.Yellow)\${source}$(UI.Color.Default):$(UI.Color.Blue)\${line}$(UI.Color.Default) $(UI.Powerline.RefersTo) $(UI.Color.Red)\${error}$(UI.Color.Default)\\"
    @return
  }

  Test.DisplaySummary() {
    if [[ $(this errors) == true ]]
    # if this errors
    then
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Red)There were errors $(UI.Color.Default)$(UI.Powerline.Lightning)\\"
      this errors = false
    else
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Yellow)Test group completed successfully $(UI.Color.Default)$(UI.Powerline.ThumbsUp)\\"
    fi
    @return
  }

  Test.NewGroup() {
    [string] groupName

    echo \\"$(UI.Powerline.ArrowRight)\\" $(UI.Color.Magenta)Testing [$(UI.Color.White)\${groupName}$(UI.Color.Magenta)]: $(UI.Color.Default)

    this groupName = \\"$groupName\\"

    @return
  }
}

Type::InitializeStatic Test

### TODO: special case for static classes
### for storage use a generated variable name (hash of class name?)
### for execution use class' name, e.g. Test Start

alias describe='Test NewGroup'
alias summary='Test DisplaySummary'
alias caught=\\"echo \\\\\\"CAUGHT: $(UI.Color.Red)\\\\$__BACKTRACE_COMMAND__$(UI.Color.Default) in \\\\$__BACKTRACE_SOURCE__:\\\\$__BACKTRACE_LINE__\\\\\\"\\"
alias it=\\"Test Start it\\"
alias expectPass=\\"Test OK; catch { Test errors = true; Test Fail \\\\\\"\\\\\${__EXCEPTION__[@]}\\\\\\"; }\\"
alias expectOutputPass=\\"Test EchoedOK; catch { Test errors = true; Test Fail; }\\"
alias expectFail='catch { caught; Test EchoedOK; }; test $? -eq 1 && Test errors = false; '
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/tryCatch.sh 1`] = `
"# no dependencies
declare -ig __oo__insideTryCatch=0
declare -g __oo__presetShellOpts=\\"$-\\"

# in case try-catch is nested, we set +e before so the parent handler doesn't catch us instead
alias try='[[ $__oo__insideTryCatch -eq 0 ]] || __oo__presetShellOpts=\\"$(echo $- | sed 's/[is]//g')\\"; __oo__insideTryCatch+=1; set +e; ( set -e; true; '
alias catch='); declare __oo__tryResult=$?; __oo__insideTryCatch+=-1; [[ $__oo__insideTryCatch -lt 1 ]] || set -\${__oo__presetShellOpts:-e} && Exception::Extract $__oo__tryResult || '

Exception::SetupTemp() {
  declare -g __oo__storedExceptionLineFile=\\"$(mktemp -t stored_exception_line.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionSourceFile=\\"$(mktemp -t stored_exception_source.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionBacktraceFile=\\"$(mktemp -t stored_exception_backtrace.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionFile=\\"$(mktemp -t stored_exception.$$.XXXXXXXXXX)\\"
}

Exception::CleanUp() {
  local exitVal=$?
  rm -f $__oo__storedExceptionLineFile $__oo__storedExceptionSourceFile $__oo__storedExceptionBacktraceFile $__oo__storedExceptionFile || exit 1
  exit $exitVal
}

Exception::ResetStore() {
  > $__oo__storedExceptionLineFile
  > $__oo__storedExceptionFile
  > $__oo__storedExceptionSourceFile
  > $__oo__storedExceptionBacktraceFile
}

Exception::GetLastException() {
  if [[ -s $__oo__storedExceptionFile ]]
  then
    cat $__oo__storedExceptionLineFile
    cat $__oo__storedExceptionFile
    cat $__oo__storedExceptionSourceFile
    cat $__oo__storedExceptionBacktraceFile

    Exception::ResetStore
  else
    echo -e \\"\${BASH_LINENO[1]}\\\\n \\\\n\${BASH_SOURCE[2]#./}\\"
  fi
}

Exception::Extract() {
  local retVal=$1
  unset __oo__tryResult

  if [[ $retVal -gt 0 ]]
  then
    local IFS=$'\\\\n'
    __EXCEPTION__=( $(Exception::GetLastException) )

    local -i counter=0
    local -i backtraceNo=0

    while [[ $counter -lt \${#__EXCEPTION__[@]} ]]
    do
      __BACKTRACE_LINE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_COMMAND__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_SOURCE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      backtraceNo+=1
    done

    return 1 # so that we may continue with a \\"catch\\"
  fi
  return 0
}

Exception::SetupTemp
trap Exception::CleanUp EXIT INT TERM
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/type.sh 1`] = `
"namespace util/type

import util/bash4
import Array/Contains String/SanitizeForVariable
import util/namedParameters util/pipe util/variable util/command

declare -g __primitive_extension_declaration=2D6A822E
declare -g __primitive_extension_fingerprint__boolean=\${__primitive_extension_declaration}36884C70843578D37E6773C4
declare -g __return_separator=52A586A48E074BB6812DCFDC790841F5
declare -g __oo__type_handler_functions=()
declare -g __oo__variableMethodPrefix=\\"$var:\\"

# /**
#   * Code like: Variable::ExportDeclarationAndTypeToVariables
#   * TODO: Merge parts
#   */
Type::GetTypeOfVariable() {
  local variableName=\\"$1\\"
  local dereferrence=\\"\${2:-true}\\"

  local regex=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p \\"\${variableName}\\" 2> /dev/null || true)

  [[ -z \\"$definition\\" ]] && e=\\"Variable not defined\\" throw
  if [[ \\"$definition\\" =~ $regex ]]
  then
    local variableType
    local primitiveType=\${BASH_REMATCH[1]}

    local objectTypeIndirect=\\"$variableName[__object_type]\\"
    if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
    then
      DEBUG Log \\"typeof $variableName: Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
      variableType=\\"\${!objectTypeIndirect}\\"
    else
      variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
      DEBUG Log \\"typeof $variableName: Primitive Type $primitiveType Resolved \${variableType}\\"
    fi

    if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
    then
      local dereferrencedVariableName=$(Variable::PrintDeclaration \\"$variableName\\" false)
      variableType=$(Type::GetTypeOfVariable \\"$dereferrencedVariableName\\")
    fi

    if [[ \\"$variableType\\" == 'string' ]]
    then
      local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
      if [[ ! -z \\"$extensionType\\" ]]
      then
        variableType=\\"$extensionType\\"
      fi
    fi

    DEBUG Log \\"Variable $variableName is typeof $variableType\\"

    echo \\"$variableType\\"
  fi
}

Type::IsPrimitive() {
  local type=\\"$1\\"

  case \\"$type\\" in
    'array'|'map'|'string'|'integer'|'boolean'|'integerArray'|'reference') ## TODO: reference should be resolved
      return 0 ;;
    * )
      return 1 ;;
  esac
}

## Returns a matching __primitive_extension_fingerprint__*
## Or nothing
Type::GetPrimitiveExtensionFromVariable() {
  local variableName=\\"$1\\"

  if [[ \\"\${!variableName}\\" != \\"$__primitive_extension_declaration\\"* ]]
  then
    return
  fi

  local prefix=__primitive_extension_fingerprint__
  local extensionType
  for extensionType in $(Variable::GetAllStartingWith $prefix)
  do
    local fingerprint=\${!extensionType}
    if [[ \\"\${!variableName}\\" == \\"$fingerprint\\"* ]]
    then
      extensionType=\${extensionType##$prefix}
      echo \\"$extensionType\\"
      return
    fi
  done
}

Type::GetPrimitiveExtensionFingerprint() {
  local type=\\"$1\\"

  local fingerprintVariable=\\"__primitive_extension_fingerprint__\${type}\\"
  printf \\"\${!fingerprintVariable}\\"
}

Type::CreateHandlerFunction() {
  local variableName=\\"$1\\"

  if [[ -z $variableName ]]
  then
    subject=WARN Log \\"No variable specified when trying to create a handle.\\"
    return
  fi

  ## don't allow creating a handler if a command/function/alias of such name already exists
  ## unless it is a handler already (keeps track)

  if ! Command::Exists \\"\${__oo__variableMethodPrefix}\${variableName}\\"
  then
    DEBUG Log \\"creating handler for $variableName\\"
    ## declare method with the name of the var ##
    eval \\"\${__oo__variableMethodPrefix}\${variableName}() { Type::Handle $variableName \\\\\\"\\\\$@\\\\\\"; }\\"
    __oo__type_handler_functions+=( \\"\${variableName}\\" )

  elif ! Array::Contains \\"\${variableName}\\" \\"\${__oo__type_handler_functions[@]}\\"
  then
    ## TODO: a way to solve this is to store the original functions
    ## and temporairly override it, returning back to the old formula in @return
    subject=WARN Log \\"Unable to create a handle for '$variableName'. A command of the same name already exists.\\"
  fi

  Type::RunFunctionGarbageCollector
}

Type::RunFunctionGarbageCollector() {
  local -a variables=( $(compgen -A 'variable' || true) )

  local index
  local handler
  for index in \\"\${!__oo__type_handler_functions[@]}\\"
  do
    handler=\\"\${__oo__type_handler_functions[$index]}\\"

    local exists=
    for variable in \\"\${variables[@]}\\"
    do
      # Log \\"comparing: \${variable} == $handler\\"
      [[ \\"$variable\\" == \\"$handler\\" ]] && { exists=1; break; }
    done
    ## unset all the functions that don't have corresponding variables
    if [[ ! -n $exists ]]
    then
      DEBUG Log \\"Unsetting handler for $handler\\"
      unset -f \\"\${__oo__variableMethodPrefix}\${handler}\\"
      unset __oo__type_handler_functions[$index]
    else
      DEBUG Log \\"not deleting: handler and variable exists: \${variable}\\"
    fi
  done
}

Type::InjectThisResolutionIfNeeded() {
  local methodName=\\"$1\\"

  local methodBody=$(declare -f \\"$methodName\\" || true)

  if [[ -z \\"$methodBody\\" ]]
  then
    e=\\"Method $methodName is not defined.\\" throw
    return
  fi

  if [[ \\"$methodBody\\" != *'@resolve:this'* && \\"$methodBody\\" != *'__local_return_self_and_result=false'* ]]
  then
    DEBUG Log \\"Injecting @this resolution to: $methodName\\"
    DEBUG [[ \\"$methodName\\" == \\"Human\\"* ]] && Log \\"$methodBody\\"

    if [[ \\"$methodBody\\" != *'@return'* ]]
    then
      Function::InjectCode \\"$methodName\\" '@resolve:this' '@return'
    else
      Function::InjectCode \\"$methodName\\" '@resolve:this'
    fi
  fi
}

Type::ConvertAllOfTypeToMethodsIfNeeded() {
  local type=\\"$1\\"

  local -a methods=( $(Function::GetAllStartingWith \\"\${type}.\\") )
  local method

  for method in \\"\${methods[@]}\\"
  do
    Type::InjectThisResolutionIfNeeded \\"$method\\"
  done
}

Type::InitializePrimitive() {
  local name=\\"$1\\"

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"
}

Type::TrapAndCreate() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift

  # Log \\"\${commandWithArgs[*]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* ]]
  then
    # set +x
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __typeCreate_next=true
    # Console::WriteStdErr \\"Will assign next one\\"
    # set +x
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"

  # TODO: make this better, otherwise edge case bug:
  if [[ \\"$varValue\\" == \\"$varName\\" ]]
  then
    # Log \\"equal $varName=$varValue\\"
    local varValue=\\"\\"
  fi

  if [[ ! -z $__typeCreate_varType ]]
  then

    local __primitive_extension_fingerprint__boolean=\${__primitive_extension_fingerprint__boolean:-2D6A822E36884C70843578D37E6773C4}
    # Console::WriteStdErr \\"SETTING $__typeCreate_varName = \\\\$$__typeCreate_paramNo\\"
    # Console::WriteStdErr --
    #Console::WriteStdErr $tempName

    DEBUG Log \\"creating: $__typeCreate_varName ($__typeCreate_varType) = $__typeCreate_varValue\\"

    if [[ -z \\"$__typeCreate_varValue\\" ]]
    then
      case \\"$__typeCreate_varType\\" in
        'array'|'map') eval \\"$__typeCreate_varName=()\\" ;;
        'string') eval \\"$__typeCreate_varName=''\\" ;;
        'integer') eval \\"$__typeCreate_varName=0\\" ;;
        'boolean') eval \\"$__typeCreate_varName=\${__primitive_extension_fingerprint__boolean}:false\\" ;;
        * )
        # Log \\"constructing: $__typeCreate_varName ($__typeCreate_varType) = $(__constructor_recursion=0 Type::Construct $__typeCreate_varType)\\"

          __constructor_recursion=0 Type::Construct \\"$__typeCreate_varType\\" \\"$__typeCreate_varName\\"

          DEBUG Log \\"constructed: $(@get $__typeCreate_varName)\\"
        ;;
      esac
    else
      case \\"$__typeCreate_varType\\" in
        'boolean')
          if [[ \\"\${__typeCreate_varValue}\\" != 'true' && \\"\${__typeCreate_varValue}\\" != 'false' ]]
          then
            __typeCreate_varValue='false'
          fi
          eval \\"$__typeCreate_varName=\\\\\\"\${__primitive_extension_fingerprint__boolean}:\${__typeCreate_varValue}\\\\\\"\\" ;;
      ## TODO: add case of setting value already with fingerprint
        *) ;;
      esac
    fi

    Type::CreateHandlerFunction \\"$__typeCreate_varName\\"

    ## IMPORTANT: TRAP won't work inside a TRAP, so such a constructor couldn't

    # case \\"$__typeCreate_varType\\" in
    #   'array'|'map'|'string'|'integer') ;;
    #   *)
    #     if Function::Exists \${__typeCreate_varType}.constructor
    #     then
    #       # __typeCreate_runConstructor=\${__typeCreate_varName}
    #       # Log __typeCreate_runConstructor $__typeCreate_runConstructor
    #       \${__typeCreate_varName} constructor
    #     fi
    #     # local return
    #     # Object.New $__typeCreate_varType $__typeCreate_varName
    #     # eval \\"$__typeCreate_varName=$return\\"
    #   ;;
    # esac

    # __oo__objects+=( $__typeCreate_varName )

    unset __typeCreate_varType
    unset __typeCreate_varValue
  fi

  if [[ \\"$command\\" != \\"declare\\" || \\"$__typeCreate_next\\" != \\"true\\" ]]
  then
    __typeCreate_normalCodeStarted+=1

  # Console::WriteStdErr \\"NOPASS \${commandWithArgs[*]}\\"
  # Console::WriteStdErr \\"normal code count ($__typeCreate_normalCodeStarted)\\"
  # Console::WriteStdErr --
  else
    unset __typeCreate_next

    __typeCreate_normalCodeStarted=0
    __typeCreate_varName=\\"$varName\\"
    __typeCreate_varValue=\\"$varValue\\"
    __typeCreate_varType=\\"$__capture_type\\"
    __typeCreate_arrLength=\\"$__capture_arrLength\\"

    # Console::WriteStdErr \\"PASS \${commandWithArgs[*]}\\"
    # Console::WriteStdErr --

    __typeCreate_paramNo+=1
  fi
  # set +x
}

Type::CaptureParams() {
    # Console::WriteStdErr \\"Capturing Type $_type\\"
    # Console::WriteStdErr --

    __capture_type=\\"$_type\\"
}

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Type::TrapAssign='Type::CaptureParams; declare -i __typeCreate_normalCodeStarted=0; trap \\"declare -i __typeCreate_paramNo; Type::TrapAndCreate \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__typeCreate_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __typeCreate_varType __typeCreate_varName __typeCreate_varValue __typeCreate_paramNo\\" DEBUG; true; true; '
alias reference='_type=reference Type::TrapAssign declare -n'
alias string='_type=string Type::TrapAssign declare'
alias boolean='_type=boolean Type::TrapAssign declare'
alias integer='_type=integer Type::TrapAssign declare -i'
alias array='_type=array Type::TrapAssign declare -a'
alias integerArray='_type=integerArray Type::TrapAssign declare -ai'
alias map='_type=map Type::TrapAssign declare -A'
#alias global:reference='_type=reference Type::TrapAssign declare -ng'
#alias global:string='_type=string Type::TrapAssign declare -g'
#alias global:integer='_type=integer Type::TrapAssign declare -ig'
#alias global:array='_type=array Type::TrapAssign declare -ag'
#alias global:map='_type=map Type::TrapAssign declare -Ag'

##############################

# for use in the object's methods
this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:() {
  Type::Handle \\"$@\\"
  # Type::Handle $1 \\"\${@:2}\\"
}

@return() {
  local variableName=\\"$1\\"
  local thisName=\\"\${2:-this}\\"

  local __return_declaration
  local __return_declaration_type

  ## if not returning anything, just update the self
  if [[ ! -z \\"$variableName\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $variableName __return_declaration
  elif [[ ! -z \\"\${monad+x}\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $thisName __return_declaration
  fi

  if [[ \\"\${__local_return_self_and_result}\\" == \\"true\\" || \\"\${__return_self_and_result}\\" == \\"true\\" ]]
  then
    # Log \\"returning heavy\\"
    local -a __return=(\\"$(Variable::PrintDeclaration $thisName)\\" \\"$__return_declaration\\" \\"$__return_declaration_type\\")

    printf \${__return_separator:-52A586A48E074BB6812DCFDC790841F5}
    Variable::PrintDeclaration __return
    # __modifiedThis=\\"$(Variable::PrintDeclaration this)\\"
  elif [[ \\"\${#__return_declaration}\\" -gt 0 ]]
  then
    echo \\"$__return_declaration\\"
  fi

  Type::RunFunctionGarbageCollector
}

@return:value() {
  local value=\\"$@\\"
  @return value
}

# ------------------------ #
# STACK HANDLING #
# ------------------------ #

Type::ExecuteMethod() {
  local type=\\"$1\\"
  local variableName=\\"$2\\"
  local method=\\"$3\\"

  shift; shift; shift;

  Type::InjectThisResolutionIfNeeded \\"$type.$method\\"

  thisReference=$variableName thisReferenceType=\\"$type\\" $type.$method \\"$@\\"
}

# /**
#  * used inside Type::Handle() for getting out the return value and updating this
#  */
Type::RunCurrentStack() {
  DEBUG Log \\"will execute: $method (\${params[@]})\\"

  if [[ ! -z \\"$returnValueDefinition\\" && \\"$affectTheInitialVariable\\" == 'false' ]]
  then
    local -$(Variable::GetDeclarationFlagFromType $returnValueType) \\"__self=$returnValueDefinition\\"
    variableName=__self
  fi

  # Log \\"Will assign: result=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\")\\"
  local resultString=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\" || { local falseBool=\\"\${__primitive_extension_fingerprint__boolean}:false\\"; __return_self_and_result=true @return falseBool $variableName; })
  # || echo \\"\${__return_separator}specialBool:\${__primitive_extension_fingerprint__boolean}:false\\"

  ## TODO: some problem here sometimes
  DEBUG Log \\"Result string: START | $resultString | END\\"

  local echoed=

  if [[ -z \\"$resultString\\" || \\"$resultString\\" != *\\"$__return_separator\\"* ]]
  then
    ## if resultString does not contain return_separator, use all as returnString and nothing as echo
    ## TODO: debug these situations if all ok.
    # theoretically, this is when no @return is present
    # or when no return separator provided - we use the echoed output as the result
    #
    ## implicit \\"string\\"
    local -a result=( \\"$(@get $variableName)\\" \\"$(@get resultString)\\" \\"string\\" )
  else
    # echo everything before the first occurrence of the separator
    echoed=\\"\${resultString%%$__return_separator*}\\"

    DEBUG [[ ! -z \\"$echoed\\" ]] && Log \\"Echoed: START | $(@get echoed) | END\\"

    # the result is everything after the first occurrence of the separator
    resultString=\\"\${resultString#*$__return_separator}\\"

    # Log \\"resultString: $resultString\\"
    local -a result=$resultString
    # eval \\"local -a result=$resultString\\"
  fi

  unset __self

  # declare -p result
  local assignResult=\\"\${result[0]}\\"

  DEBUG Log \\"Assign Result:\\"
  DEBUG Log \\"START $assignResult END\\"
  # declare -p assignResult

  local typeParam=$(Variable::GetDeclarationFlagFromType $type)

  DEBUG Log \\"Will eval: | $variableName=$assignResult |\\"
  # [[ \\"\${assignResult}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1

  if [[ \\"$typeParam\\" =~ [aA] ]]
  then
    # update the object
    eval \\"$variableName=$assignResult\\"
  else
    ## TODO: use the primitive extension fingerprint here, not in the methods themselves
    # assignResult=\\"$(Type::GetPrimitiveExtensionFingerprint $type):$assignResult\\"
    eval \\"$variableName=\\\\\\"\\\\$assignResult\\\\\\"\\"
  fi

  # update the result
  returnValueDefinition=\\"\${result[1]}\\"
  returnValueType=\\"\${result[2]}\\"

  # Log \\"returned: $returnValueType: $returnValueDefinition\\"

  # switch context for the next command
  if [[ \\"$assignResult\\" != \\"\${returnValueDefinition}\\" ]]
  then
    affectTheInitialVariable=false
    type=\\"$returnValueType\\" # $(Variable::GetPrimitiveTypeFromDeclarationFlag $returnValueType)
  fi

  printf %s \\"$echoed\\"

  ## cleanup vars:
  method=''
  params=()

  # TODO: this should work directly but doesn't
  # eval $variableName=\\\\$assignResult
}

Type::RunGetter() {
  local variableName=\\"$1\\"
  local type=\\"$2\\"

  if Function::Exists \\"$type.__getter__\\"
  then
    __return_self_and_result=false Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"__getter__\\"
  else
    @get \\"$variableName\\"
  fi
}

## TODO: private handling should be reimplemented - only this() should be able to access private entries
Type::Handle() {
  local variableName=\\"$1\\"
  local type=$(Type::GetTypeOfVariable \\"\${variableName}\\")
  local affectTheInitialVariable=true
  local -a propertyTree=(\\"$1\\")

  if [[ \\"$type\\" == \\"undefined\\" ]]
  then
    e=\\"No variable named: $variableName\\" throw
    return
  fi

  shift

  local returnValueDefinition
  local returnValueType

  local currentPropertyVisibility=public

  local multiExpression=false

  if [[ \\"$1\\" == ':' ]]
  then
    multiExpression=true
    shift
  fi

  DEBUG subject=\\"type handling\\" Log \\"START ANALYZING: type: $type | variable: $variableName $@\\"
  DEBUG subject=\\"type handling\\" Log \\"WHAT: $(declare -p $variableName)\\"

  # Log multiExpression $multiExpression

  if [[ $# -gt 0 ]]
  then
    local method
    local -a params
    local mode=method
    local prevMode
    local prevModeNext
    local bracketsStarted=false
    local -i closingBracketCount=0

    while [[ $# -gt 0 ]]
    do
      if [[ \\"$__access_private\\" != \\"true\\" && \\"$currentPropertyVisibility\\" == \\"private\\" ]]
      then
        e=\\"Trying to access a private property: $method\\" throw
        return
      fi

      prevModeNext=$mode

      if [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '{' ]]
      then
        if [[ $bracketsStarted == 'true' ]]
        then
          ## handle edge case of '}' as actual parameter
          while (( closingBracketCount+=-1 ))
          do
            params+=( '}' )
          done

          Type::RunCurrentStack
        fi
        bracketsStarted=true
        # mode=params
      elif [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '}' ]]
      then
        closingBracketCount+=1
        mode=method
        prevModeNext=params
      elif [[ \\"$mode\\" == 'params' ]]
      then
        params+=(\\"$1\\")
      elif [[ \\"$mode\\" == 'method' ]]
      then
        # Log $(@get __\${type}_property_names | array.indexOf $1) $1 idx
        # Log $(@get __\${type}_property_names | array.contains $1 && echo t)

        # Log index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${1})

        local typeSanitized=$(String::SanitizeForVariableName \${type})
        # local typeSanitized=\\"\${type//[^a-zA-Z0-9]/_}\\"

        if Variable::Exists __\${typeSanitized}_property_names &&
            @get __\${typeSanitized}_property_names | __return_self_and_result=false array.contains $1
        then
          # stack now belongs to selected property:
          local property=\\"$1\\"

          DEBUG Log found index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${property})
          # Log prop: $property of [$(@get __\${type}_property_names)]

          ## TODO: theoretically, we could get rid of: __return_self_and_result=false
          local -i index=$(@get __\${typeSanitized}_property_names | __return_self_and_result=false array.indexOf \${property})

          if [[ $index -ge 0 ]]
          then
            DEBUG Log \\"traversing to a child property $property of type $type\\"

            local newType=__\${typeSanitized}_property_types[$index]
            type=\${!newType}
            local typeParam=$(Variable::GetDeclarationFlagFromType $type)

            local currentPropertyVisibilityIndirect=__\${typeSanitized}_property_visibilities[$index]
            currentPropertyVisibility=\${!currentPropertyVisibilityIndirect}

            local propertyValueIndirect=$variableName[$property]

            if [[ -z \\"\${!propertyValueIndirect}\\" && \\"$typeParam\\" =~ [aA] ]]
            then
              local -$typeParam \\"__$property=()\\"
            else
              ## TODO: check if this preserves spaces correctly
              local -$typeParam \\"__$property=\${!propertyValueIndirect}\\"

              if ! Type::IsPrimitive \\"$type\\"
              then
                eval \\"__$property[__object_type]=\\\\\\"\\\\$type\\\\\\"\\"
              fi
            fi

            DEBUG Log \\".$property new $type value is: \\" # \${propertyValueIndirect} vs '\${!propertyValueIndirect}'
            DEBUG Log \\"$(declare -p __$property)\\"
            # affectTheInitialVariable=false

            ## TODO: variableName needs to be unique (add count at the end)
            ## in case the same property is nested
            variableName=__$property

            propertyTree+=(\\"$property\\")

            prevModeNext=property
          fi
          ### /selectProperty
        else
          mode=params
          method=\\"$1\\"
        fi
      fi
      prevMode=$prevModeNext

      DEBUG subject=\\"type handling\\" Log \\"iter: $1 | prevMode: $prevMode | mode: $mode | type: $type | variable: $variableName | method: $method | #params: \${#params[@]}\\"

      shift
    done

    if [[ \\"\${#method}\\" -gt 0 ]]
    then
      # Log 'running stack for:' $variableName
      Type::RunCurrentStack
      # Log 'output was:' \\"\${!variableName}\\"
      ## TODO: this does not work: (false boolean should return fail)
      [[ \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1 # && Log \\"LALALALA\\"
    elif [[ \\"$prevMode\\" == 'property' ]]
    then
      if [[ \\"$currentPropertyVisibility\\" == 'public' || \\"$__access_private\\" == \\"true\\" ]]
      then
        DEBUG subject='property' Log 'print out the property' $variableName
        ## print out the property or run the getter
        Type::RunGetter $variableName $type
      else
        e=\\"Property is private\\" throw
      fi
    fi

    ## TODO: shouldn't this be an elif ?
    # finally echo the latest return value if not empty
    if [[ ! -z \\"$returnValueDefinition\\" ]]
    then
      echo \\"$returnValueDefinition\\"
    fi

    ## UPDATE THE OBJECT RECURSIVELY:
    local -i propertyTreeLength=\${#propertyTree[@]}
    if [[ \${#propertyTree[@]} -gt 1 ]]
    then
      # Log PropertyTree: $(@get propertyTree)
      local -a reversedPropertyTree=$(@get propertyTree | __return_self_and_result=false array.reverse)

      local -i i=$propertyTreeLength
      local property
      local parent
      for parent in \\"\${reversedPropertyTree[@]}\\"
      do
        ## recursively insert the children into parents

        i+=-1
        (( $i == $propertyTreeLength - 1 )) && property=$parent && continue

        local parentVarName=__$parent

        (( $i == 0 )) && parentVarName=$parent

        local propertyDefinition=\\"$(@get __$property)\\"
        # Log \\"Will eval: $parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"
        eval \\"$parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"

        DEBUG Log \\"SETTING: ($i) $parentVarName.$property = \\\\\\"$propertyDefinition\\\\\\"\\"

        property=$parent
      done
    fi
  else
    #@get $variableName
    Type::RunGetter $variableName $type
  fi
}

## TODO: take note of what variables have handler functions in a global variable
## in @resolve:this save the list and then compare it in a @return
## -- or better yet -- to it in the parent that executes the method
## before and after execution

## question - how to add @resolve:this to all methods without explicitly stating it?

## \\"garbage collect\\", i.e. remove all the new references so they don't pollute the global scope

## note: declaration needs to be trimmed,
## since bash adds an enter at the end, hence %?
alias @resolve:this=\\"
  local __local_return_self_and_result=false
  [[ \\\\$__return_self_and_result == 'true' ]] && local __local_return_self_and_result=true && local __return_self_and_result=false
  # TODO: local __access_private_members_of=
  if [[ -z \\\\\${__use_this_transparently+x} ]];
  then
    local __declaration;
    local __declaration_type;

    if [[ ! -z \\\\\\"\\\\\${useReturnValueDefinition}\\\\\\" ]];
    then
      # subject='@resolve:this' Log 'using: ReturnValueDefinition'
      __declaration=\\\\\\"\\\\$returnValueDefinition\\\\\\"
      __declaration_type=\\\\$returnValueType
    elif [[ -z \\\\\${thisReference+x} && ! -t 0 ]];
    then
      # subject='@resolve:this' Log 'using: pipe'
      Pipe::Capture __declaration;
      __declaration_type=\\\\\${FUNCNAME[0]%.*}
      DEBUG Log capturing via pipe \\\\\${__declaration_type}
    else
      # subject='@resolve:this' Log 'using: thisReference:' $ \\\\$thisReference type: \\\\$thisReferenceType
      Variable::ExportDeclarationAndTypeToVariables \\\\$thisReference __declaration;
      __declaration_type=\\\\\\"\\\\$thisReferenceType\\\\\\"
      unset thisReference;
    fi;

    local typeParam=\\\\$(Variable::GetDeclarationFlagFromType \\\\\\"\\\\\${__declaration_type}\\\\\\" '-');
    # subject='@resolve:this' Log \\\\$__declaration_type = \\\\$typeParam = \\\\$__declaration

    # TODO: does it preserve spaces properly?
    local -\\\\$typeParam this=\\\\\${__declaration};

    ## add type for objects that don't have them set explicitly
    if [[ \\\\$typeParam == 'A' && \\\\$__declaration_type != 'map' && -z \\\\\${this[__object_type]+x} ]]
    then
      # Log setting object type
      this[__object_type]=\\\\\\"\\\\$__declaration_type\\\\\\"
    fi

    unset __declaration;
    unset __declaration_type;
  fi
  \\"

# ------------------------ #

import TypePrimitives
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/variable.sh 1`] = `
"import util/command
namespace util/variable

declare __declaration_type ## for Variable::ExportDeclarationAndTypeToVariables (?)

Variable::Exists() {
  local variableName=\\"$1\\"
  declare -p \\"$variableName\\" &> /dev/null
}

Variable::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'variable' \\"$startsWith\\" || true
}

Variable::GetDeclarationFlagFromType() {
  DEBUG subject=\\"GetParamFromType\\" Log 'getting param from type' \\"$@\\"

  local typeInfo=\\"$1\\"
  local fallback=\\"$2\\"

  if [[ \\"$typeInfo\\" == \\"map\\" ]] || Function::Exists \\"class:\${typeInfo}\\"
  then
    echo A
  else
    case \\"$typeInfo\\" in
      \\"reference\\")
        echo n
      ;;
      \\"array\\")
        echo a
      ;;
      \\"string\\" | \\"boolean\\")
        echo -
      ;;
      \\"integer\\")
        echo i
      ;;
      \\"integerArray\\")
        echo ai
      ;;
      *)
        echo \\"\${fallback:-A}\\"
      ;;
    esac
  fi
}

Variable::GetPrimitiveTypeFromDeclarationFlag() {
  local typeInfo=\\"$1\\"

  case \\"$typeInfo\\" in
    \\"n\\"*)
      echo reference
    ;;
    \\"a\\"*)
      echo array
    ;;
    \\"A\\"*)
      echo map
    ;;
    \\"i\\"*)
      echo integer
    ;;
    \\"ai\\"*)
      echo integerArray
    ;;
    \\"Ai\\"*)
      echo integerMap
    ;;
    *)
      echo string
    ;;
  esac
}

Variable::ExportDeclarationAndTypeToVariables() {
  local variableName=\\"$1\\"
  local targetVariable=\\"$2\\"
  local dereferrence=\\"\${3:-true}\\"

  # TODO: rename for a safer, less common variablename so parents can output to declaration
  local declaration
  local regexArray=\\"declare -([a-zA-Z-]+) $variableName='(.*)'\\"
  local regex=\\"declare -([a-zA-Z-]+) $variableName=\\\\\\"(.*)\\\\\\"\\"
  local regexArrayBash4_4=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p $variableName 2> /dev/null || true)

  local escaped=\\"'\\\\\\\\\\\\'\\"
  local escapedQuotes='\\\\\\\\\\"'
  local singleQuote='\\"'

  local doubleSlashes='\\\\\\\\\\\\\\\\'
  local singleSlash='\\\\'

  [[ -z \\"$definition\\" ]] && e=\\"Variable $variableName not defined\\" throw

  if [[ \\"$definition\\" =~ $regexArray ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\"
  elif [[ \\"$definition\\" =~ $regex ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\" ## TODO: is this transformation needed?
    declaration=\\"\${declaration//$escapedQuotes/$singleQuote}\\"
    declaration=\\"\${declaration//$doubleSlashes/$singleSlash}\\"
  elif [[ \\"$definition\\" =~ $regexArrayBash4_4 ]]
  then
    declaration=\\"\${BASH_REMATCH[2]}\\"
  fi

  local variableType

  DEBUG Log \\"Variable Is $variableName = $definition ==== \${BASH_REMATCH[1]}\\"

  local primitiveType=\${BASH_REMATCH[1]}

  local objectTypeIndirect=\\"$variableName[__object_type]\\"
  if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
  then
    DEBUG Log \\"Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
    variableType=\\"\${!objectTypeIndirect}\\"
  # elif [[ ! -z \${__primitive_extension_fingerprint__boolean+x} && \\"$primitiveType\\" == '-' && \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}\\"* ]]
  # then
  #   variableType=\\"boolean\\"
  else
    variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
    DEBUG Log \\"Primitive Type $primitiveType Resolved \${variableType}\\"
  fi

  if [[ \\"$variableType\\" == 'string' ]] && Function::Exists 'Type::GetPrimitiveExtensionFromVariable'
  then
    local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
    if [[ ! -z \\"$extensionType\\" ]]
    then
      variableType=\\"$extensionType\\"
    fi
  fi

  DEBUG Log \\"Variable $variableName is typeof $variableType\\"

  if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
  then
    local dereferrencedVariableName=\\"$declaration\\"
    Variable::ExportDeclarationAndTypeToVariables \\"$dereferrencedVariableName\\" \\"$targetVariable\\" \\"$dereferrence\\"
  else
    eval \\"$targetVariable=\\\\\\"\\\\$declaration\\\\\\"\\"
    eval \\"\${targetVariable}_type=\\\\$variableType\\"
  fi
}

Variable::PrintDeclaration() {
  local variableName=\\"\${1}\\"
  local dereferrence=\\"\${2:-true}\\"

  local __declaration
  local __declaration_type
  Variable::ExportDeclarationAndTypeToVariables \\"$variableName\\" __declaration \\"$dereferrence\\"
  echo \\"$__declaration\\"
}

alias @get='Variable::PrintDeclaration'
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-config/.gitignore 1`] = `
"/config
/crypto-config
"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-config/configtx.yaml 1`] = `
"################################################################################
#   SECTION: Capabilities
################################################################################
Capabilities:
    Channel: &ChannelCapabilities
        V1_4_3: true
    Orderer: &OrdererCapabilities
        V1_4_2: true
    Application: &ApplicationCapabilities
        V1_4_2: true

################################################################################
#   CHANNEL Defaults
################################################################################
Channel: &ChannelDefaults
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: \\"ANY Readers\\"
        Writers:
            Type: ImplicitMeta
            Rule: \\"ANY Writers\\"
        Admins:
            Type: ImplicitMeta
            Rule: \\"MAJORITY Admins\\"
    Capabilities:
        <<: *ChannelCapabilities

################################################################################
#   Section: Organizations
################################################################################
Organizations:
    - &OrdererOrg
        Name: Orderer
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/root.com/msp 
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.com/msp
        AnchorPeers:
            - Host: peer0.org1.com
              Port: 7051
    - &Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: crypto-config/peerOrganizations/org2.com/msp
        AnchorPeers:
            - Host: peer0.org2.com
              Port: 7051

################################################################################
#   SECTION: Application
################################################################################
Application: &ApplicationDefaults
    Organizations:
    Capabilities:
        <<: *ApplicationCapabilities

################################################################################
#   SECTION: Orderer
################################################################################
Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses: 
        - orderer0.root.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Organizations:

################################################################################
#   Profile
################################################################################
# https://github:com/hyperledger/fabric/blob/master/sampleconfig/configtx.yaml

Profiles:
    SoloOrdererGenesis:
        <<: *ChannelDefaults
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations: 
                    - *Org1
                    - *Org2
    AllOrgChannel:
        <<: *ChannelDefaults
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations: 
                - *Org1
                - *Org2
            Capabilities:
                <<: *ApplicationCapabilities

"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-config/crypto-config-org1.yaml 1`] = `
"PeerOrgs:
  - Name: Org1
    Domain: org1.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-config/crypto-config-org2.yaml 1`] = `
"PeerOrgs:
  - Name: Org2
    Domain: org2.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabric-config/crypto-config-root.yaml 1`] = `
"OrdererOrgs:
  - Name: Orderer
    Domain: root.com
    Specs: 
      - Hostname: orderer0
    "
`;

exports[`e2e/__tmp__/sample-02 should create proper e2e/__tmp__/sample-02/fabrikkaConfig-2orgs-2channels-1chaincode.json 1`] = `
"{
  \\"fabrikkaVersion\\": \\"alpha-0.0.1\\",
  \\"fileVersion\\": \\"0.1\\",
  \\"networkSettings\\": {
    \\"fabricVersion\\": \\"1.4.3\\",
    \\"tls\\": false
  },
  \\"rootOrg\\": {
    \\"organization\\": {
      \\"key\\": \\"root\\",
      \\"name\\": \\"Orderer\\",
      \\"mspName\\": \\"OrdererMSP\\",
      \\"domain\\": \\"root.com\\"
    },
    \\"ca\\": {
      \\"prefix\\": \\"ca\\"
    },
    \\"orderer\\": {
      \\"prefix\\": \\"orderer\\",
      \\"consensus\\": \\"solo\\",
      \\"instances\\": 1
    }
  },
  \\"orgs\\": [
    {
      \\"organization\\": {
        \\"key\\": \\"org1\\",
        \\"name\\": \\"Org1\\",
        \\"mspName\\": \\"Org1MSP\\",
        \\"domain\\": \\"org1.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    },
    {
      \\"organization\\": {
        \\"key\\": \\"org2\\",
        \\"name\\": \\"Org2\\",
        \\"mspName\\": \\"Org2MSP\\",
        \\"domain\\": \\"org2.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    }
  ],
  \\"channels\\": [
    {
      \\"key\\": \\"channel1\\",
      \\"name\\": \\"my-channel1\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        }
      ]
    },
    {
      \\"key\\": \\"channel2\\",
      \\"name\\": \\"my-channel2\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer1\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer1\\"
          ]
        }
      ]
    }
  ],
  \\"chaincodes\\": [
    {
      \\"name\\": \\"chaincode1\\",
      \\"version\\": \\"0.0.1\\",
      \\"lang\\": \\"java\\",
      \\"channel\\": \\"channel1\\",
      \\"init\\": \\"{'Args':[]}\\",
      \\"endorsement\\": \\"AND ('Org1.member')\\",
      \\"directory\\": \\"chaincode1\\"
    }
  ]
}
"
`;

exports[`e2e/__tmp__/sample-02 should create proper files 1`] = `
Array [
  "e2e/__tmp__/sample-02/fabric-compose.sh",
  "e2e/__tmp__/sample-02/fabric-compose/.env",
  "e2e/__tmp__/sample-02/fabric-compose/commands-generated.sh",
  "e2e/__tmp__/sample-02/fabric-compose/docker-compose.yaml",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/base-functions.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/base-help.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/cli/channel_fns.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Contains.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Intersect.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/List.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/Array/Reverse.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/GetSpaces.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/IsNumber.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/SanitizeForVariable.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/SlashReplacement.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/String/UUID.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Color.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Color.var.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Console.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/UI/Cursor.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/oo-bootstrap.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/bash4.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/class.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/command.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/exception.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/exits.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/log.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/namedParameters.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/pipe.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/test.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/tryCatch.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/type.sh",
  "e2e/__tmp__/sample-02/fabric-compose/scripts/lib/util/variable.sh",
  "e2e/__tmp__/sample-02/fabric-config/.gitignore",
  "e2e/__tmp__/sample-02/fabric-config/configtx.yaml",
  "e2e/__tmp__/sample-02/fabric-config/crypto-config-org1.yaml",
  "e2e/__tmp__/sample-02/fabric-config/crypto-config-org2.yaml",
  "e2e/__tmp__/sample-02/fabric-config/crypto-config-root.yaml",
  "e2e/__tmp__/sample-02/fabrikkaConfig-2orgs-2channels-1chaincode.json",
]
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose.sh 1`] = `
"#!/bin/bash
SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

source \\"$BASEDIR\\"/fabric-compose/scripts/lib/oo-bootstrap.sh

source \\"$BASEDIR\\"/fabric-compose/scripts/base-help.sh
source \\"$BASEDIR\\"/fabric-compose/scripts/base-functions.sh
source \\"$BASEDIR\\"/fabric-compose/commands-generated.sh

source \\"$BASEDIR\\"/fabric-compose/.env

if [ \\"$1\\" = \\"up\\" ]; then
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"recreate\\" ]; then
  networkDown
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"down\\" ]; then
  networkDown
elif [ \\"$1\\" = \\"start\\" ]; then
  startNetwork
elif [ \\"$1\\" = \\"stop\\" ]; then
  stopNetwork
elif [ \\"$1\\" = \\"chaincodes\\" ] && [ \\"$2\\" = \\"install\\" ]; then
  installChaincodes
elif [ \\"$1\\" = \\"help\\" ]; then
  printHelp
elif [ \\"$1\\" = \\"--help\\" ]; then
  printHelp
else
  echo \\"No command specified\\"
  echo \\"Basic commands are: up, down, start, stop, recreate\\"
  echo \\"Also check: 'chaincodes install'\\"
  echo \\"Use 'help' or '--help' for more information\\"
fi
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/.env 1`] = `
"COMPOSE_PROJECT_NAME=network
FABRIC_VERSION=1.4.3
LOGGING_LEVEL=info

ROOT_CA_ADMIN_NAME=admin
ROOT_CA_ADMIN_PASSWORD=adminpw

ORG1_CA_ADMIN_NAME=admin
ORG1_CA_ADMIN_PASSWORD=adminpw

"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/commands-generated.sh 1`] = `
"SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

function installChaincodes() {
  
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F60E\\"
    chaincodeInstallTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F618\\"
    chaincodeInstantiateTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
    
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer1\\" \\"U1F60E\\"
    chaincodeInstallTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer1.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer1\\" \\"U1F618\\"
    chaincodeInstantiateTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer1.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
    
}

function generateArtifacts() {
  printHeadline \\"Generating basic configs\\" \\"U1F913\\"
  printItalics \\"Generating crypto material for org Orderer\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-root.yaml\\" \\"ordererOrganizations/root.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org1\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org1.yaml\\" \\"peerOrganizations/org1.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating genesis block\\" \\"U1F3E0\\"
  genesisBlockCreate \\"$BASEDIR/fabric-config\\" \\"$BASEDIR/fabric-config/config\\"
}

function startNetwork() {
  printHeadline \\"Starting network\\" \\"U1F680\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose up -d
  cd $CURRENT_DIR
  sleep 4
}

function stopNetwork() {
  printHeadline \\"Stopping network\\" \\"U1F68F\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose stop
  cd $CURRENT_DIR
  sleep 4
}

function generateChannelsArtifacts() {
    printHeadline \\"Generating config for 'my-channel1'\\" \\"U1F913\\"
  createChannelTx \\"my-channel1\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
  }

function installChannels() {
  
    
    printHeadline \\"Creating 'my-channel1' on Org1/peer0\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoinTls 'my-channel1' 'Org1MSP' 'peer0.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'crypto/users/Admin@org1.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
    
    printItalics \\"Joining 'my-channel1' on  Org1/peer1\\" \\"U1F638\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoinTls 'my-channel1' 'Org1MSP' 'peer1.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'crypto/users/Admin@org1.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
        }

function networkDown() {
  printHeadline \\"Destroying network\\" \\"U1F916\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose down
  cd $CURRENT_DIR

  printf \\"\\\\nRemoving chaincode containers & images... \\\\U1F5D1 \\\\n\\"
   
  docker rm -f $(docker ps -a | grep dev-peer0.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  docker rm -f $(docker ps -a | grep dev-peer1.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer1.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  printf \\"\\\\nRemoving generated configs... \\\\U1F5D1 \\\\n\\"
  rm -rf $BASEDIR/fabric-config/config
  rm -rf $BASEDIR/fabric-config/crypto-config

  printHeadline \\"Done! Network was purged\\" \\"U1F5D1\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/docker-compose.yaml 1`] = `
"version: '2.2'

networks:
  basic:

services:
  
  ca.root.com:
    container_name: ca.root.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.root.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.root.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7030:7054
    command: sh -c 'fabric-ca-server start -b \${ROOT_CA_ADMIN_NAME}:\${ROOT_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  orderer0.root.com:
    container_name: orderer0.root.com
    image: hyperledger/fabric-orderer:\${FABRIC_VERSION}
    environment:
      - ORDERER_GENERAL_LOGLEVEL=\${LOGGING_LEVEL}
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/config/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      - GODEBUG=netdns=go
            #enabled TLS
      - ORDERER_GENERAL_TLS_ENABLED=true
      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
    working_dir: /var/hyperledger/orderer
    command: orderer
    ports:
      - 7040:7050
    volumes:
      - ../fabric-config/config/:/var/hyperledger/config
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/msp/:/var/hyperledger/orderer/msp
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/tls/:/var/hyperledger/orderer/tls
    networks:
      - basic
    
  
  ca.org1.com:
    container_name: ca.org1.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org1.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7031:7054
    command: sh -c 'fabric-ca-server start -b \${ORG1_CA_ADMIN_NAME}:\${ORG1_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org1.com:
    container_name: cli.org1.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org1.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org1.com/msp
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/client.crt
      - CORE_PEER_TLS_KEY_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/client.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/ca.crt
      - TLS_CA_CERT_PATH=:/var/hyperledger/cli/crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org1.com:
    container_name: peer0.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7051:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org1.com:
    container_name: peer1.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer1.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7052:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/base-functions.sh 1`] = `
"import util/log
import util/tryCatch

function certsGenerate() {
  local CONTAINER_NAME=certsGenerate

  local CONFIG_PATH=$1
  local CRYPTO_CONFIG_FILE_NAME=$2
  local ORG_PATH=$3
  local OUTPUT_PATH=$4
  local FULL_CERT_PATH=$OUTPUT_PATH$ORG_PATH

  echo \\"Generating certs...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CRYPTO_CONFIG_FILE_NAME: $CRYPTO_CONFIG_FILE_NAME\\"
  inputLog \\"ORG_PATH: $ORG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"FULL_CERT_PATH: $FULL_CERT_PATH\\"

  if [ -d \\"$FULL_CERT_PATH\\" ]; then
    echo \\"Can't generate certs, directory already exists : $FULL_CERT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME cryptogen generate --config=./fabric-config/$CRYPTO_CONFIG_FILE_NAME

    docker cp $CONTAINER_NAME:/crypto-config/. $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }

  removeContainer $CONTAINER_NAME
  for file in $(find $OUTPUT_PATH/ -iname *_sk); do dir=$(dirname $file); mv \${dir}/*_sk \${dir}/priv-key.pem; done
}

function genesisBlockCreate() {
  local CONTAINER_NAME=genesisBlockCreate

  local CONFIG_PATH=$1
  local OUTPUT_PATH=$2

  echo \\"Creating genesis block...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"

  if [ -d \\"$OUTPUT_PATH\\" ]; then
    echo \\"Cant't generate genesis block, directory already exists : $OUTPUT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile SoloOrdererGenesis -outputBlock ./config/genesis.block || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createChannelTx() {
  local CONTAINER_NAME=createChannelTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local CHANNEL_TX_PATH=$OUTPUT_PATH\\"/\\"$CHANNEL_NAME\\".tx\\"

  echo \\"Creating channelTx for $CHANNEL_NAME...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CONFIG_PROFILE: $CONFIG_PROFILE\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"CHANNEL_TX_PATH: $CHANNEL_TX_PATH\\"

  if [ -f \\"$CHANNEL_TX_PATH\\" ]; then
    echo \\"Can't create channel configuration, it already exists : $CHANNEL_TX_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputCreateChannelTx ./config/channel.tx -channelID \${CHANNEL_NAME} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/channel.tx $CHANNEL_TX_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createAnchorPeerUpdateTx() {
  local CONTAINER_NAME=createAnchorPeerUpdateTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local MSP=$5
  local ANCHOR_PEER_UPDATE_PATH=$OUTPUT_PATH\\"/\\"$MSP\\"anchors.tx\\"

  if [ -f \\"$ANCHOR_PEER_UPDATE_PATH\\" ]; then
    echo \\"Cant't create anchor peer update, it already exists : $ANCHOR_PEER_UPDATE_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputAnchorPeersUpdate ./config/\${MSP}anchors.tx -channelID \${CHANNEL_NAME} -asOrg \${MSP} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/\${MSP}anchors.tx $ANCHOR_PEER_UPDATE_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function chaincodeInstall() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"
  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation. Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiate() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate. Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function chaincodeInstallTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8
  local CA_CERT=\\"/var/hyperledger/cli/\\"$9

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation (TLS). Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiateTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}
  local CA_CERT=\\"/var/hyperledger/cli/\\"\${11}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate (TLS). Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function printHeadline() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Bold)============ %b %s %b ==============$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function printItalics() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Italics)==== %b %s %b ====$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function inputLog() {
  echo \\"$(UI.Color.DarkGray)   $1 $(UI.Color.Default)\\"
}

function certsRemove() {
  local CERTS_DIR_PATH=$1
  rm -rf \\"$CERTS_DIR_PATH\\"/*
}

function removeContainer() {
  CONTAINER_NAME=$1
  docker rm -f \\"$CONTAINER_NAME\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/base-help.sh 1`] = `
"function printHelp() {
  echo \\"Fabrikka is powered by SoftwareMill\\"

  echo \\"\\"
  echo \\"usage: ./fabric-compose.sh <command>\\"
  echo \\"\\"

  echo \\"Commands: \\"
  echo \\"\\"
  echo \\"./fabric-compose.sh up\\"
  echo -e \\"\\\\t Use for first run. Creates all needed artifacts (certs, genesis block) and starts network for the first time.\\"
  echo -e \\"\\\\t After 'up' commands start/stop are used to manage network and rerun to rerun it\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh down\\"
  echo -e \\"\\\\t Back to empty state - destorys created containers, prunes generated certificates, configs.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh start\\"
  echo -e \\"\\\\t Starts already created network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh stop\\"
  echo -e \\"\\\\t Stops already running network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh recreate\\"
  echo -e \\"\\\\t Fresh start - it destorys whole network, certs, configs and then reruns everything.\\"
  echo \\"\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/cli/channel_fns.sh 1`] = `
"function createChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-createChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx
  peer channel join -b \${CHANNEL_NAME}.block

  rm -rf $DIR_NAME
}

function createChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-createChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}

function fetchChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-fetchChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL}
  peer channel join -b \${CHANNEL_NAME}_newest.block

  rm -rf $DIR_NAME
}

function fetchChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-fetchChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL} --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}_newest.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Contains.sh 1`] = `
"Array::Contains() {
  local element
  for element in \\"\${@:2}\\"
  do
    [[ \\"$element\\" = \\"$1\\" ]] && return 0
  done
  return 1
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Intersect.sh 1`] = `
"import util/namedParameters util/type

Array::Intersect() {
  @required [array] arrayA
  @required [array] arrayB

  array intersection

  # http://stackoverflow.com/questions/2312762/compare-difference-of-two-arrays-in-bash
  for i in \\"\${arrayA[@]}\\"
  do
    local skip=
    for j in \\"\${arrayB[@]}\\"
    do
      [[ \\"$i\\" == \\"$j\\" ]] && { skip=1; break; }
    done
    [[ -n $skip ]] || intersection+=(\\"$i\\")
  done

  @get intersection
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/List.sh 1`] = `
"import util/namedParameters

## generates a list separated by new lines
Array::List() {
  @required [string] variableName
  [string] separator=$'\\\\n'

  local indirectAccess=\\"\${variableName}[*]\\"
  (
    local IFS=\\"$separator\\"
    echo \\"\${!indirectAccess}\\"
  )
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Reverse.sh 1`] = `
"import util/namedParameters

## TODO: consider making Parameters::Methods
## since this actually modifies parameters, not arrays

## static methods should be Array::Method, with capital letter

# static version
Array::Reverse() {
  [...rest] this

  local -i length=\${#this[@]}  #$(this length)
  local -a outArray
  local -i indexFromEnd
  local -i index

  for index in \\"\${!this[@]}\\"
  do
    indexFromEnd=$(( $length - 1 - $index ))
    outArray+=( \\"\${this[$indexFromEnd]}\\" )
  done

  @get outArray
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/GetSpaces.sh 1`] = `
"String::GetSpaces() {
  local howMany=\\"$1\\"

  if [[ \\"$howMany\\" -gt 0 ]]
  then
    ( printf \\"%*s\\" \\"$howMany\\" )
  fi
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/IsNumber.sh 1`] = `
"String::IsNumber() {
  local input=\\"$1\\"

  local regex='^-?[0-9]+([.][0-9]+)?$'
  if ! [[ \\"$input\\" =~ $regex ]]
  then
    return 1
  fi
  return 0
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/SanitizeForVariable.sh 1`] = `
"String::SanitizeForVariableName() {
  local type=\\"$1\\"
  echo \\"\${type//[^a-zA-Z0-9]/_}\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/SlashReplacement.sh 1`] = `
"String::ReplaceSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slash$slash/$slashReplacement}\\"
}

String::RestoreSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slashReplacement/$slash}\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/UUID.sh 1`] = `
"String::GenerateUUID() {
  ## https://gist.github.com/markusfisch/6110640
  local N B C='89ab'

  for (( N=0; N < 16; ++N ))
  do
    B=$(( $RANDOM%256 ))

    case $N in
      6)
        printf '4%x' $(( B%16 ))
      ;;
      8)
        printf '%c%x' \${C:$RANDOM%\${#C}:1} $(( B%16 ))
      ;;
      3 | 5 | 7 | 9)
        printf '%02x-' $B
      ;;
      *)
        printf '%02x' $B
      ;;
    esac
  done
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Color.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  alias UI.Color.Default=\\"echo \\\\$'\\\\033[0m'\\"

  alias UI.Color.Black=\\"echo \\\\$'\\\\033[0;30m'\\"
  alias UI.Color.Red=\\"echo \\\\$'\\\\033[0;31m'\\"
  alias UI.Color.Green=\\"echo \\\\$'\\\\033[0;32m'\\"
  alias UI.Color.Yellow=\\"echo \\\\$'\\\\033[0;33m'\\"
  alias UI.Color.Blue=\\"echo \\\\$'\\\\033[0;34m'\\"
  alias UI.Color.Magenta=\\"echo \\\\$'\\\\033[0;35m'\\"
  alias UI.Color.Cyan=\\"echo \\\\$'\\\\033[0;36m'\\"
  alias UI.Color.LightGray=\\"echo \\\\$'\\\\033[0;37m'\\"

  alias UI.Color.DarkGray=\\"echo \\\\$'\\\\033[0;90m'\\"
  alias UI.Color.LightRed=\\"echo \\\\$'\\\\033[0;91m'\\"
  alias UI.Color.LightGreen=\\"echo \\\\$'\\\\033[0;92m'\\"
  alias UI.Color.LightYellow=\\"echo \\\\$'\\\\033[0;93m'\\"
  alias UI.Color.LightBlue=\\"echo \\\\$'\\\\033[0;94m'\\"
  alias UI.Color.LightMagenta=\\"echo \\\\$'\\\\033[0;95m'\\"
  alias UI.Color.LightCyan=\\"echo \\\\$'\\\\033[0;96m'\\"
  alias UI.Color.White=\\"echo \\\\$'\\\\033[0;97m'\\"

  # flags
  alias UI.Color.Bold=\\"echo \\\\$'\\\\033[1m'\\"
  alias UI.Color.Dim=\\"echo \\\\$'\\\\033[2m'\\"
  alias UI.Color.Italics=\\"echo \\\\$'\\\\033[3m'\\"
  alias UI.Color.Underline=\\"echo \\\\$'\\\\033[4m'\\"
  alias UI.Color.Blink=\\"echo \\\\$'\\\\033[5m'\\"
  alias UI.Color.Invert=\\"echo \\\\$'\\\\033[7m'\\"
  alias UI.Color.Invisible=\\"echo \\\\$'\\\\033[8m'\\"

  alias UI.Color.NoBold=\\"echo \\\\$'\\\\033[21m'\\"
  alias UI.Color.NoDim=\\"echo \\\\$'\\\\033[22m'\\"
  alias UI.Color.NoItalics=\\"echo \\\\$'\\\\033[23m'\\"
  alias UI.Color.NoUnderline=\\"echo \\\\$'\\\\033[24m'\\"
  alias UI.Color.NoBlink=\\"echo \\\\$'\\\\033[25m'\\"
  alias UI.Color.NoInvert=\\"echo \\\\$'\\\\033[27m'\\"
  alias UI.Color.NoInvisible=\\"echo \\\\$'\\\\033[28m'\\"
else
  alias UI.Color.Default=\\"echo\\"

  alias UI.Color.Black=\\"echo\\"
  alias UI.Color.Red=\\"echo\\"
  alias UI.Color.Green=\\"echo\\"
  alias UI.Color.Yellow=\\"echo\\"
  alias UI.Color.Blue=\\"echo\\"
  alias UI.Color.Magenta=\\"echo\\"
  alias UI.Color.Cyan=\\"echo\\"
  alias UI.Color.LightGray=\\"echo\\"

  alias UI.Color.DarkGray=\\"echo\\"
  alias UI.Color.LightRed=\\"echo\\"
  alias UI.Color.LightGreen=\\"echo\\"
  alias UI.Color.LightYellow=\\"echo\\"
  alias UI.Color.LightBlue=\\"echo\\"
  alias UI.Color.LightMagenta=\\"echo\\"
  alias UI.Color.LightCyan=\\"echo\\"
  alias UI.Color.White=\\"echo\\"

  # flags
  alias UI.Color.Bold=\\"echo\\"
  alias UI.Color.Dim=\\"echo\\"
  alias UI.Color.Underline=\\"echo\\"
  alias UI.Color.Blink=\\"echo\\"
  alias UI.Color.Invert=\\"echo\\"
  alias UI.Color.Invisible=\\"echo\\"

  alias UI.Color.NoBold=\\"echo\\"
  alias UI.Color.NoDim=\\"echo\\"
  alias UI.Color.NoUnderline=\\"echo\\"
  alias UI.Color.NoBlink=\\"echo\\"
  alias UI.Color.NoInvert=\\"echo\\"
  alias UI.Color.NoInvisible=\\"echo\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  alias UI.Powerline.PointingArrow=\\"echo -e $'\\\\u27a1'\\"
  alias UI.Powerline.ArrowLeft=\\"echo -e $'\\\\u25c0'\\"
  alias UI.Powerline.ArrowRight=\\"echo -e $'\\\\u25b6'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo -e $'\\\\u2198'\\"
  alias UI.Powerline.ArrowDown=\\"echo -e $'\\\\u2B07'\\"
  alias UI.Powerline.PlusMinus=\\"echo -e $'\\\\ue00b1'\\"
  alias UI.Powerline.Branch=\\"echo -e $'\\\\ue0a0'\\"
  alias UI.Powerline.RefersTo=\\"echo -e $'\\\\u27a6'\\"
  alias UI.Powerline.OK=\\"echo -e $'\\\\u2714'\\"
  alias UI.Powerline.Fail=\\"echo -e $'\\\\u2718'\\"
  alias UI.Powerline.Lightning=\\"echo -e $'\\\\u26a1'\\"
  alias UI.Powerline.Cog=\\"echo -e $'\\\\u2699'\\"
  alias UI.Powerline.Heart=\\"echo -e $'\\\\u2764'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo -e $'\\\\u2b50'\\"
  alias UI.Powerline.Saxophone=\\"echo -e $'\\\\U1F3B7'\\"
  alias UI.Powerline.ThumbsUp=\\"echo -e $'\\\\U1F44D'\\"
else
  alias UI.Powerline.PointingArrow=\\"echo '~'\\"
  alias UI.Powerline.ArrowLeft=\\"echo '<'\\"
  alias UI.Powerline.ArrowRight=\\"echo '>'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo '>'\\"
  alias UI.Powerline.ArrowDown=\\"echo '_'\\"
  alias UI.Powerline.PlusMinus=\\"echo '+-'\\"
  alias UI.Powerline.Branch=\\"echo '|}'\\"
  alias UI.Powerline.RefersTo=\\"echo '*'\\"
  alias UI.Powerline.OK=\\"echo '+'\\"
  alias UI.Powerline.Fail=\\"echo 'x'\\"
  alias UI.Powerline.Lightning=\\"echo '!'\\"
  alias UI.Powerline.Cog=\\"echo '{*}'\\"
  alias UI.Powerline.Heart=\\"echo '<3'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo '*''\\"
  alias UI.Powerline.Saxophone=\\"echo '(YEAH)'\\"
  alias UI.Powerline.ThumbsUp=\\"echo '(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Color.var.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  UI_Color_Default=$'\\\\033[0m'

  UI_Color_Black=$'\\\\033[0;30m'
  UI_Color_Red=$'\\\\033[0;31m'
  UI_Color_Green=$'\\\\033[0;32m'
  UI_Color_Yellow=$'\\\\033[0;33m'
  UI_Color_Blue=$'\\\\033[0;34m'
  UI_Color_Magenta=$'\\\\033[0;35m'
  UI_Color_Cyan=$'\\\\033[0;36m'
  UI_Color_LightGray=$'\\\\033[0;37m'

  UI_Color_DarkGray=$'\\\\033[0;90m'
  UI_Color_LightRed=$'\\\\033[0;91m'
  UI_Color_LightGreen=$'\\\\033[0;92m'
  UI_Color_LightYellow=$'\\\\033[0;93m'
  UI_Color_LightBlue=$'\\\\033[0;94m'
  UI_Color_LightMagenta=$'\\\\033[0;95m'
  UI_Color_LightCyan=$'\\\\033[0;96m'
  UI_Color_White=$'\\\\033[0;97m'

  # flags
  UI_Color_Bold=$'\\\\033[1m'
  UI_Color_Dim=$'\\\\033[2m'
  UI_Color_Italics=$'\\\\033[3m'
  UI_Color_Underline=$'\\\\033[4m'
  UI_Color_Blink=$'\\\\033[5m'
  UI_Color_Invert=$'\\\\033[7m'
  UI_Color_Invisible=$'\\\\033[8m'

  UI_Color_NoBold=$'\\\\033[21m'
  UI_Color_NoDim=$'\\\\033[22m'
  UI_Color_NoItalics=$'\\\\033[23m'
  UI_Color_NoUnderline=$'\\\\033[24m'
  UI_Color_NoBlink=$'\\\\033[25m'
  UI_Color_NoInvert=$'\\\\033[27m'
  UI_Color_NoInvisible=$'\\\\033[28m'
else
  UI_Color_Default=\\"\\"

  UI_Color_Black=\\"\\"
  UI_Color_Red=\\"\\"
  UI_Color_Green=\\"\\"
  UI_Color_Yellow=\\"\\"
  UI_Color_Blue=\\"\\"
  UI_Color_Magenta=\\"\\"
  UI_Color_Cyan=\\"\\"
  UI_Color_LightGray=\\"\\"

  UI_Color_DarkGray=\\"\\"
  UI_Color_LightRed=\\"\\"
  UI_Color_LightGreen=\\"\\"
  UI_Color_LightYellow=\\"\\"
  UI_Color_LightBlue=\\"\\"
  UI_Color_LightMagenta=\\"\\"
  UI_Color_LightCyan=\\"\\"
  UI_Color_White=\\"\\"

  # flags
  UI_Color_Bold=\\"\\"
  UI_Color_Dim=\\"\\"
  UI_Color_Italics=\\"\\"
  UI_Color_Underline=\\"\\"
  UI_Color_Blink=\\"\\"
  UI_Color_Invert=\\"\\"
  UI_Color_Invisible=\\"\\"

  UI_Color_NoBold=\\"\\"
  UI_Color_NoDim=\\"\\"
  UI_Color_NoItalics=\\"\\"
  UI_Color_NoUnderline=\\"\\"
  UI_Color_NoBlink=\\"\\"
  UI_Color_NoInvert=\\"\\"
  UI_Color_NoInvisible=\\"\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  UI_Powerline_PointingArrow=$'\\\\u27a1'
  UI_Powerline_ArrowLeft=$'\\\\ue0b2'
  UI_Powerline_ArrowRight=$'\\\\ue0b0'
  UI_Powerline_ArrowRightDown=$'\\\\u2198'
  UI_Powerline_ArrowDown=$'\\\\u2B07'
  UI_Powerline_PlusMinus=$'\\\\ue00b1'
  UI_Powerline_Branch=$'\\\\ue0a0'
  UI_Powerline_RefersTo=$'\\\\u27a6'
  UI_Powerline_OK=$'\\\\u2714'
  UI_Powerline_Fail=$'\\\\u2718'
  UI_Powerline_Lightning=$'\\\\u26a1'
  UI_Powerline_Cog=$'\\\\u2699'
  UI_Powerline_Heart=$'\\\\u2764'

  # colorful
  UI_Powerline_Star=$'\\\\u2b50'
  UI_Powerline_Saxophone=$'\\\\U1F3B7'
  UI_Powerline_ThumbsUp=$'\\\\U1F44D'
else
  UI_Powerline_PointingArrow=\\"'~'\\"
  UI_Powerline_ArrowLeft=\\"'<'\\"
  UI_Powerline_ArrowRight=\\"'>'\\"
  UI_Powerline_ArrowRightDown=\\"'>'\\"
  UI_Powerline_ArrowDown=\\"'_'\\"
  UI_Powerline_PlusMinus=\\"'+-'\\"
  UI_Powerline_Branch=\\"'|}'\\"
  UI_Powerline_RefersTo=\\"'*'\\"
  UI_Powerline_OK=\\"'+'\\"
  UI_Powerline_Fail=\\"'x'\\"
  UI_Powerline_Lightning=\\"'!'\\"
  UI_Powerline_Cog=\\"'{*}'\\"
  UI_Powerline_Heart=\\"'<3'\\"

  # colorful
  UI_Powerline_Star=\\"'*''\\"
  UI_Powerline_Saxophone=\\"'(YEAH)'\\"
  UI_Powerline_ThumbsUp=\\"'(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Console.sh 1`] = `
"import UI/Color

Console::WriteStdErr() {
  # http://stackoverflow.com/questions/2990414/echo-that-outputs-to-stderr
  cat <<< \\"$*\\" 1>&2
  return
}

Console::WriteStdErrAnnotated() {
  local script=\\"$1\\"
  local lineNo=$2
  local color=$3
  local type=$4
  shift; shift; shift; shift

  Console::WriteStdErr \\"$color[$type] $(UI.Color.Blue)[\${script}:\${lineNo}]$(UI.Color.Default) $* \\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Cursor.sh 1`] = `
"import util/class

class:UI.Cursor() {
  # http://askubuntu.com/questions/366103/saving-more-corsor-positions-with-tput-in-bash-terminal
	# http://unix.stackexchange.com/questions/88296/get-vertical-cursor-position

	private integer x
	private integer y

  UI.Cursor.capture() {
    local x
    local y
    IFS=';' read -sdR -p $'\\\\E[6n' y x

    this y = $(( \${y#*[} - 1 ))
    this x = $(( \${x} - 1 ))

    @return
  }

  UI.Cursor.restore() {
    [integer] shift=1

    local -i totalHeight=$(tput lines)
    local -i y=$(this y)
    local -i x=$(this x)

    (( $y + 1 == $totalHeight )) && y+=-$shift

    tput cup $y $x

    @return
  }
}

Type::Initialize UI.Cursor
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/oo-bootstrap.sh 1`] = `
"#!/usr/bin/env bash

###########################
### BOOTSTRAP FUNCTIONS ###
###########################

if [[ -n \\"\${__INTERNAL_LOGGING__:-}\\" ]]
then
  alias DEBUG=\\":; \\"
else
  alias DEBUG=\\":; #\\"
fi

System::SourceHTTP() {
  local URL=\\"$1\\"
  local -i RETRIES=3
  shift

  if hash curl 2>/dev/null
  then
    builtin source <(curl --fail -sL --retry $RETRIES \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && curl --fail -sL --retry $RETRIES \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  else
    builtin source <(wget -t $RETRIES -O - -o /dev/null \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && wget -t $RETRIES -O - -o /dev/null \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  fi
  __oo__importedFiles+=( \\"$URL\\" )
}

System::SourcePath() {
  local libPath=\\"$1\\"
  shift
  # echo trying $libPath
  if [[ -d \\"$libPath\\" ]]
  then
    local file
    for file in \\"$libPath\\"/*.sh
    do
      System::SourceFile \\"$file\\" \\"$@\\"
    done
  else
    System::SourceFile \\"$libPath\\" \\"$@\\" || System::SourceFile \\"\${libPath}.sh\\" \\"$@\\"
  fi
}

declare -g __oo__fdPath=$(dirname <(echo))
declare -gi __oo__fdLength=$(( \${#__oo__fdPath} + 1 ))

System::ImportOne() {
  local libPath=\\"$1\\"
  local __oo__importParent=\\"\${__oo__importParent-}\\"
  local requestedPath=\\"$libPath\\"
  shift

  if [[ \\"$requestedPath\\" == 'github:'* ]]
  then
    requestedPath=\\"https://raw.githubusercontent.com/\${requestedPath:7}\\"
  elif [[ \\"$requestedPath\\" == './'* ]]
  then
    requestedPath=\\"\${requestedPath:2}\\"
  elif [[ \\"$requestedPath\\" == \\"$__oo__fdPath\\"* ]] # starts with /dev/fd
  then
    requestedPath=\\"\${requestedPath:$__oo__fdLength}\\"
  fi

  # [[ \\"$__oo__importParent\\" == 'http://'* || \\"$__oo__importParent\\" == 'https://'* ]] &&
  if [[ \\"$requestedPath\\" != 'http://'* && \\"$requestedPath\\" != 'https://'* ]]
  then
    requestedPath=\\"\${__oo__importParent}/\${requestedPath}\\"
  fi

  if [[ \\"$requestedPath\\" == 'http://'* || \\"$requestedPath\\" == 'https://'* ]]
  then
    __oo__importParent=$(dirname \\"$requestedPath\\") System::SourceHTTP \\"$requestedPath\\"
    return
  fi

  # try relative to parent script
  # try with parent
  # try without parent
  # try global library
  # try local library
  {
    local localPath=\\"$( cd \\"\${BASH_SOURCE[1]%/*}\\" && pwd )\\"
    localPath=\\"\${localPath}/\${libPath}\\"
    System::SourcePath \\"\${localPath}\\" \\"$@\\"
  } || \\\\
  System::SourcePath \\"\${requestedPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__libPath}/\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__path}/\${libPath}\\" \\"$@\\" || e=\\"Cannot import $libPath\\" throw
}

System::Import() {
  local libPath
  for libPath in \\"$@\\"
  do
    System::ImportOne \\"$libPath\\"
  done
}

File::GetAbsolutePath() {
  # http://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
  # $1 : relative filename
  local file=\\"$1\\"
  if [[ \\"$file\\" == \\"/\\"* ]]
  then
    echo \\"$file\\"
  else
    echo \\"$(cd \\"$(dirname \\"$file\\")\\" && pwd)/$(basename \\"$file\\")\\"
  fi
}

System::WrapSource() {
  local libPath=\\"$1\\"
  shift

  builtin source \\"$libPath\\" \\"$@\\" || throw \\"Unable to load $libPath\\"
}

System::SourceFile() {
  local libPath=\\"$1\\"
  shift

  # DEBUG subject=level3 Log \\"Trying to load from: \${libPath}\\"
  [[ ! -f \\"$libPath\\" ]] && return 1 # && e=\\"Cannot import $libPath\\" throw

  libPath=\\"$(File::GetAbsolutePath \\"$libPath\\")\\"

  # echo \\"importing $libPath\\"

  # [ -e \\"$libPath\\" ] && echo \\"Trying to load from: \${libPath}\\"
  if [[ -f \\"$libPath\\" ]]
  then
    ## if already imported let's return
    # if declare -f \\"Array::Contains\\" &> /dev/null &&
    if [[ \\"\${__oo__allowFileReloading-}\\" != true ]] && [[ ! -z \\"\${__oo__importedFiles[*]}\\" ]] && Array::Contains \\"$libPath\\" \\"\${__oo__importedFiles[@]}\\"
    then
      # DEBUG subject=level3 Log \\"File previously imported: \${libPath}\\"
      return 0
    fi

    # DEBUG subject=level2 Log \\"Importing: $libPath\\"

    __oo__importedFiles+=( \\"$libPath\\" )
    __oo__importParent=$(dirname \\"$libPath\\") System::WrapSource \\"$libPath\\" \\"$@\\"
    # eval \\"$(<\\"$libPath\\")\\"

  else
    :
    # DEBUG subject=level2 Log \\"File doesn't exist when importing: $libPath\\"
  fi
}

System::Bootstrap() {
  ## note: aliases are visible inside functions only if
  ## they were initialized AFTER they were created
  ## this is the reason why we have to load files in a specific order
  if ! System::Import Array/Contains
  then
    cat <<< \\"FATAL ERROR: Unable to bootstrap (missing lib directory?)\\" 1>&2
    exit 1
  fi
}

########################
### INITIALZE SYSTEM ###
########################

# From: http://wiki.bash-hackers.org/scripting/debuggingtips
export PS4='+(\${BASH_SOURCE##*/}:\${LINENO}): \${FUNCNAME[0]:+\${FUNCNAME[0]}(): }'

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail

shopt -s expand_aliases
declare -g __oo__libPath=\\"$( cd \\"\${BASH_SOURCE[0]%/*}\\" && pwd )\\"
declare -g __oo__path=\\"\${__oo__libPath}/..\\"
declare -ag __oo__importedFiles

## stubs in case either exception or log is not loaded
namespace() { :; }
throw() { eval 'cat <<< \\"Exception: $e ($*)\\" 1>&2; read -s;'; }

System::Bootstrap

alias import=\\"__oo__allowFileReloading=false System::Import\\"
alias source=\\"__oo__allowFileReloading=true System::ImportOne\\"
alias .=\\"__oo__allowFileReloading=true System::ImportOne\\"

declare -g __oo__bootstrapped=true
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/bash4.sh 1`] = `
"[[ \\"\${BASH_VERSINFO[0]}\\" -lt 4 ]] && echo \\"The module you are trying to load requires bash >= 4\\" && exit 1 || true
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/class.sh 1`] = `
"namespace util/type
import util/type String/SanitizeForVariable
# ------------------------ #

Type::DefineProperty() {
  local visibility=\\"$1\\"
  local class=\\"$2\\"
  local type=\\"$3\\"
  local property=\\"$4\\"
  local assignment=\\"$5\\"
  local defaultValue=\\"$6\\"

  class=\\"\${class//[^a-zA-Z0-9]/_}\\"

  eval \\"__\${class}_property_names+=( '$property' )\\"
  eval \\"__\${class}_property_types+=( '$type' )\\"
  eval \\"__\${class}_property_visibilities+=( '$visibility' )\\"
  # if [[ \\"$assignment\\" == '=' && ! -z \\"$defaultValue\\" ]]
  # then
    eval \\"__\${class}_property_defaults+=( \\\\\\"\\\\$defaultValue\\\\\\" )\\"
  # fi
}

private() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty private $class \\"$@\\"
}

public() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty public $class \\"$@\\"
}

Type::Initialize() {
  local name=\\"$1\\"
  local style=\\"\${2:-default}\\"

  Function::Exists class:$name && class:$name || true

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"

  case \\"$style\\" in
    'primitive') ;;
    'static')
      declare -Ag __oo_static_instance_\${name}=\\"$(Type::Construct $name)\\"
      eval \\"\${name}\\"'(){ '\\"Type::Handle __oo_static_instance_\${name}\\"' \\"$@\\"; }'
    ;;
    *)
      ## add alias for parameters
      alias [$name]=\\"_type=$name Variable::TrapAssign local -A\\"

      ## add alias for creating vars
      alias $name=\\"_type=$name Type::TrapAssign declare -A\\"
    ;;
  esac
}

Type::InitializeStatic() {
  local name=\\"$1\\"

  Type::Initialize \\"$name\\" static
}

Type::Construct() {
  local type=\\"$1\\"
  local typeSanitized=$(String::SanitizeForVariableName $type)
  local assignToVariable=\\"$2\\"

  if [[ ! -z \\"\${__constructor_recursion+x}\\" ]]
  then
    __constructor_recursion=$(( \${__constructor_recursion} + 1 ))
  fi

  local -A constructedType=( [__object_type]=\\"$type\\" )
  # else
  #   echo \\"$assignToVariable[__object_type]=\\\\\\"$type\\\\\\"\\"
  # fi

  if Variable::Exists \\"__\${typeSanitized}_property_names\\"
  then
    local propertyIndexesIndirect=\\"__\${typeSanitized}_property_names[@]\\"
    local -i propertyIndex=0
    local propertyName
    for propertyName in \\"\${!propertyIndexesIndirect}\\"
    do
      # local propertyNameIndirect=__\${typeSanitized}_property_names[$propertyIndex]
      # local propertyName=\\"\${!propertyNameIndirect}\\"

      local propertyTypeIndirect=__\${typeSanitized}_property_types[$propertyIndex]
      local propertyType=\\"\${!propertyTypeIndirect}\\"

      local defaultValueIndirect=__\${typeSanitized}_property_defaults[$propertyIndex]
      local defaultValue=\\"\${!defaultValueIndirect}\\"

      if [[ $propertyType == 'boolean' ]] && [[ \\"$defaultValue\\" == 'false' || \\"$defaultValue\\" == 'true' ]]
      then
        defaultValue=\\"\${__primitive_extension_fingerprint__boolean}:$defaultValue\\"
      fi

      local constructedPropertyDefinition=\\"$defaultValue\\"

      DEBUG Log \\"iterating type: \${typeSanitized}, property: [$propertyIndex] $propertyName = $defaultValue\\"

      ## AUTOMATICALLY CONSTRUCTS THE PROPERTIES:
      # case \\"$propertyType\\" in
      #   'array'|'map'|'string'|'integer'|'integerArray') ;;
      #       # 'integer') constructedPropertyDefinition=\\"\${__integer_fingerprint}$defaultValue\\" ;;
      #       # 'integerArray') constructedPropertyDefinition=\\"\${__integer_array_fingerprint}$defaultValue\\" ;;
      #   * )
      #     if [[ -z \\"$defaultValue\\" && \\"$__constructor_recursion\\" -lt 15 ]]
      #     then
      #       constructedPropertyDefinition=$(Type::Construct \\"$propertyType\\")
      #     fi
      #   ;;
      # esac

      if [[ ! -z \\"$constructedPropertyDefinition\\" ]]
      then
        ## initialize non-empty fields

        DEBUG Log \\"Will exec: constructedType+=( [\\\\\\"$propertyName\\\\\\"]=\\\\\\"$constructedPropertyDefinition\\\\\\" )\\"
        constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )
        # eval 'constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )'
      fi

      propertyIndex+=1
    done
  fi

  if [[ -z \\"$assignToVariable\\" ]]
  then
    Variable::PrintDeclaration constructedType
  else
    local constructedIndex
    for constructedIndex in \\"\${!constructedType[@]}\\"
    do
      eval \\"$assignToVariable[\\\\\\"\\\\$constructedIndex\\\\\\"]=\\\\\\"\\\\\${constructedType[\\\\\\"\\\\$constructedIndex\\\\\\"]}\\\\\\"\\"
    done
  fi
}

alias new='Type::Construct'
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/command.sh 1`] = `
"# no dependencies

Command::GetType() {
  local name=\\"$1\\"
  local typeMatch=$(type -t \\"$name\\" 2> /dev/null || true)
  echo \\"$typeMatch\\"
}

Command::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" || \\"$typeMatch\\" == \\"function\\" || \\"$typeMatch\\" == \\"builtin\\" ]]
}

Alias::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" ]]
}

Function::Exists(){
  local name=\\"$1\\"
  declare -f \\"$name\\" &> /dev/null
}

Function::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'function' \\"$startsWith\\" || true
}

Function::InjectCode() {
  local functionName=\\"$1\\"
  local injectBefore=\\"$2\\"
  local injectAfter=\\"$3\\"
  local body=$(declare -f \\"$functionName\\")
  body=\\"\${body#*{}\\" # trim start
  body=\\"\${body%\\\\}}\\" # trim end
  local enter=$'\\\\n'
  eval \\"\${functionName}() { \${enter}\${injectBefore}\${body}\${injectAfter}\${enter} }\\"
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/exception.sh 1`] = `
"namespace util/exception
import String/GetSpaces String/SlashReplacement UI/Color UI/Console

#########################
### HANDLE EXCEPTIONS ###
#########################

trap \\"__EXCEPTION_TYPE__=\\\\\\"\\\\$_\\\\\\" command_not_found_handle \\\\$? \\\\$BASH_COMMAND\\" ERR
set -o errtrace  # trace ERR through 'time command' and other functions

# unalias throw 2> /dev/null || true
unset -f throw 2> /dev/null || true
alias throw=\\"__EXCEPTION_TYPE__=\\\\\${e:-Manually invoked} command_not_found_handle\\"

Exception::CustomCommandHandler() {
  ## this method can be overridden to create a custom, unknown command handler
  return 1
}

Exception::FillExceptionWithTraceElements() {
  local IFS=$'\\\\n'
  for traceElement in $(Exception::DumpBacktrace \${skipBacktraceCount:-3})
  do
    exception+=( \\"$traceElement\\" )
  done
}

command_not_found_handle() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  # ignore the error from the catch subshell itself
  if [[ \\"$*\\" = '( set -'*'; true'* ]] ## TODO: refine with a regex and test
  then
    return 0
  fi

  Exception::CustomCommandHandler \\"$@\\" && return 0 || true

  local exit_code=\\"\${1}\\"
  shift || true # there might have not been any parameter, in which case \\"shift\\" would fail
  local script=\\"\${BASH_SOURCE[1]#./}\\"
  local lineNo=\\"\${BASH_LINENO[0]}\\"
  local undefinedObject=\\"$*\\"
  local type=\\"\${__EXCEPTION_TYPE__:-\\"Undefined command\\"}\\"

  if [[ \\"$undefinedObject\\" == \\"(\\"*\\")\\" ]]
  then
    type=\\"Subshell returned a non-zero value\\"
  fi

  if [[ -z \\"$undefinedObject\\" ]]
  then
    undefinedObject=\\"$type\\"
  fi

  if [[ $__oo__insideTryCatch -gt 0 ]]
  then
    subject=level3 Log \\"inside Try No.: $__oo__insideTryCatch\\"

    if [[ ! -s $__oo__storedExceptionLineFile ]]; then
      echo \\"$lineNo\\" > $__oo__storedExceptionLineFile
    fi
    if [[ ! -s $__oo__storedExceptionFile ]]; then
      echo \\"$undefinedObject\\" > $__oo__storedExceptionFile
    fi
    if [[ ! -s $__oo__storedExceptionSourceFile ]]; then
      echo \\"$script\\" > $__oo__storedExceptionSourceFile
    fi
    if [[ ! -s $__oo__storedExceptionBacktraceFile ]]; then
      Exception::DumpBacktrace 2 > $__oo__storedExceptionBacktraceFile
    fi

    return 1 # needs to be return 1
  fi

  if [[ $BASH_SUBSHELL -ge 25 ]] ## TODO: configurable
  then
    echo \\"ERROR: Call stack exceeded (25).\\"
    Exception::ContinueOrBreak || exit 1
  fi

  local -a exception=( \\"$lineNo\\" \\"$undefinedObject\\" \\"$script\\" )

  Exception::FillExceptionWithTraceElements

  Console::WriteStdErr
  Console::WriteStdErr \\" $(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Bold)UNCAUGHT EXCEPTION: $(UI.Color.LightRed)\${type} $(UI.Color.Yellow)$(UI.Color.Italics)(\${exit_code})$(UI.Color.Default)\\"
  Exception::PrintException \\"\${exception[@]}\\"

  Exception::ContinueOrBreak
}

Exception::PrintException() {
  #    [...rest] exception
  local -a exception=(\\"$@\\")

  local -i backtraceIndentationLevel=\${backtraceIndentationLevel:-0}

  local -i counter=0
  local -i backtraceNo=0

  local -a backtraceLine
  local -a backtraceCommand
  local -a backtraceFile

  #for traceElement in Exception::GetLastException
  while [[ $counter -lt \${#exception[@]} ]]
  do
    backtraceLine[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceCommand[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceFile[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1

    backtraceNo+=1
  done

  local -i index=1

  while [[ $index -lt $backtraceNo ]]
  do
    Console::WriteStdErr \\"$(Exception::FormatExceptionSegment \\"\${backtraceFile[$index]}\\" \\"\${backtraceLine[$index]}\\" \\"\${backtraceCommand[($index - 1)]}\\" $(( $index + $backtraceIndentationLevel )) )\\"
    index+=1
  done
}

Exception::CanHighlight() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  if [[ \\"$errLine\\" == *\\"$stringToMarkWithoutSlash\\"* ]]
  then
    return 0
  else
    return 1
  fi
}

Exception::HighlightPart() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
  local underlinedObjectInLine=\\"\${errLine/$stringToMarkWithoutSlash/$underlinedObject}\\"

  # Bring back the slash:
  underlinedObjectInLine=\\"$(String::RestoreSlashes \\"$underlinedObjectInLine\\")\\"

  # Trimming:
  underlinedObjectInLine=\\"\${underlinedObjectInLine#\\"\${underlinedObjectInLine%%[![:space:]]*}\\"}\\" # \\"

  echo \\"$underlinedObjectInLine\\"
}

Exception::GetUnderlinedPart() {
  #    [string] stringToMark
  local stringToMark=\\"$1\\"

  echo \\"$(UI.Color.LightGreen)$(UI.Powerline.RefersTo) $(UI.Color.Magenta)$(UI.Color.Underline)$stringToMark$(UI.Color.White)$(UI.Color.NoUnderline)\\"
}

Exception::FormatExceptionSegment() {
  local script=\\"$1\\"
  local -i lineNo=\\"$2\\"
  local stringToMark=\\"$3\\"
  local -i callPosition=\\"\${4:-1}\\"
  #    [string] script
  #    [integer] lineNo
  #    [string] stringToMark
  #    [integer] callPosition=1

  local errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  local originalErrLine=\\"$errLine\\"

  local -i linesTried=0

  ## TODO: when line ends with slash \\\\ it is a multiline statement
  ## TODO: when eval or alias
  # In case it's a multiline eval, sometimes bash gives a line that's offset by a few
  while [[ $linesTried -lt 5 && $lineNo -gt 0 ]] && ! Exception::CanHighlight \\"$errLine\\" \\"$stringToMark\\"
  do
    linesTried+=1
    lineNo+=-1
    errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  done

  # Cut out the path, leave the script name
  script=\\"\${script##*/}\\"

  local prefix=\\"   $(UI.Powerline.Branch)$(String::GetSpaces $(($callPosition * 3 - 3)) || true) \\"

  if [[ $linesTried -ge 5 ]]
  then
    # PRINT THE ORGINAL OBJECT AND ORIGINAL LINE #
    #local underlinedObject=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"
    local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
    echo \\"\${prefix}$(UI.Color.White)\${underlinedObject}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
    prefix=\\"$prefix$(UI.Powerline.Fail) \\"
    errLine=\\"$originalErrLine\\"
  fi

  local underlinedObjectInLine=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"

  echo \\"\${prefix}$(UI.Color.White)\${underlinedObjectInLine}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
}

Exception::ContinueOrBreak() (
  ## TODO: Exceptions that happen in commands that are piped to others do not HALT the execution
  ## TODO: Add a workaround for this ^
  ## probably it's enough to -pipefail, check for a pipe in command_not_found - and if yes - return 1

  # if in a terminal
  if [ -t 0 ]
  then
    trap \\"stty sane; exit 1\\" INT
    Console::WriteStdErr
    Console::WriteStdErr \\" $(UI.Color.Yellow)$(UI.Powerline.Lightning)$(UI.Color.White) Press $(UI.Color.Bold)[CTRL+C]$(UI.Color.White) to exit or $(UI.Color.Bold)[Return]$(UI.Color.White) to continue execution.\\"
    read -s
    Console::WriteStdErr \\"$(UI.Color.Blue)$(UI.Powerline.Cog)$(UI.Color.White)  Continuing...$(UI.Color.Default)\\"
    return 0
  else
    Console::WriteStdErr
    exit 1
  fi
)

Exception::DumpBacktrace() {
  local -i startFrom=\\"\${1:-1}\\"
  #    [integer] startFrom=1
  # inspired by: http://stackoverflow.com/questions/64786/error-handling-in-bash

  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local -i i=0

  while caller $i > /dev/null
  do
    if (( $i + 1 >= $startFrom ))
    then
      local -a trace=( $(caller $i) )

      echo \\"\${trace[0]}\\"
      echo \\"\${trace[1]}\\"
      echo \\"\${trace[@]:2}\\"
    fi
    i+=1
  done
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/exits.sh 1`] = `
"#!/usr/bin/env bash
#
# exits
#
# Those values are come from /usr/include/sysexits.h
#

# successful termination
Util_ExitCode_OK=0
Util_ExitCode_USAGE=64  # command line usage error
Util_ExitCode_DATAERR=65  # data format error
Util_ExitCode_NOINPUT=66  # cannot open input
Util_ExitCode_NOUSER=67  # addressee unknown
Util_ExitCode_NOHOST=68  # host name unknown
Util_ExitCode_UNAVAILABLE=69  # service unavailable
Util_ExitCode_SOFTWARE=70  # internal software error
Util_ExitCode_OSERR=71  # system error (e.g., can't fork)
Util_ExitCode_OSFILE=72  # critical OS file missing
Util_ExitCode_CANTCREAT=73  # can't create (user) output file
Util_ExitCode_IOERR=74  # input/output error
Util_ExitCode_TEMPFAIL=75  # temp failure; user is invited to retry
Util_ExitCode_PROTOCOL=76  # remote error in protocol
Util_ExitCode_NOPERM=77  # permission denied
Util_ExitCode_CONFIG=78  # configuration error
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/log.sh 1`] = `
"import util/bash4
import UI/Color UI/Console

declare -Ag __oo__logScopes
declare -Ag __oo__logScopeOutputs
declare -Ag __oo__logDisabledFilter
declare -Ag __oo__loggers

Log::NameScope() {
  local scopeName=\\"$1\\"
  local script=\\"\${BASH_SOURCE[1]}\\"
  __oo__logScopes[\\"$script\\"]=\\"$scopeName\\"
}

Log::AddOutput() {
  local scopeName=\\"$1\\"
  local outputType=\\"\${2:-STDERR}\\"
  __oo__logScopeOutputs[\\"$scopeName\\"]+=\\"$outputType;\\"
}

Log::ResetOutputsAndFilters() {
  local scopeName=\\"$1\\"
  unset __oo__logScopeOutputs[\\"$scopeName\\"]
  unset __oo__logDisabledFilter[\\"$scopeName\\"]
}

Log::ResetAllOutputsAndFilters() {
  unset __oo__logScopeOutputs
  unset __oo__logDisabledFilter
  declare -Ag __oo__logScopeOutputs
  declare -Ag __oo__logDisabledFilter
}

Log::DisableFilter() {
  __oo__logDisabledFilter[\\"$1\\"]=true
}

Log() {
  local callingFunction=\\"\${FUNCNAME[1]}\\"
  local callingScript=\\"\${BASH_SOURCE[1]}\\"
  local scope
  if [[ ! -z \\"\${__oo__logScopes[\\"$callingScript\\"]}\\" ]]
  then
    scope=\\"\${__oo__logScopes[\\"$callingScript\\"]}\\"
  else # just the filename without extension
    scope=\\"\${callingScript##*/}\\"
    scope=\\"\${scope%.*}\\"
  fi
  local loggerList
  local loggers
  local logger
  local logged

  if [[ ! -z \\"$subject\\" ]]
  then
    if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\"
    fi

    loggers=( \${loggerList//;/ } )
    for logger in \\"\${loggers[@]}\\"
    do
      subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      logged=true
    done
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope/$callingFunction\\"]} == true || \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
          subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
          logged=true
      done
    fi
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
        subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      done
    fi
  fi
}

Log::RegisterLogger() {
  local logger=\\"$1\\"
  local method=\\"$2\\"
  __oo__loggers[\\"$logger\\"]=\\"$method\\"
}

Log::Using() {
  local logger=\\"$1\\"
  shift
  if [[ ! -z \${__oo__loggers[\\"$logger\\"]} ]]
  then
      \${__oo__loggers[\\"$logger\\"]} \\"$@\\"
  fi
}

Logger::DEBUG() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) DEBUG \\"$@\\"
}
Logger::ERROR() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Red) ERROR \\"$@\\"
}
Logger::INFO() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Blue) INFO \\"$@\\"
}
Logger::WARN() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) WARN \\"$@\\"
}
Logger::CUSTOM() {
    Console::WriteStdErr \\"$(UI.Color.Yellow)[\${subject^^}] $(UI.Color.Default)$* \\"
}
Logger::DETAILED() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) \\"\${subject^^}\\" \\"$@\\"
}

Log::RegisterLogger STDERR Console::WriteStdErr
Log::RegisterLogger DEBUG Logger::DEBUG
Log::RegisterLogger ERROR Logger::ERROR
Log::RegisterLogger INFO Logger::INFO
Log::RegisterLogger WARN Logger::WARN
Log::RegisterLogger CUSTOM Logger::CUSTOM
Log::RegisterLogger DETAILED Logger::DETAILED

alias namespace=\\"Log::NameScope\\"
namespace oo/log
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/namedParameters.sh 1`] = `
"namespace oo/type
import util/variable

# depends on modules: variable, exception

declare -g ref=D10F7FB728364261BB50A7E818D537C4
declare -g var=A04FB7D7594E479B8CD8D90C5014E37A

# TODO: required parameters
Variable::TrapAssignNumberedParameter() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift
  #  Log \\"TRAP: \${commandWithArgs[@]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* || \\"$command\\" == \\"_isRequired=\\"* || \\"$command\\" == \\"_isReadOnly=\\"*  || \\"$command\\" == \\"_noHandle=\\"* || \\"$command\\" == \\"_isGlobal=\\"* ]]
  then
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __assign_next=true
    DEBUG subject=\\"parameters-assign\\" Log \\"Will assign next one\\"

    local nextAssignment=$(( \${__assign_paramNo:-0} + 1 ))
    if [[ \\"\${!nextAssignment-}\\" == \\"$ref:\\"* ]]
    then
      DEBUG subject=\\"parameters-reference\\" Log \\"next param ($nextAssignment) is an object reference\\"
      __assign_parameters=\\"-n\\"
    ## TODO: type checking
    else
      __assign_parameters=\\"\\"
    fi
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* || $varDeclaration == '\${__assign'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"
  # TODO: checking for parameter existence or default value

  if [[ \\"\${__assign_varType:-null}\\" != \\"null\\" ]]
  then
    local requiredType=\\"$__assign_varType\\" ## TODO: use this information
    [[ $__assign_parameters == '-n' ]] && __assign_varType=\\"reference\\"

    DEBUG subject=\\"parameters-setting\\" Log \\"SETTING: [$__assign_varType] $__assign_varName = \\\\$$__assign_paramNo [rq:$__assign_valueRequired]\\" # [val:\${!__assign_paramNo}]
    # subject=\\"parameters-setting\\" Log --

    if [[ \\"$__assign_valueRequired\\" == 'true' && -z \\"\${!__assign_paramNo+x}\\" ]]
    then
      e=\\"Value is required for the parameter $__assign_varName ($__assign_paramNo) of type [$__assign_varType]\\" throw
    fi

    unset __assign_valueRequired __assign_valueReadOnly

    local indirectAccess=\\"$__assign_paramNo\\"

    if [[ \\"\${!indirectAccess-}\\" == \\"$var:\\"* ]]
    then
      local realVarName=\\"\${!indirectAccess#*$var:}\\"
      if Variable::Exists \\"$realVarName\\"
      then
        local __declaration
        local __declaration_type
        Variable::ExportDeclarationAndTypeToVariables \\"$realVarName\\" __declaration
        # Log realVarName \\"\${!indirectAccess#*$var:}\\" type \\"$declaration_type vs $__assign_varType\\" declaration: \\"$__declaration\\" vs \\"$(Variable::PrintDeclaration \\"$realVarName\\")\\"
        indirectAccess=__declaration

        if [[ \\"$__declaration_type\\" != \\"$__assign_varType\\" && \\"$__assign_varType\\" != 'params' && \\"$__assign_varType\\" != 'rest' ]]
        then
          e=\\"Passed in variable: ($__assign_paramNo) $__assign_varName is of different than its required type [required: $__assign_varType] [actual: $__declaration_type]\\" throw
        fi
      fi
    fi

    case \\"$__assign_varType\\" in
      'params')
      # passing array:
        eval \\"__assign_arrLength=$__assign_arrLength\\"
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo:$__assign_arrLength}\\\\\\" )\\"

        ## TODO: foreach param expand $var: indirectAccess
        __assign_paramNo+=$(($__assign_arrLength - 1))
        unset __assign_arrLength
      ;;
      'rest')
      ## TODO: foreach param expand $var: indirectAccess
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo}\\\\\\" )\\"
      ;;
      'boolean')
        DEBUG Log passed \\"\${!indirectAccess}\\", default \\"\${__assign_varValue}\\"
        local boolean_fingerprint=\\"\${__primitive_extension_fingerprint__boolean:+__primitive_extension_fingerprint__boolean:}\\"

        if [[ ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"\${boolean_fingerprint}\\"* ]]
          then
            __assign_varValue=\\"\${!indirectAccess}\\"
          elif [[ \\"\${!indirectAccess}\\" == 'true' || \\"\${!indirectAccess}\\" == 'false' ]]
          then
            __assign_varValue=\\"\${boolean_fingerprint}\${!indirectAccess}\\"
          else
            __assign_varValue=\\"\${boolean_fingerprint}false\\"
          fi
        elif [[ \\"\${__assign_varValue}\\" == 'true' || \\"\${__assign_varValue}\\" == 'false' ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}\${__assign_varValue}\\"
        elif [[ \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}true\\" && \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}false\\" ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}false\\"
        fi
        eval \\"$__assign_varName=\\\\\\"\${__assign_varValue}\\\\\\"\\"
      ;;
      'string'|'integer'|'reference')
        if [[ \\"$__assign_varType\\" == \\"reference\\" || ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"$ref:\\"* ]]
          then
            local refVarName=\\"\${!indirectAccess#*$ref:}\\"
            eval \\"$__assign_varName=$refVarName\\"
          else
            DEBUG Log \\"Will eval $__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
            # escape $indirectAccess with \\\\\\"
            # local escapedAssignment=\\"\${!indirectAccess}\\"
            # escapedAssignment=\\"\${escapedAssignment//\\\\\\"/\\\\\\\\\\\\\\"}\\"
            # execute=\\"$__assign_varName=\\\\\\"$escapedAssignment\\\\\\"\\"
            eval \\"$__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          fi

        # DEBUG subject=\\"parameters-executing\\" Log \\"EXECUTING: $execute\\"
        fi
      ;;
      *) # 'array'|'map'|objects
        if [[ ! -z \\"\${!indirectAccess}\\" ]]
        then
          eval \\"local -$(Variable::GetDeclarationFlagFromType '$__assign_varType') tempMap=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          local index
          local value

          ## copy the array / map item by item
          for index in \\"\${!tempMap[@]}\\"
          do
            eval \\"$__assign_varName[\\\\$index]=\\\\\\"\\\\\${tempMap[\\\\$index]}\\\\\\"\\"
          done

          unset index value tempMap
        fi
      ;;
    esac

    unset __assign_varType
    unset __assign_parameters

    if [[ \\"$__assign_valueGlobal\\" == \\"true\\" ]]; then
      local declaration=\\"$(declare -p $__assign_varName)\\"
      declaration=\\"\${declaration/declare/declare -g}\\"
      eval \\"$declaration\\"
    fi
    unset __assign_valueGlobal

    if [[ \\"$__assign_noHandle\\" != 'true' && ! -z \${__oo__bootstrapped+x} ]] && declare -f 'Type::CreateHandlerFunction' &> /dev/null
    then
      DEBUG Log \\"Will create handle for $__assign_varName\\"
      Type::CreateHandlerFunction \\"$__assign_varName\\" # 2> /dev/null || true
    fi
  fi

  if [[ \\"$command\\" != \\"local\\" || \\"\${__assign_next-}\\" != \\"true\\" ]]
  then
    __assign_normalCodeStarted+=1

    DEBUG subject=\\"parameters-nopass\\" Log \\"NOPASS \${commandWithArgs[*]}\\"
    DEBUG subject=\\"parameters-nopass\\" Log \\"normal code count ($__assign_normalCodeStarted)\\"
  # subject=\\"parameters-nopass\\" Log --
  else
    unset __assign_next

    __assign_normalCodeStarted=0
    __assign_varName=\\"$varName\\"
    __assign_varValue=\\"$varValue\\"
    __assign_varType=\\"$__capture_type\\"
    __assign_arrLength=\\"$__capture_arrLength\\"
    __assign_valueRequired=\\"$__capture_valueRequired\\"
    __assign_valueReadOnly=\\"$__capture_valueReadOnly\\"
    __assign_valueGlobal=\\"$__capture_valueGlobal\\"
    __assign_noHandle=\\"$__capture_noHandle\\"

    DEBUG subject=\\"parameters-pass\\" Log \\"PASS \${commandWithArgs[*]}\\"
    # subject=\\"parameters-pass\\" Log --

    __assign_paramNo+=1
  fi
}

Variable::InTrapCaptureParameters() {
  DEBUG subject=\\"parameters\\" Log \\"Capturing Type $_type\\"
  # subject=\\"parameters\\" Log --

  __capture_type=\\"$_type\\"
  __capture_arrLength=\\"\${l-'\${#@}'}\\"
  __capture_valueRequired=\\"\${_isRequired-false}\\"
  __capture_valueReadOnly=\\"\${_isReadOnly-false}\\"
  __capture_valueGlobal=\\"\${_isGlobal-false}\\"
  __capture_noHandle=\\"\${_noHandle-false}\\"
}

## ARGUMENT RESOLVERS ##

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Variable::TrapAssign='Variable::InTrapCaptureParameters; local -i __assign_normalCodeStarted=0; trap \\"declare -i __assign_paramNo; Variable::TrapAssignNumberedParameter \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__assign_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __assign_varType __assign_varName __assign_varValue __assign_paramNo __assign_valueRequired __assign_valueReadOnly __assign_valueGlobal __assign_noHandle\\" DEBUG; true; true; '
alias [reference]='_type=reference Variable::TrapAssign local -n'
alias Variable::TrapAssignLocal='Variable::TrapAssign local \${__assign_parameters}'
alias [string]=\\"_type=string Variable::TrapAssignLocal\\"
# alias [string]=\\"_type=string Variable::TrapAssign local \\\\\${__assign_parameters}\\"
alias [integer]='_type=integer Variable::TrapAssign local \${__assign_parameters:--i}'
alias [array]='_type=array Variable::TrapAssign local \${__assign_parameters:--a}'
alias [map]='_type=map Variable::TrapAssign local \${__assign_parameters:--A}'
# TODO: alias [integerArray]='_type=array Variable::TrapAssign local \${__assign_parameters:--ai}'
alias [boolean]='_type=boolean Variable::TrapAssignLocal'
alias [string[]]='_type=params Variable::TrapAssignLocal'
alias [string[1]]='l=1 _type=params Variable::TrapAssignLocal'
alias [string[2]]='l=2 _type=params Variable::TrapAssignLocal'
alias [string[3]]='l=3 _type=params Variable::TrapAssignLocal'
alias [string[4]]='l=4 _type=params Variable::TrapAssignLocal'
alias [string[5]]='l=5 _type=params Variable::TrapAssignLocal'
alias [string[6]]='l=6 _type=params Variable::TrapAssignLocal'
alias [string[7]]='l=7 _type=params Variable::TrapAssignLocal'
alias [string[8]]='l=8 _type=params Variable::TrapAssignLocal'
alias [string[9]]='l=9 _type=params Variable::TrapAssignLocal'
alias [string[10]]='l=10 _type=params Variable::TrapAssignLocal'
alias [...rest]='_type=rest Variable::TrapAssignLocal'
alias @required='_isRequired=true'
alias @handleless='_noHandle=true'
alias @global='_isGlobal=true'
# TODO: alias @readonly='_isReadOnly=true '
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/pipe.sh 1`] = `
"# no dependencies

Pipe::Capture() {
  read -r -d '' $1 || true
}

Pipe::CaptureFaithful() {
  IFS= read -r -d '' $1 || true
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/test.sh 1`] = `
"import util/class util/tryCatch UI/Cursor

class:Test() {
  private UI.Cursor onStartCursor
  private string groupName
  public string errors
  # public boolean errors = false

  Test.Start() {
    [string] verb
    [string] description

    this onStartCursor capture
    echo \\"$(UI.Color.Yellow)$(UI.Powerline.PointingArrow) $(UI.Color.Yellow)[$(UI.Color.LightGray)$(UI.Color.Bold)TEST$(UI.Color.NoBold)$(UI.Color.Yellow)] $(UI.Color.White)\${verb} \${description}$(UI.Color.Default)\\"
    @return
  }

  Test.OK() {
    [string] printInPlace=true

    [[ $printInPlace == true ]] && this onStartCursor restore

    echo \\"$(UI.Color.Green)$(UI.Powerline.OK) $(UI.Color.Yellow)[ $(UI.Color.Green)$(UI.Color.Bold)OK$(UI.Color.NoBold) $(UI.Color.Yellow)]$(UI.Color.Default)\\"
    @return
  }

  Test.EchoedOK() {
    this OK false
  }

  Test.Fail() {
    [string] line
    [string] error
    [string] source
    echo \\"$(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Yellow)[$(UI.Color.Red)$(UI.Color.Bold)FAIL$(UI.Color.NoBold)$(UI.Color.Yellow)]$(UI.Color.Default) in $(UI.Color.Yellow)\${source}$(UI.Color.Default):$(UI.Color.Blue)\${line}$(UI.Color.Default) $(UI.Powerline.RefersTo) $(UI.Color.Red)\${error}$(UI.Color.Default)\\"
    @return
  }

  Test.DisplaySummary() {
    if [[ $(this errors) == true ]]
    # if this errors
    then
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Red)There were errors $(UI.Color.Default)$(UI.Powerline.Lightning)\\"
      this errors = false
    else
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Yellow)Test group completed successfully $(UI.Color.Default)$(UI.Powerline.ThumbsUp)\\"
    fi
    @return
  }

  Test.NewGroup() {
    [string] groupName

    echo \\"$(UI.Powerline.ArrowRight)\\" $(UI.Color.Magenta)Testing [$(UI.Color.White)\${groupName}$(UI.Color.Magenta)]: $(UI.Color.Default)

    this groupName = \\"$groupName\\"

    @return
  }
}

Type::InitializeStatic Test

### TODO: special case for static classes
### for storage use a generated variable name (hash of class name?)
### for execution use class' name, e.g. Test Start

alias describe='Test NewGroup'
alias summary='Test DisplaySummary'
alias caught=\\"echo \\\\\\"CAUGHT: $(UI.Color.Red)\\\\$__BACKTRACE_COMMAND__$(UI.Color.Default) in \\\\$__BACKTRACE_SOURCE__:\\\\$__BACKTRACE_LINE__\\\\\\"\\"
alias it=\\"Test Start it\\"
alias expectPass=\\"Test OK; catch { Test errors = true; Test Fail \\\\\\"\\\\\${__EXCEPTION__[@]}\\\\\\"; }\\"
alias expectOutputPass=\\"Test EchoedOK; catch { Test errors = true; Test Fail; }\\"
alias expectFail='catch { caught; Test EchoedOK; }; test $? -eq 1 && Test errors = false; '
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/tryCatch.sh 1`] = `
"# no dependencies
declare -ig __oo__insideTryCatch=0
declare -g __oo__presetShellOpts=\\"$-\\"

# in case try-catch is nested, we set +e before so the parent handler doesn't catch us instead
alias try='[[ $__oo__insideTryCatch -eq 0 ]] || __oo__presetShellOpts=\\"$(echo $- | sed 's/[is]//g')\\"; __oo__insideTryCatch+=1; set +e; ( set -e; true; '
alias catch='); declare __oo__tryResult=$?; __oo__insideTryCatch+=-1; [[ $__oo__insideTryCatch -lt 1 ]] || set -\${__oo__presetShellOpts:-e} && Exception::Extract $__oo__tryResult || '

Exception::SetupTemp() {
  declare -g __oo__storedExceptionLineFile=\\"$(mktemp -t stored_exception_line.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionSourceFile=\\"$(mktemp -t stored_exception_source.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionBacktraceFile=\\"$(mktemp -t stored_exception_backtrace.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionFile=\\"$(mktemp -t stored_exception.$$.XXXXXXXXXX)\\"
}

Exception::CleanUp() {
  local exitVal=$?
  rm -f $__oo__storedExceptionLineFile $__oo__storedExceptionSourceFile $__oo__storedExceptionBacktraceFile $__oo__storedExceptionFile || exit 1
  exit $exitVal
}

Exception::ResetStore() {
  > $__oo__storedExceptionLineFile
  > $__oo__storedExceptionFile
  > $__oo__storedExceptionSourceFile
  > $__oo__storedExceptionBacktraceFile
}

Exception::GetLastException() {
  if [[ -s $__oo__storedExceptionFile ]]
  then
    cat $__oo__storedExceptionLineFile
    cat $__oo__storedExceptionFile
    cat $__oo__storedExceptionSourceFile
    cat $__oo__storedExceptionBacktraceFile

    Exception::ResetStore
  else
    echo -e \\"\${BASH_LINENO[1]}\\\\n \\\\n\${BASH_SOURCE[2]#./}\\"
  fi
}

Exception::Extract() {
  local retVal=$1
  unset __oo__tryResult

  if [[ $retVal -gt 0 ]]
  then
    local IFS=$'\\\\n'
    __EXCEPTION__=( $(Exception::GetLastException) )

    local -i counter=0
    local -i backtraceNo=0

    while [[ $counter -lt \${#__EXCEPTION__[@]} ]]
    do
      __BACKTRACE_LINE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_COMMAND__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_SOURCE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      backtraceNo+=1
    done

    return 1 # so that we may continue with a \\"catch\\"
  fi
  return 0
}

Exception::SetupTemp
trap Exception::CleanUp EXIT INT TERM
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/type.sh 1`] = `
"namespace util/type

import util/bash4
import Array/Contains String/SanitizeForVariable
import util/namedParameters util/pipe util/variable util/command

declare -g __primitive_extension_declaration=2D6A822E
declare -g __primitive_extension_fingerprint__boolean=\${__primitive_extension_declaration}36884C70843578D37E6773C4
declare -g __return_separator=52A586A48E074BB6812DCFDC790841F5
declare -g __oo__type_handler_functions=()
declare -g __oo__variableMethodPrefix=\\"$var:\\"

# /**
#   * Code like: Variable::ExportDeclarationAndTypeToVariables
#   * TODO: Merge parts
#   */
Type::GetTypeOfVariable() {
  local variableName=\\"$1\\"
  local dereferrence=\\"\${2:-true}\\"

  local regex=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p \\"\${variableName}\\" 2> /dev/null || true)

  [[ -z \\"$definition\\" ]] && e=\\"Variable not defined\\" throw
  if [[ \\"$definition\\" =~ $regex ]]
  then
    local variableType
    local primitiveType=\${BASH_REMATCH[1]}

    local objectTypeIndirect=\\"$variableName[__object_type]\\"
    if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
    then
      DEBUG Log \\"typeof $variableName: Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
      variableType=\\"\${!objectTypeIndirect}\\"
    else
      variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
      DEBUG Log \\"typeof $variableName: Primitive Type $primitiveType Resolved \${variableType}\\"
    fi

    if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
    then
      local dereferrencedVariableName=$(Variable::PrintDeclaration \\"$variableName\\" false)
      variableType=$(Type::GetTypeOfVariable \\"$dereferrencedVariableName\\")
    fi

    if [[ \\"$variableType\\" == 'string' ]]
    then
      local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
      if [[ ! -z \\"$extensionType\\" ]]
      then
        variableType=\\"$extensionType\\"
      fi
    fi

    DEBUG Log \\"Variable $variableName is typeof $variableType\\"

    echo \\"$variableType\\"
  fi
}

Type::IsPrimitive() {
  local type=\\"$1\\"

  case \\"$type\\" in
    'array'|'map'|'string'|'integer'|'boolean'|'integerArray'|'reference') ## TODO: reference should be resolved
      return 0 ;;
    * )
      return 1 ;;
  esac
}

## Returns a matching __primitive_extension_fingerprint__*
## Or nothing
Type::GetPrimitiveExtensionFromVariable() {
  local variableName=\\"$1\\"

  if [[ \\"\${!variableName}\\" != \\"$__primitive_extension_declaration\\"* ]]
  then
    return
  fi

  local prefix=__primitive_extension_fingerprint__
  local extensionType
  for extensionType in $(Variable::GetAllStartingWith $prefix)
  do
    local fingerprint=\${!extensionType}
    if [[ \\"\${!variableName}\\" == \\"$fingerprint\\"* ]]
    then
      extensionType=\${extensionType##$prefix}
      echo \\"$extensionType\\"
      return
    fi
  done
}

Type::GetPrimitiveExtensionFingerprint() {
  local type=\\"$1\\"

  local fingerprintVariable=\\"__primitive_extension_fingerprint__\${type}\\"
  printf \\"\${!fingerprintVariable}\\"
}

Type::CreateHandlerFunction() {
  local variableName=\\"$1\\"

  if [[ -z $variableName ]]
  then
    subject=WARN Log \\"No variable specified when trying to create a handle.\\"
    return
  fi

  ## don't allow creating a handler if a command/function/alias of such name already exists
  ## unless it is a handler already (keeps track)

  if ! Command::Exists \\"\${__oo__variableMethodPrefix}\${variableName}\\"
  then
    DEBUG Log \\"creating handler for $variableName\\"
    ## declare method with the name of the var ##
    eval \\"\${__oo__variableMethodPrefix}\${variableName}() { Type::Handle $variableName \\\\\\"\\\\$@\\\\\\"; }\\"
    __oo__type_handler_functions+=( \\"\${variableName}\\" )

  elif ! Array::Contains \\"\${variableName}\\" \\"\${__oo__type_handler_functions[@]}\\"
  then
    ## TODO: a way to solve this is to store the original functions
    ## and temporairly override it, returning back to the old formula in @return
    subject=WARN Log \\"Unable to create a handle for '$variableName'. A command of the same name already exists.\\"
  fi

  Type::RunFunctionGarbageCollector
}

Type::RunFunctionGarbageCollector() {
  local -a variables=( $(compgen -A 'variable' || true) )

  local index
  local handler
  for index in \\"\${!__oo__type_handler_functions[@]}\\"
  do
    handler=\\"\${__oo__type_handler_functions[$index]}\\"

    local exists=
    for variable in \\"\${variables[@]}\\"
    do
      # Log \\"comparing: \${variable} == $handler\\"
      [[ \\"$variable\\" == \\"$handler\\" ]] && { exists=1; break; }
    done
    ## unset all the functions that don't have corresponding variables
    if [[ ! -n $exists ]]
    then
      DEBUG Log \\"Unsetting handler for $handler\\"
      unset -f \\"\${__oo__variableMethodPrefix}\${handler}\\"
      unset __oo__type_handler_functions[$index]
    else
      DEBUG Log \\"not deleting: handler and variable exists: \${variable}\\"
    fi
  done
}

Type::InjectThisResolutionIfNeeded() {
  local methodName=\\"$1\\"

  local methodBody=$(declare -f \\"$methodName\\" || true)

  if [[ -z \\"$methodBody\\" ]]
  then
    e=\\"Method $methodName is not defined.\\" throw
    return
  fi

  if [[ \\"$methodBody\\" != *'@resolve:this'* && \\"$methodBody\\" != *'__local_return_self_and_result=false'* ]]
  then
    DEBUG Log \\"Injecting @this resolution to: $methodName\\"
    DEBUG [[ \\"$methodName\\" == \\"Human\\"* ]] && Log \\"$methodBody\\"

    if [[ \\"$methodBody\\" != *'@return'* ]]
    then
      Function::InjectCode \\"$methodName\\" '@resolve:this' '@return'
    else
      Function::InjectCode \\"$methodName\\" '@resolve:this'
    fi
  fi
}

Type::ConvertAllOfTypeToMethodsIfNeeded() {
  local type=\\"$1\\"

  local -a methods=( $(Function::GetAllStartingWith \\"\${type}.\\") )
  local method

  for method in \\"\${methods[@]}\\"
  do
    Type::InjectThisResolutionIfNeeded \\"$method\\"
  done
}

Type::InitializePrimitive() {
  local name=\\"$1\\"

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"
}

Type::TrapAndCreate() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift

  # Log \\"\${commandWithArgs[*]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* ]]
  then
    # set +x
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __typeCreate_next=true
    # Console::WriteStdErr \\"Will assign next one\\"
    # set +x
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"

  # TODO: make this better, otherwise edge case bug:
  if [[ \\"$varValue\\" == \\"$varName\\" ]]
  then
    # Log \\"equal $varName=$varValue\\"
    local varValue=\\"\\"
  fi

  if [[ ! -z $__typeCreate_varType ]]
  then

    local __primitive_extension_fingerprint__boolean=\${__primitive_extension_fingerprint__boolean:-2D6A822E36884C70843578D37E6773C4}
    # Console::WriteStdErr \\"SETTING $__typeCreate_varName = \\\\$$__typeCreate_paramNo\\"
    # Console::WriteStdErr --
    #Console::WriteStdErr $tempName

    DEBUG Log \\"creating: $__typeCreate_varName ($__typeCreate_varType) = $__typeCreate_varValue\\"

    if [[ -z \\"$__typeCreate_varValue\\" ]]
    then
      case \\"$__typeCreate_varType\\" in
        'array'|'map') eval \\"$__typeCreate_varName=()\\" ;;
        'string') eval \\"$__typeCreate_varName=''\\" ;;
        'integer') eval \\"$__typeCreate_varName=0\\" ;;
        'boolean') eval \\"$__typeCreate_varName=\${__primitive_extension_fingerprint__boolean}:false\\" ;;
        * )
        # Log \\"constructing: $__typeCreate_varName ($__typeCreate_varType) = $(__constructor_recursion=0 Type::Construct $__typeCreate_varType)\\"

          __constructor_recursion=0 Type::Construct \\"$__typeCreate_varType\\" \\"$__typeCreate_varName\\"

          DEBUG Log \\"constructed: $(@get $__typeCreate_varName)\\"
        ;;
      esac
    else
      case \\"$__typeCreate_varType\\" in
        'boolean')
          if [[ \\"\${__typeCreate_varValue}\\" != 'true' && \\"\${__typeCreate_varValue}\\" != 'false' ]]
          then
            __typeCreate_varValue='false'
          fi
          eval \\"$__typeCreate_varName=\\\\\\"\${__primitive_extension_fingerprint__boolean}:\${__typeCreate_varValue}\\\\\\"\\" ;;
      ## TODO: add case of setting value already with fingerprint
        *) ;;
      esac
    fi

    Type::CreateHandlerFunction \\"$__typeCreate_varName\\"

    ## IMPORTANT: TRAP won't work inside a TRAP, so such a constructor couldn't

    # case \\"$__typeCreate_varType\\" in
    #   'array'|'map'|'string'|'integer') ;;
    #   *)
    #     if Function::Exists \${__typeCreate_varType}.constructor
    #     then
    #       # __typeCreate_runConstructor=\${__typeCreate_varName}
    #       # Log __typeCreate_runConstructor $__typeCreate_runConstructor
    #       \${__typeCreate_varName} constructor
    #     fi
    #     # local return
    #     # Object.New $__typeCreate_varType $__typeCreate_varName
    #     # eval \\"$__typeCreate_varName=$return\\"
    #   ;;
    # esac

    # __oo__objects+=( $__typeCreate_varName )

    unset __typeCreate_varType
    unset __typeCreate_varValue
  fi

  if [[ \\"$command\\" != \\"declare\\" || \\"$__typeCreate_next\\" != \\"true\\" ]]
  then
    __typeCreate_normalCodeStarted+=1

  # Console::WriteStdErr \\"NOPASS \${commandWithArgs[*]}\\"
  # Console::WriteStdErr \\"normal code count ($__typeCreate_normalCodeStarted)\\"
  # Console::WriteStdErr --
  else
    unset __typeCreate_next

    __typeCreate_normalCodeStarted=0
    __typeCreate_varName=\\"$varName\\"
    __typeCreate_varValue=\\"$varValue\\"
    __typeCreate_varType=\\"$__capture_type\\"
    __typeCreate_arrLength=\\"$__capture_arrLength\\"

    # Console::WriteStdErr \\"PASS \${commandWithArgs[*]}\\"
    # Console::WriteStdErr --

    __typeCreate_paramNo+=1
  fi
  # set +x
}

Type::CaptureParams() {
    # Console::WriteStdErr \\"Capturing Type $_type\\"
    # Console::WriteStdErr --

    __capture_type=\\"$_type\\"
}

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Type::TrapAssign='Type::CaptureParams; declare -i __typeCreate_normalCodeStarted=0; trap \\"declare -i __typeCreate_paramNo; Type::TrapAndCreate \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__typeCreate_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __typeCreate_varType __typeCreate_varName __typeCreate_varValue __typeCreate_paramNo\\" DEBUG; true; true; '
alias reference='_type=reference Type::TrapAssign declare -n'
alias string='_type=string Type::TrapAssign declare'
alias boolean='_type=boolean Type::TrapAssign declare'
alias integer='_type=integer Type::TrapAssign declare -i'
alias array='_type=array Type::TrapAssign declare -a'
alias integerArray='_type=integerArray Type::TrapAssign declare -ai'
alias map='_type=map Type::TrapAssign declare -A'
#alias global:reference='_type=reference Type::TrapAssign declare -ng'
#alias global:string='_type=string Type::TrapAssign declare -g'
#alias global:integer='_type=integer Type::TrapAssign declare -ig'
#alias global:array='_type=array Type::TrapAssign declare -ag'
#alias global:map='_type=map Type::TrapAssign declare -Ag'

##############################

# for use in the object's methods
this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:() {
  Type::Handle \\"$@\\"
  # Type::Handle $1 \\"\${@:2}\\"
}

@return() {
  local variableName=\\"$1\\"
  local thisName=\\"\${2:-this}\\"

  local __return_declaration
  local __return_declaration_type

  ## if not returning anything, just update the self
  if [[ ! -z \\"$variableName\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $variableName __return_declaration
  elif [[ ! -z \\"\${monad+x}\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $thisName __return_declaration
  fi

  if [[ \\"\${__local_return_self_and_result}\\" == \\"true\\" || \\"\${__return_self_and_result}\\" == \\"true\\" ]]
  then
    # Log \\"returning heavy\\"
    local -a __return=(\\"$(Variable::PrintDeclaration $thisName)\\" \\"$__return_declaration\\" \\"$__return_declaration_type\\")

    printf \${__return_separator:-52A586A48E074BB6812DCFDC790841F5}
    Variable::PrintDeclaration __return
    # __modifiedThis=\\"$(Variable::PrintDeclaration this)\\"
  elif [[ \\"\${#__return_declaration}\\" -gt 0 ]]
  then
    echo \\"$__return_declaration\\"
  fi

  Type::RunFunctionGarbageCollector
}

@return:value() {
  local value=\\"$@\\"
  @return value
}

# ------------------------ #
# STACK HANDLING #
# ------------------------ #

Type::ExecuteMethod() {
  local type=\\"$1\\"
  local variableName=\\"$2\\"
  local method=\\"$3\\"

  shift; shift; shift;

  Type::InjectThisResolutionIfNeeded \\"$type.$method\\"

  thisReference=$variableName thisReferenceType=\\"$type\\" $type.$method \\"$@\\"
}

# /**
#  * used inside Type::Handle() for getting out the return value and updating this
#  */
Type::RunCurrentStack() {
  DEBUG Log \\"will execute: $method (\${params[@]})\\"

  if [[ ! -z \\"$returnValueDefinition\\" && \\"$affectTheInitialVariable\\" == 'false' ]]
  then
    local -$(Variable::GetDeclarationFlagFromType $returnValueType) \\"__self=$returnValueDefinition\\"
    variableName=__self
  fi

  # Log \\"Will assign: result=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\")\\"
  local resultString=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\" || { local falseBool=\\"\${__primitive_extension_fingerprint__boolean}:false\\"; __return_self_and_result=true @return falseBool $variableName; })
  # || echo \\"\${__return_separator}specialBool:\${__primitive_extension_fingerprint__boolean}:false\\"

  ## TODO: some problem here sometimes
  DEBUG Log \\"Result string: START | $resultString | END\\"

  local echoed=

  if [[ -z \\"$resultString\\" || \\"$resultString\\" != *\\"$__return_separator\\"* ]]
  then
    ## if resultString does not contain return_separator, use all as returnString and nothing as echo
    ## TODO: debug these situations if all ok.
    # theoretically, this is when no @return is present
    # or when no return separator provided - we use the echoed output as the result
    #
    ## implicit \\"string\\"
    local -a result=( \\"$(@get $variableName)\\" \\"$(@get resultString)\\" \\"string\\" )
  else
    # echo everything before the first occurrence of the separator
    echoed=\\"\${resultString%%$__return_separator*}\\"

    DEBUG [[ ! -z \\"$echoed\\" ]] && Log \\"Echoed: START | $(@get echoed) | END\\"

    # the result is everything after the first occurrence of the separator
    resultString=\\"\${resultString#*$__return_separator}\\"

    # Log \\"resultString: $resultString\\"
    local -a result=$resultString
    # eval \\"local -a result=$resultString\\"
  fi

  unset __self

  # declare -p result
  local assignResult=\\"\${result[0]}\\"

  DEBUG Log \\"Assign Result:\\"
  DEBUG Log \\"START $assignResult END\\"
  # declare -p assignResult

  local typeParam=$(Variable::GetDeclarationFlagFromType $type)

  DEBUG Log \\"Will eval: | $variableName=$assignResult |\\"
  # [[ \\"\${assignResult}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1

  if [[ \\"$typeParam\\" =~ [aA] ]]
  then
    # update the object
    eval \\"$variableName=$assignResult\\"
  else
    ## TODO: use the primitive extension fingerprint here, not in the methods themselves
    # assignResult=\\"$(Type::GetPrimitiveExtensionFingerprint $type):$assignResult\\"
    eval \\"$variableName=\\\\\\"\\\\$assignResult\\\\\\"\\"
  fi

  # update the result
  returnValueDefinition=\\"\${result[1]}\\"
  returnValueType=\\"\${result[2]}\\"

  # Log \\"returned: $returnValueType: $returnValueDefinition\\"

  # switch context for the next command
  if [[ \\"$assignResult\\" != \\"\${returnValueDefinition}\\" ]]
  then
    affectTheInitialVariable=false
    type=\\"$returnValueType\\" # $(Variable::GetPrimitiveTypeFromDeclarationFlag $returnValueType)
  fi

  printf %s \\"$echoed\\"

  ## cleanup vars:
  method=''
  params=()

  # TODO: this should work directly but doesn't
  # eval $variableName=\\\\$assignResult
}

Type::RunGetter() {
  local variableName=\\"$1\\"
  local type=\\"$2\\"

  if Function::Exists \\"$type.__getter__\\"
  then
    __return_self_and_result=false Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"__getter__\\"
  else
    @get \\"$variableName\\"
  fi
}

## TODO: private handling should be reimplemented - only this() should be able to access private entries
Type::Handle() {
  local variableName=\\"$1\\"
  local type=$(Type::GetTypeOfVariable \\"\${variableName}\\")
  local affectTheInitialVariable=true
  local -a propertyTree=(\\"$1\\")

  if [[ \\"$type\\" == \\"undefined\\" ]]
  then
    e=\\"No variable named: $variableName\\" throw
    return
  fi

  shift

  local returnValueDefinition
  local returnValueType

  local currentPropertyVisibility=public

  local multiExpression=false

  if [[ \\"$1\\" == ':' ]]
  then
    multiExpression=true
    shift
  fi

  DEBUG subject=\\"type handling\\" Log \\"START ANALYZING: type: $type | variable: $variableName $@\\"
  DEBUG subject=\\"type handling\\" Log \\"WHAT: $(declare -p $variableName)\\"

  # Log multiExpression $multiExpression

  if [[ $# -gt 0 ]]
  then
    local method
    local -a params
    local mode=method
    local prevMode
    local prevModeNext
    local bracketsStarted=false
    local -i closingBracketCount=0

    while [[ $# -gt 0 ]]
    do
      if [[ \\"$__access_private\\" != \\"true\\" && \\"$currentPropertyVisibility\\" == \\"private\\" ]]
      then
        e=\\"Trying to access a private property: $method\\" throw
        return
      fi

      prevModeNext=$mode

      if [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '{' ]]
      then
        if [[ $bracketsStarted == 'true' ]]
        then
          ## handle edge case of '}' as actual parameter
          while (( closingBracketCount+=-1 ))
          do
            params+=( '}' )
          done

          Type::RunCurrentStack
        fi
        bracketsStarted=true
        # mode=params
      elif [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '}' ]]
      then
        closingBracketCount+=1
        mode=method
        prevModeNext=params
      elif [[ \\"$mode\\" == 'params' ]]
      then
        params+=(\\"$1\\")
      elif [[ \\"$mode\\" == 'method' ]]
      then
        # Log $(@get __\${type}_property_names | array.indexOf $1) $1 idx
        # Log $(@get __\${type}_property_names | array.contains $1 && echo t)

        # Log index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${1})

        local typeSanitized=$(String::SanitizeForVariableName \${type})
        # local typeSanitized=\\"\${type//[^a-zA-Z0-9]/_}\\"

        if Variable::Exists __\${typeSanitized}_property_names &&
            @get __\${typeSanitized}_property_names | __return_self_and_result=false array.contains $1
        then
          # stack now belongs to selected property:
          local property=\\"$1\\"

          DEBUG Log found index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${property})
          # Log prop: $property of [$(@get __\${type}_property_names)]

          ## TODO: theoretically, we could get rid of: __return_self_and_result=false
          local -i index=$(@get __\${typeSanitized}_property_names | __return_self_and_result=false array.indexOf \${property})

          if [[ $index -ge 0 ]]
          then
            DEBUG Log \\"traversing to a child property $property of type $type\\"

            local newType=__\${typeSanitized}_property_types[$index]
            type=\${!newType}
            local typeParam=$(Variable::GetDeclarationFlagFromType $type)

            local currentPropertyVisibilityIndirect=__\${typeSanitized}_property_visibilities[$index]
            currentPropertyVisibility=\${!currentPropertyVisibilityIndirect}

            local propertyValueIndirect=$variableName[$property]

            if [[ -z \\"\${!propertyValueIndirect}\\" && \\"$typeParam\\" =~ [aA] ]]
            then
              local -$typeParam \\"__$property=()\\"
            else
              ## TODO: check if this preserves spaces correctly
              local -$typeParam \\"__$property=\${!propertyValueIndirect}\\"

              if ! Type::IsPrimitive \\"$type\\"
              then
                eval \\"__$property[__object_type]=\\\\\\"\\\\$type\\\\\\"\\"
              fi
            fi

            DEBUG Log \\".$property new $type value is: \\" # \${propertyValueIndirect} vs '\${!propertyValueIndirect}'
            DEBUG Log \\"$(declare -p __$property)\\"
            # affectTheInitialVariable=false

            ## TODO: variableName needs to be unique (add count at the end)
            ## in case the same property is nested
            variableName=__$property

            propertyTree+=(\\"$property\\")

            prevModeNext=property
          fi
          ### /selectProperty
        else
          mode=params
          method=\\"$1\\"
        fi
      fi
      prevMode=$prevModeNext

      DEBUG subject=\\"type handling\\" Log \\"iter: $1 | prevMode: $prevMode | mode: $mode | type: $type | variable: $variableName | method: $method | #params: \${#params[@]}\\"

      shift
    done

    if [[ \\"\${#method}\\" -gt 0 ]]
    then
      # Log 'running stack for:' $variableName
      Type::RunCurrentStack
      # Log 'output was:' \\"\${!variableName}\\"
      ## TODO: this does not work: (false boolean should return fail)
      [[ \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1 # && Log \\"LALALALA\\"
    elif [[ \\"$prevMode\\" == 'property' ]]
    then
      if [[ \\"$currentPropertyVisibility\\" == 'public' || \\"$__access_private\\" == \\"true\\" ]]
      then
        DEBUG subject='property' Log 'print out the property' $variableName
        ## print out the property or run the getter
        Type::RunGetter $variableName $type
      else
        e=\\"Property is private\\" throw
      fi
    fi

    ## TODO: shouldn't this be an elif ?
    # finally echo the latest return value if not empty
    if [[ ! -z \\"$returnValueDefinition\\" ]]
    then
      echo \\"$returnValueDefinition\\"
    fi

    ## UPDATE THE OBJECT RECURSIVELY:
    local -i propertyTreeLength=\${#propertyTree[@]}
    if [[ \${#propertyTree[@]} -gt 1 ]]
    then
      # Log PropertyTree: $(@get propertyTree)
      local -a reversedPropertyTree=$(@get propertyTree | __return_self_and_result=false array.reverse)

      local -i i=$propertyTreeLength
      local property
      local parent
      for parent in \\"\${reversedPropertyTree[@]}\\"
      do
        ## recursively insert the children into parents

        i+=-1
        (( $i == $propertyTreeLength - 1 )) && property=$parent && continue

        local parentVarName=__$parent

        (( $i == 0 )) && parentVarName=$parent

        local propertyDefinition=\\"$(@get __$property)\\"
        # Log \\"Will eval: $parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"
        eval \\"$parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"

        DEBUG Log \\"SETTING: ($i) $parentVarName.$property = \\\\\\"$propertyDefinition\\\\\\"\\"

        property=$parent
      done
    fi
  else
    #@get $variableName
    Type::RunGetter $variableName $type
  fi
}

## TODO: take note of what variables have handler functions in a global variable
## in @resolve:this save the list and then compare it in a @return
## -- or better yet -- to it in the parent that executes the method
## before and after execution

## question - how to add @resolve:this to all methods without explicitly stating it?

## \\"garbage collect\\", i.e. remove all the new references so they don't pollute the global scope

## note: declaration needs to be trimmed,
## since bash adds an enter at the end, hence %?
alias @resolve:this=\\"
  local __local_return_self_and_result=false
  [[ \\\\$__return_self_and_result == 'true' ]] && local __local_return_self_and_result=true && local __return_self_and_result=false
  # TODO: local __access_private_members_of=
  if [[ -z \\\\\${__use_this_transparently+x} ]];
  then
    local __declaration;
    local __declaration_type;

    if [[ ! -z \\\\\\"\\\\\${useReturnValueDefinition}\\\\\\" ]];
    then
      # subject='@resolve:this' Log 'using: ReturnValueDefinition'
      __declaration=\\\\\\"\\\\$returnValueDefinition\\\\\\"
      __declaration_type=\\\\$returnValueType
    elif [[ -z \\\\\${thisReference+x} && ! -t 0 ]];
    then
      # subject='@resolve:this' Log 'using: pipe'
      Pipe::Capture __declaration;
      __declaration_type=\\\\\${FUNCNAME[0]%.*}
      DEBUG Log capturing via pipe \\\\\${__declaration_type}
    else
      # subject='@resolve:this' Log 'using: thisReference:' $ \\\\$thisReference type: \\\\$thisReferenceType
      Variable::ExportDeclarationAndTypeToVariables \\\\$thisReference __declaration;
      __declaration_type=\\\\\\"\\\\$thisReferenceType\\\\\\"
      unset thisReference;
    fi;

    local typeParam=\\\\$(Variable::GetDeclarationFlagFromType \\\\\\"\\\\\${__declaration_type}\\\\\\" '-');
    # subject='@resolve:this' Log \\\\$__declaration_type = \\\\$typeParam = \\\\$__declaration

    # TODO: does it preserve spaces properly?
    local -\\\\$typeParam this=\\\\\${__declaration};

    ## add type for objects that don't have them set explicitly
    if [[ \\\\$typeParam == 'A' && \\\\$__declaration_type != 'map' && -z \\\\\${this[__object_type]+x} ]]
    then
      # Log setting object type
      this[__object_type]=\\\\\\"\\\\$__declaration_type\\\\\\"
    fi

    unset __declaration;
    unset __declaration_type;
  fi
  \\"

# ------------------------ #

import TypePrimitives
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/variable.sh 1`] = `
"import util/command
namespace util/variable

declare __declaration_type ## for Variable::ExportDeclarationAndTypeToVariables (?)

Variable::Exists() {
  local variableName=\\"$1\\"
  declare -p \\"$variableName\\" &> /dev/null
}

Variable::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'variable' \\"$startsWith\\" || true
}

Variable::GetDeclarationFlagFromType() {
  DEBUG subject=\\"GetParamFromType\\" Log 'getting param from type' \\"$@\\"

  local typeInfo=\\"$1\\"
  local fallback=\\"$2\\"

  if [[ \\"$typeInfo\\" == \\"map\\" ]] || Function::Exists \\"class:\${typeInfo}\\"
  then
    echo A
  else
    case \\"$typeInfo\\" in
      \\"reference\\")
        echo n
      ;;
      \\"array\\")
        echo a
      ;;
      \\"string\\" | \\"boolean\\")
        echo -
      ;;
      \\"integer\\")
        echo i
      ;;
      \\"integerArray\\")
        echo ai
      ;;
      *)
        echo \\"\${fallback:-A}\\"
      ;;
    esac
  fi
}

Variable::GetPrimitiveTypeFromDeclarationFlag() {
  local typeInfo=\\"$1\\"

  case \\"$typeInfo\\" in
    \\"n\\"*)
      echo reference
    ;;
    \\"a\\"*)
      echo array
    ;;
    \\"A\\"*)
      echo map
    ;;
    \\"i\\"*)
      echo integer
    ;;
    \\"ai\\"*)
      echo integerArray
    ;;
    \\"Ai\\"*)
      echo integerMap
    ;;
    *)
      echo string
    ;;
  esac
}

Variable::ExportDeclarationAndTypeToVariables() {
  local variableName=\\"$1\\"
  local targetVariable=\\"$2\\"
  local dereferrence=\\"\${3:-true}\\"

  # TODO: rename for a safer, less common variablename so parents can output to declaration
  local declaration
  local regexArray=\\"declare -([a-zA-Z-]+) $variableName='(.*)'\\"
  local regex=\\"declare -([a-zA-Z-]+) $variableName=\\\\\\"(.*)\\\\\\"\\"
  local regexArrayBash4_4=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p $variableName 2> /dev/null || true)

  local escaped=\\"'\\\\\\\\\\\\'\\"
  local escapedQuotes='\\\\\\\\\\"'
  local singleQuote='\\"'

  local doubleSlashes='\\\\\\\\\\\\\\\\'
  local singleSlash='\\\\'

  [[ -z \\"$definition\\" ]] && e=\\"Variable $variableName not defined\\" throw

  if [[ \\"$definition\\" =~ $regexArray ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\"
  elif [[ \\"$definition\\" =~ $regex ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\" ## TODO: is this transformation needed?
    declaration=\\"\${declaration//$escapedQuotes/$singleQuote}\\"
    declaration=\\"\${declaration//$doubleSlashes/$singleSlash}\\"
  elif [[ \\"$definition\\" =~ $regexArrayBash4_4 ]]
  then
    declaration=\\"\${BASH_REMATCH[2]}\\"
  fi

  local variableType

  DEBUG Log \\"Variable Is $variableName = $definition ==== \${BASH_REMATCH[1]}\\"

  local primitiveType=\${BASH_REMATCH[1]}

  local objectTypeIndirect=\\"$variableName[__object_type]\\"
  if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
  then
    DEBUG Log \\"Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
    variableType=\\"\${!objectTypeIndirect}\\"
  # elif [[ ! -z \${__primitive_extension_fingerprint__boolean+x} && \\"$primitiveType\\" == '-' && \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}\\"* ]]
  # then
  #   variableType=\\"boolean\\"
  else
    variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
    DEBUG Log \\"Primitive Type $primitiveType Resolved \${variableType}\\"
  fi

  if [[ \\"$variableType\\" == 'string' ]] && Function::Exists 'Type::GetPrimitiveExtensionFromVariable'
  then
    local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
    if [[ ! -z \\"$extensionType\\" ]]
    then
      variableType=\\"$extensionType\\"
    fi
  fi

  DEBUG Log \\"Variable $variableName is typeof $variableType\\"

  if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
  then
    local dereferrencedVariableName=\\"$declaration\\"
    Variable::ExportDeclarationAndTypeToVariables \\"$dereferrencedVariableName\\" \\"$targetVariable\\" \\"$dereferrence\\"
  else
    eval \\"$targetVariable=\\\\\\"\\\\$declaration\\\\\\"\\"
    eval \\"\${targetVariable}_type=\\\\$variableType\\"
  fi
}

Variable::PrintDeclaration() {
  local variableName=\\"\${1}\\"
  local dereferrence=\\"\${2:-true}\\"

  local __declaration
  local __declaration_type
  Variable::ExportDeclarationAndTypeToVariables \\"$variableName\\" __declaration \\"$dereferrence\\"
  echo \\"$__declaration\\"
}

alias @get='Variable::PrintDeclaration'
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-config/.gitignore 1`] = `
"/config
/crypto-config
"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-config/configtx.yaml 1`] = `
"################################################################################
#   SECTION: Capabilities
################################################################################
Capabilities:
    Channel: &ChannelCapabilities
        V1_4_3: true
    Orderer: &OrdererCapabilities
        V1_4_2: true
    Application: &ApplicationCapabilities
        V1_4_2: true

################################################################################
#   CHANNEL Defaults
################################################################################
Channel: &ChannelDefaults
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: \\"ANY Readers\\"
        Writers:
            Type: ImplicitMeta
            Rule: \\"ANY Writers\\"
        Admins:
            Type: ImplicitMeta
            Rule: \\"MAJORITY Admins\\"
    Capabilities:
        <<: *ChannelCapabilities

################################################################################
#   Section: Organizations
################################################################################
Organizations:
    - &OrdererOrg
        Name: Orderer
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/root.com/msp 
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.com/msp
        AnchorPeers:
            - Host: peer0.org1.com
              Port: 7051

################################################################################
#   SECTION: Application
################################################################################
Application: &ApplicationDefaults
    Organizations:
    Capabilities:
        <<: *ApplicationCapabilities

################################################################################
#   SECTION: Orderer
################################################################################
Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses: 
        - orderer0.root.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Organizations:

################################################################################
#   Profile
################################################################################
# https://github:com/hyperledger/fabric/blob/master/sampleconfig/configtx.yaml

Profiles:
    SoloOrdererGenesis:
        <<: *ChannelDefaults
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations: 
                    - *Org1
    AllOrgChannel:
        <<: *ChannelDefaults
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations: 
                - *Org1
            Capabilities:
                <<: *ApplicationCapabilities

"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-config/crypto-config-org1.yaml 1`] = `
"PeerOrgs:
  - Name: Org1
    Domain: org1.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabric-config/crypto-config-root.yaml 1`] = `
"OrdererOrgs:
  - Name: Orderer
    Domain: root.com
    Specs: 
      - Hostname: orderer0
    "
`;

exports[`e2e/__tmp__/sample-03 should create proper e2e/__tmp__/sample-03/fabrikkaConfig-1org-1channel-1chaincode-tls.json 1`] = `
"{
  \\"fabrikkaVersion\\": \\"alpha-0.0.1\\",
  \\"fileVersion\\": \\"0.1\\",
  \\"networkSettings\\": {
    \\"fabricVersion\\": \\"1.4.3\\",
    \\"tls\\": true
  },
  \\"rootOrg\\": {
    \\"organization\\": {
      \\"key\\": \\"root\\",
      \\"name\\": \\"Orderer\\",
      \\"mspName\\": \\"OrdererMSP\\",
      \\"domain\\": \\"root.com\\"
    },
    \\"ca\\": {
      \\"prefix\\": \\"ca\\"
    },
    \\"orderer\\": {
      \\"prefix\\": \\"orderer\\",
      \\"consensus\\": \\"solo\\",
      \\"instances\\": 1
    }
  },
  \\"orgs\\": [
    {
      \\"organization\\": {
        \\"key\\": \\"org1\\",
        \\"name\\": \\"Org1\\",
        \\"mspName\\": \\"Org1MSP\\",
        \\"domain\\": \\"org1.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    }
  ],
  \\"channels\\": [
    {
      \\"key\\": \\"channel1\\",
      \\"name\\": \\"my-channel1\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer0\\",
            \\"peer1\\"
          ]
        }
      ]
    }
  ],
  \\"chaincodes\\": [
    {
      \\"name\\": \\"chaincode1\\",
      \\"version\\": \\"0.0.1\\",
      \\"lang\\": \\"java\\",
      \\"channel\\": \\"channel1\\",
      \\"init\\": \\"{'Args':[]}\\",
      \\"endorsement\\": \\"AND ('Org1.member')\\",
      \\"directory\\": \\"chaincode1\\"
    }
  ]
}
"
`;

exports[`e2e/__tmp__/sample-03 should create proper files 1`] = `
Array [
  "e2e/__tmp__/sample-03/fabric-compose.sh",
  "e2e/__tmp__/sample-03/fabric-compose/.env",
  "e2e/__tmp__/sample-03/fabric-compose/commands-generated.sh",
  "e2e/__tmp__/sample-03/fabric-compose/docker-compose.yaml",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/base-functions.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/base-help.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/cli/channel_fns.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Contains.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Intersect.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/List.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/Array/Reverse.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/GetSpaces.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/IsNumber.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/SanitizeForVariable.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/SlashReplacement.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/String/UUID.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Color.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Color.var.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Console.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/UI/Cursor.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/oo-bootstrap.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/bash4.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/class.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/command.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/exception.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/exits.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/log.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/namedParameters.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/pipe.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/test.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/tryCatch.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/type.sh",
  "e2e/__tmp__/sample-03/fabric-compose/scripts/lib/util/variable.sh",
  "e2e/__tmp__/sample-03/fabric-config/.gitignore",
  "e2e/__tmp__/sample-03/fabric-config/configtx.yaml",
  "e2e/__tmp__/sample-03/fabric-config/crypto-config-org1.yaml",
  "e2e/__tmp__/sample-03/fabric-config/crypto-config-root.yaml",
  "e2e/__tmp__/sample-03/fabrikkaConfig-1org-1channel-1chaincode-tls.json",
]
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose.sh 1`] = `
"#!/bin/bash
SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

source \\"$BASEDIR\\"/fabric-compose/scripts/lib/oo-bootstrap.sh

source \\"$BASEDIR\\"/fabric-compose/scripts/base-help.sh
source \\"$BASEDIR\\"/fabric-compose/scripts/base-functions.sh
source \\"$BASEDIR\\"/fabric-compose/commands-generated.sh

source \\"$BASEDIR\\"/fabric-compose/.env

if [ \\"$1\\" = \\"up\\" ]; then
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"recreate\\" ]; then
  networkDown
  generateArtifacts
  startNetwork
  generateChannelsArtifacts
  installChannels
  installChaincodes
  printHeadline \\"Done! Enjoy your fresh network\\" \\"U1F984\\"
elif [ \\"$1\\" = \\"down\\" ]; then
  networkDown
elif [ \\"$1\\" = \\"start\\" ]; then
  startNetwork
elif [ \\"$1\\" = \\"stop\\" ]; then
  stopNetwork
elif [ \\"$1\\" = \\"chaincodes\\" ] && [ \\"$2\\" = \\"install\\" ]; then
  installChaincodes
elif [ \\"$1\\" = \\"help\\" ]; then
  printHelp
elif [ \\"$1\\" = \\"--help\\" ]; then
  printHelp
else
  echo \\"No command specified\\"
  echo \\"Basic commands are: up, down, start, stop, recreate\\"
  echo \\"Also check: 'chaincodes install'\\"
  echo \\"Use 'help' or '--help' for more information\\"
fi
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/.env 1`] = `
"COMPOSE_PROJECT_NAME=network
FABRIC_VERSION=1.4.3
LOGGING_LEVEL=info

ROOT_CA_ADMIN_NAME=admin
ROOT_CA_ADMIN_PASSWORD=adminpw

ORG1_CA_ADMIN_NAME=admin
ORG1_CA_ADMIN_PASSWORD=adminpw

ORG2_CA_ADMIN_NAME=admin
ORG2_CA_ADMIN_PASSWORD=adminpw

"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/commands-generated.sh 1`] = `
"SCRIPT=$(readlink -f \\"$0\\")
BASEDIR=$(dirname \\"$SCRIPT\\")

function installChaincodes() {
  
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F60E\\"
    chaincodeInstallTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org1/peer0\\" \\"U1F618\\"
    chaincodeInstantiateTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org1.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org1.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
    
  printHeadline \\"Installing 'chaincode1' on my-channel1/Org2/peer0\\" \\"U1F60E\\"
    chaincodeInstallTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org2.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org2.com\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
  
  printItalics \\"Instantiating 'chaincode1' on my-channel1/Org2/peer0\\" \\"U1F618\\"
    chaincodeInstantiateTls \\"$BASEDIR/chaincode1\\" \\"chaincode1\\" \\"0.0.1\\" \\"java\\" \\"my-channel1\\" \\"peer0.org2.com:7051\\" \\"orderer0.root.com:7050\\" \\"cli.org2.com\\" '{'Args':[]}' \\"AND ('Org1.member')\\" \\"crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem\\"
    
}

function generateArtifacts() {
  printHeadline \\"Generating basic configs\\" \\"U1F913\\"
  printItalics \\"Generating crypto material for org Orderer\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-root.yaml\\" \\"ordererOrganizations/root.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org1\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org1.yaml\\" \\"peerOrganizations/org1.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating crypto material for Org2\\" \\"U1F512\\"
  certsGenerate \\"$BASEDIR/fabric-config\\" \\"crypto-config-org2.yaml\\" \\"peerOrganizations/org2.com\\" \\"$BASEDIR/fabric-config/crypto-config/\\"
  
  printItalics \\"Generating genesis block\\" \\"U1F3E0\\"
  genesisBlockCreate \\"$BASEDIR/fabric-config\\" \\"$BASEDIR/fabric-config/config\\"
}

function startNetwork() {
  printHeadline \\"Starting network\\" \\"U1F680\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose up -d
  cd $CURRENT_DIR
  sleep 4
}

function stopNetwork() {
  printHeadline \\"Stopping network\\" \\"U1F68F\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose stop
  cd $CURRENT_DIR
  sleep 4
}

function generateChannelsArtifacts() {
    printHeadline \\"Generating config for 'my-channel1'\\" \\"U1F913\\"
  createChannelTx \\"my-channel1\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
    printHeadline \\"Generating config for 'my-channel2'\\" \\"U1F913\\"
  createChannelTx \\"my-channel2\\" \\"$BASEDIR/fabric-config\\" \\"AllOrgChannel\\" \\"$BASEDIR/fabric-config/config\\"
  }

function installChannels() {
  
    
    printHeadline \\"Creating 'my-channel1' on Org1/peer0\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoinTls 'my-channel1' 'Org1MSP' 'peer0.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'crypto/users/Admin@org1.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
        
    printItalics \\"Joining 'my-channel1' on  Org2/peer0\\" \\"U1F638\\"
    docker exec -i cli.org2.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoinTls 'my-channel1' 'Org2MSP' 'peer0.org2.com:7051' 'crypto/users/Admin@org2.com/msp' 'crypto/users/Admin@org2.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
        
    
    printHeadline \\"Creating 'my-channel2' on Org1/peer1\\" \\"U1F63B\\"
    docker exec -i cli.org1.com bash -c \\\\
    \\"source scripts/channel_fns.sh; createChannelAndJoinTls 'my-channel2' 'Org1MSP' 'peer1.org1.com:7051' 'crypto/users/Admin@org1.com/msp' 'crypto/users/Admin@org1.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
        
    printItalics \\"Joining 'my-channel2' on  Org2/peer1\\" \\"U1F638\\"
    docker exec -i cli.org2.com bash -c \\\\
    \\"source scripts/channel_fns.sh; fetchChannelAndJoinTls 'my-channel2' 'Org2MSP' 'peer1.org2.com:7051' 'crypto/users/Admin@org2.com/msp' 'crypto/users/Admin@org2.com/tls' 'crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem' 'orderer0.root.com:7050';\\"
  
        }

function networkDown() {
  printHeadline \\"Destroying network\\" \\"U1F916\\"
  CURRENT_DIR=$(pwd)
  cd \\"$BASEDIR\\"/fabric-compose
  docker-compose down
  cd $CURRENT_DIR

  printf \\"\\\\nRemoving chaincode containers & images... \\\\U1F5D1 \\\\n\\"
   
  docker rm -f $(docker ps -a | grep dev-peer0.org1.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org1.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  docker rm -f $(docker ps -a | grep dev-peer0.org2.com-chaincode1-0.0.1-* | awk '{print $1}') || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  docker rmi $(docker images dev-peer0.org2.com-chaincode1-0.0.1-* -q) || {
    echo \\"docker rm failed, Check if all fabric dockers properly was deleted\\"
  }
  
  printf \\"\\\\nRemoving generated configs... \\\\U1F5D1 \\\\n\\"
  rm -rf $BASEDIR/fabric-config/config
  rm -rf $BASEDIR/fabric-config/crypto-config

  printHeadline \\"Done! Network was purged\\" \\"U1F5D1\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/docker-compose.yaml 1`] = `
"version: '2.2'

networks:
  basic:

services:
  
  ca.root.com:
    container_name: ca.root.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.root.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.root.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7030:7054
    command: sh -c 'fabric-ca-server start -b \${ROOT_CA_ADMIN_NAME}:\${ROOT_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  orderer0.root.com:
    container_name: orderer0.root.com
    image: hyperledger/fabric-orderer:\${FABRIC_VERSION}
    environment:
      - ORDERER_GENERAL_LOGLEVEL=\${LOGGING_LEVEL}
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/config/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      - GODEBUG=netdns=go
            #enabled TLS
      - ORDERER_GENERAL_TLS_ENABLED=true
      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
    working_dir: /var/hyperledger/orderer
    command: orderer
    ports:
      - 7040:7050
    volumes:
      - ../fabric-config/config/:/var/hyperledger/config
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/msp/:/var/hyperledger/orderer/msp
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/tls/:/var/hyperledger/orderer/tls
    networks:
      - basic
    
  
  ca.org1.com:
    container_name: ca.org1.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org1.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7031:7054
    command: sh -c 'fabric-ca-server start -b \${ORG1_CA_ADMIN_NAME}:\${ORG1_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org1.com:
    container_name: cli.org1.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org1.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org1.com/msp
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/client.crt
      - CORE_PEER_TLS_KEY_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/client.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org1.com/tls/ca.crt
      - TLS_CA_CERT_PATH=:/var/hyperledger/cli/crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org1.com:
    container_name: peer0.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer0.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7051:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer0.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org1.com:
    container_name: peer1.org1.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org1.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_ADDRESS=peer1.org1.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7052:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/peers/peer1.org1.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org1.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
  
  ca.org2.com:
    container_name: ca.org2.com
    image: hyperledger/fabric-ca:\${FABRIC_VERSION}
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.org2.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org2.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/priv-key.pem
    ports:
      - 7032:7054
    command: sh -c 'fabric-ca-server start -b \${ORG2_CA_ADMIN_NAME}:\${ORG2_CA_ADMIN_PASSWORD} -d'
    volumes:
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/ca/:/etc/hyperledger/fabric-ca-server-config
    networks:
      - basic
  
  cli.org2.com:
    container_name: cli.org2.com
    image: hyperledger/fabric-tools:\${FABRIC_VERSION}
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - FABRIC_LOGGING_SPEC=\${LOGGING_LEVEL}
      - CORE_PEER_ID=cli.org2.com
      - CORE_CHAINCODE_KEEPALIVE=10
      #
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_MSPCONFIGPATH=/var/hyperledger/cli/crypto/users/Admin@org2.com/msp
      - CORE_PEER_ADDRESS=peer0.org2.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org2.com/tls/client.crt
      - CORE_PEER_TLS_KEY_FILE=/var/hyperledger/cli/crypto/users/Admin@org2.com/tls/client.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/cli/crypto/users/Admin@org2.com/tls/ca.crt
      - TLS_CA_CERT_PATH=:/var/hyperledger/cli/crypto/daTls/msp/tlscacerts/tlsca.root.com-cert.pem
    working_dir: /var/hyperledger/cli/
    command: /bin/bash
    volumes:
      - /var/run/:/host/var/run/
      - ./scripts/cli:/var/hyperledger/cli/scripts/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com:/var/hyperledger/cli/crypto/
      - ../fabric-config/config:/var/hyperledger/cli/config/ # genesis.block and channel.tx's
      - ../fabric-config/crypto-config/ordererOrganizations/root.com/orderers/orderer0.root.com/:/var/hyperledger/cli/crypto/daTls # TODO ! To ease up deployment, not proper. 
      - ../chaincode1/:/var/hyperledger/cli/chaincode1/
    networks:
      - basic
  
  peer0.org2.com:
    container_name: peer0.org2.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org2.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_ADDRESS=peer0.org2.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7061:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer0.org2.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer0.org2.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  peer1.org2.com:
    container_name: peer1.org2.com
    image: hyperledger/fabric-peer:\${FABRIC_VERSION}
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer1.org2.com
      - CORE_LOGGING_PEER=\${LOGGING_LEVEL}
      - CORE_CHAINCODE_LOGGING_LEVEL=\${LOGGING_LEVEL}
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=\${COMPOSE_PROJECT_NAME}_basic
      - CORE_VM_DOCKER_ATTACHSTDOUT=true
      - GODEBUG=netdns=go
      #
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/peer/msp
      - CORE_PEER_LOCALMSPID=Org2MSP
      - CORE_PEER_ADDRESS=peer1.org2.com:7051
            # enabled TLS
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/peer/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/peer/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer/tls/ca.crt
            
    working_dir: /etc/hyperledger/fabric/peer/
    command: peer node start
    ports:
      - 7062:7051
     #- 7053:7053
    volumes:
      - /var/run/:/host/var/run/
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer1.org2.com/msp:/etc/hyperledger/fabric/peer/msp
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/peers/peer1.org2.com/tls:/etc/hyperledger/fabric/peer/tls
      - ../fabric-config/crypto-config/peerOrganizations/org2.com/users:/etc/hyperledger/fabric/peer/msp/users
      - ../fabric-config/config:/etc/hyperledger/fabric/config
    depends_on:
      - orderer0.root.com
    networks:
      - basic
  
  
  
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/base-functions.sh 1`] = `
"import util/log
import util/tryCatch

function certsGenerate() {
  local CONTAINER_NAME=certsGenerate

  local CONFIG_PATH=$1
  local CRYPTO_CONFIG_FILE_NAME=$2
  local ORG_PATH=$3
  local OUTPUT_PATH=$4
  local FULL_CERT_PATH=$OUTPUT_PATH$ORG_PATH

  echo \\"Generating certs...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CRYPTO_CONFIG_FILE_NAME: $CRYPTO_CONFIG_FILE_NAME\\"
  inputLog \\"ORG_PATH: $ORG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"FULL_CERT_PATH: $FULL_CERT_PATH\\"

  if [ -d \\"$FULL_CERT_PATH\\" ]; then
    echo \\"Can't generate certs, directory already exists : $FULL_CERT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME cryptogen generate --config=./fabric-config/$CRYPTO_CONFIG_FILE_NAME

    docker cp $CONTAINER_NAME:/crypto-config/. $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }

  removeContainer $CONTAINER_NAME
  for file in $(find $OUTPUT_PATH/ -iname *_sk); do dir=$(dirname $file); mv \${dir}/*_sk \${dir}/priv-key.pem; done
}

function genesisBlockCreate() {
  local CONTAINER_NAME=genesisBlockCreate

  local CONFIG_PATH=$1
  local OUTPUT_PATH=$2

  echo \\"Creating genesis block...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"

  if [ -d \\"$OUTPUT_PATH\\" ]; then
    echo \\"Cant't generate genesis block, directory already exists : $OUTPUT_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile SoloOrdererGenesis -outputBlock ./config/genesis.block || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config $OUTPUT_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createChannelTx() {
  local CONTAINER_NAME=createChannelTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local CHANNEL_TX_PATH=$OUTPUT_PATH\\"/\\"$CHANNEL_NAME\\".tx\\"

  echo \\"Creating channelTx for $CHANNEL_NAME...\\"
  inputLog \\"CONFIG_PATH: $CONFIG_PATH\\"
  inputLog \\"CONFIG_PROFILE: $CONFIG_PROFILE\\"
  inputLog \\"OUTPUT_PATH: $OUTPUT_PATH\\"
  inputLog \\"CHANNEL_TX_PATH: $CHANNEL_TX_PATH\\"

  if [ -f \\"$CHANNEL_TX_PATH\\" ]; then
    echo \\"Can't create channel configuration, it already exists : $CHANNEL_TX_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputCreateChannelTx ./config/channel.tx -channelID \${CHANNEL_NAME} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/channel.tx $CHANNEL_TX_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function createAnchorPeerUpdateTx() {
  local CONTAINER_NAME=createAnchorPeerUpdateTx

  local CHANNEL_NAME=$1
  local CONFIG_PATH=$2
  local CONFIG_PROFILE=$3
  local OUTPUT_PATH=$4
  local MSP=$5
  local ANCHOR_PEER_UPDATE_PATH=$OUTPUT_PATH\\"/\\"$MSP\\"anchors.tx\\"

  if [ -f \\"$ANCHOR_PEER_UPDATE_PATH\\" ]; then
    echo \\"Cant't create anchor peer update, it already exists : $ANCHOR_PEER_UPDATE_PATH\\"
    echo \\"Try using 'recreate' or 'down' to remove whole network or 'start' to reuse it\\"
    exit 1
  fi

  try {
    docker run -i -d --name $CONTAINER_NAME hyperledger/fabric-tools:\${FABRIC_VERSION} bash
    docker cp $CONFIG_PATH $CONTAINER_NAME:/fabric-config

    docker exec -i $CONTAINER_NAME mkdir /config
    docker exec -i $CONTAINER_NAME configtxgen --configPath ./fabric-config -profile \${CONFIG_PROFILE} -outputAnchorPeersUpdate ./config/\${MSP}anchors.tx -channelID \${CHANNEL_NAME} -asOrg \${MSP} || removeContainer $CONTAINER_NAME

    docker cp $CONTAINER_NAME:/config/\${MSP}anchors.tx $ANCHOR_PEER_UPDATE_PATH
  } catch {
    removeContainer $CONTAINER_NAME
  }
  removeContainer $CONTAINER_NAME
}

function chaincodeInstall() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"
  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation. Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiate() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate. Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function chaincodeInstallTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8
  local CA_CERT=\\"/var/hyperledger/cli/\\"$9

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Installing chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec -e CHANNEL_NAME=$CHANNEL_NAME -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
      $CLI_NAME peer chaincode install \\\\
      -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -p /var/hyperledger/cli/$CHAINCODE_NAME/ \\\\
      -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' installation (TLS). Chaincode's directory is empty.\\"
  fi
}

function chaincodeInstantiateTls() {
  local CHAINCODE_DIR_PATH=$1
  local CHAINCODE_NAME=$2
  local CHAINCODE_VERSION=$3
  local CHAINCODE_LANG=$4

  local CHANNEL_NAME=$5

  local PEER_ADDRESS=$6
  local ORDERER_URL=$7
  local CLI_NAME=$8

  local INIT_PARAMS=$9
  local ENDORSEMENT=\${10}
  local CA_CERT=\\"/var/hyperledger/cli/\\"\${11}

  local CHAINCODE_DIR_CONTENT=$(ls $CHAINCODE_DIR_PATH)

  echo \\"Instantiating chaincode on $CHANNEL_NAME (TLS)...\\"
  inputLog \\"CHAINCODE_NAME: $CHAINCODE_NAME\\"
  inputLog \\"CHAINCODE_VERSION: $CHAINCODE_VERSION\\"
  inputLog \\"CHAINCODE_LANG: $CHAINCODE_LANG\\"
  inputLog \\"CHAINCODE_DIR_PATH: $CHAINCODE_DIR_PATH\\"

  inputLog \\"INIT_PARAMS: $INIT_PARAMS\\"
  inputLog \\"ENDORSEMENT: $ENDORSEMENT\\"

  inputLog \\"PEER_ADDRESS: $PEER_ADDRESS\\"
  inputLog \\"ORDERER_URL: $ORDERER_URL\\"
  inputLog \\"CLI_NAME: $CLI_NAME\\"
  inputLog \\"CA_CERT: $CA_CERT\\"

  if [ ! -z \\"$CHAINCODE_DIR_CONTENT\\" ]; then
    docker exec \\\\
        -e CORE_PEER_ADDRESS=$PEER_ADDRESS \\\\
        $CLI_NAME peer chaincode instantiate \\\\
        -n $CHAINCODE_NAME -v $CHAINCODE_VERSION -l $CHAINCODE_LANG -c \\"$INIT_PARAMS\\" -C $CHANNEL_NAME -P \\"$ENDORSEMENT\\" \\\\
        -o $ORDERER_URL --tls --cafile $CA_CERT
  else
    echo \\"Skipping chaincode '$CHAINCODE_NAME' instantiate (TLS). Chaincode's directory is empty.\\"
    echo \\"Looked in dir: '$CHAINCODE_DIR_PATH'\\"
  fi
}

function printHeadline() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Bold)============ %b %s %b ==============$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function printItalics() {
  TEXT=$1
  EMOJI=$2
  printf \\"$(UI.Color.Italics)==== %b %s %b ====$(UI.Color.Default)\\\\n\\" \\"\\\\\\\\$EMOJI\\" \\"$TEXT\\" \\"\\\\\\\\$EMOJI\\"
}

function inputLog() {
  echo \\"$(UI.Color.DarkGray)   $1 $(UI.Color.Default)\\"
}

function certsRemove() {
  local CERTS_DIR_PATH=$1
  rm -rf \\"$CERTS_DIR_PATH\\"/*
}

function removeContainer() {
  CONTAINER_NAME=$1
  docker rm -f \\"$CONTAINER_NAME\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/base-help.sh 1`] = `
"function printHelp() {
  echo \\"Fabrikka is powered by SoftwareMill\\"

  echo \\"\\"
  echo \\"usage: ./fabric-compose.sh <command>\\"
  echo \\"\\"

  echo \\"Commands: \\"
  echo \\"\\"
  echo \\"./fabric-compose.sh up\\"
  echo -e \\"\\\\t Use for first run. Creates all needed artifacts (certs, genesis block) and starts network for the first time.\\"
  echo -e \\"\\\\t After 'up' commands start/stop are used to manage network and rerun to rerun it\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh down\\"
  echo -e \\"\\\\t Back to empty state - destorys created containers, prunes generated certificates, configs.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh start\\"
  echo -e \\"\\\\t Starts already created network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh stop\\"
  echo -e \\"\\\\t Stops already running network.\\"
  echo \\"\\"
  echo \\"./fabric-compose.sh recreate\\"
  echo -e \\"\\\\t Fresh start - it destorys whole network, certs, configs and then reruns everything.\\"
  echo \\"\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/cli/channel_fns.sh 1`] = `
"function createChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-createChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx
  peer channel join -b \${CHANNEL_NAME}.block

  rm -rf $DIR_NAME
}

function createChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-createChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Creating channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  cp /var/hyperledger/cli/config/\\"$CHANNEL_NAME\\".tx .

  peer channel create -o \${ORDERER_URL} -c \${CHANNEL_NAME} -f ./\\"$CHANNEL_NAME\\".tx --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}

function fetchChannelAndJoin() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)

  local ORDERER_URL=$5

  local DIR_NAME=step-fetchChannelAndJoin-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name: \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL}
  peer channel join -b \${CHANNEL_NAME}_newest.block

  rm -rf $DIR_NAME
}

function fetchChannelAndJoinTls() {
  local CHANNEL_NAME=$1

  local CORE_PEER_LOCALMSPID=$2
  local CORE_PEER_ADDRESS=$3
  local CORE_PEER_MSPCONFIGPATH=$(realpath $4)
  local CORE_PEER_TLS_MSPCONFIGPATH=$(realpath $5)
  local TLS_CA_CERT_PATH=$(realpath $6)
  local ORDERER_URL=$7

  local CORE_PEER_TLS_CERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.crt
  local CORE_PEER_TLS_KEY_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/client.key
  local CORE_PEER_TLS_ROOTCERT_FILE=$CORE_PEER_TLS_MSPCONFIGPATH/ca.crt

  local DIR_NAME=step-fetchChannelAndJoinTls-$CHANNEL_NAME-$CORE_PEER_ADDRESS

  echo \\"Fetching channel with name (TLS): \${CHANNEL_NAME}\\"
  echo \\"   Orderer: $ORDERER_URL\\"
  echo \\"   CORE_PEER_LOCALMSPID: $CORE_PEER_LOCALMSPID\\"
  echo \\"   CORE_PEER_ADDRESS: $CORE_PEER_ADDRESS\\"
  echo \\"   CORE_PEER_MSPCONFIGPATH: $CORE_PEER_MSPCONFIGPATH\\"
  echo \\"\\"
  echo \\"   TLS_CA_CERT_PATH is: $TLS_CA_CERT_PATH\\"
  echo \\"   CORE_PEER_TLS_CERT_FILE: $CORE_PEER_TLS_CERT_FILE\\"
  echo \\"   CORE_PEER_TLS_KEY_FILE: $CORE_PEER_TLS_KEY_FILE\\"
  echo \\"   CORE_PEER_TLS_ROOTCERT_FILE: $CORE_PEER_TLS_ROOTCERT_FILE\\"

  mkdir $DIR_NAME && cd $DIR_NAME

  peer channel fetch newest -c \${CHANNEL_NAME} --orderer \${ORDERER_URL} --tls --cafile $TLS_CA_CERT_PATH
  peer channel join -b \${CHANNEL_NAME}_newest.block --tls --cafile $TLS_CA_CERT_PATH

  rm -rf $DIR_NAME
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Contains.sh 1`] = `
"Array::Contains() {
  local element
  for element in \\"\${@:2}\\"
  do
    [[ \\"$element\\" = \\"$1\\" ]] && return 0
  done
  return 1
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Intersect.sh 1`] = `
"import util/namedParameters util/type

Array::Intersect() {
  @required [array] arrayA
  @required [array] arrayB

  array intersection

  # http://stackoverflow.com/questions/2312762/compare-difference-of-two-arrays-in-bash
  for i in \\"\${arrayA[@]}\\"
  do
    local skip=
    for j in \\"\${arrayB[@]}\\"
    do
      [[ \\"$i\\" == \\"$j\\" ]] && { skip=1; break; }
    done
    [[ -n $skip ]] || intersection+=(\\"$i\\")
  done

  @get intersection
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/List.sh 1`] = `
"import util/namedParameters

## generates a list separated by new lines
Array::List() {
  @required [string] variableName
  [string] separator=$'\\\\n'

  local indirectAccess=\\"\${variableName}[*]\\"
  (
    local IFS=\\"$separator\\"
    echo \\"\${!indirectAccess}\\"
  )
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Reverse.sh 1`] = `
"import util/namedParameters

## TODO: consider making Parameters::Methods
## since this actually modifies parameters, not arrays

## static methods should be Array::Method, with capital letter

# static version
Array::Reverse() {
  [...rest] this

  local -i length=\${#this[@]}  #$(this length)
  local -a outArray
  local -i indexFromEnd
  local -i index

  for index in \\"\${!this[@]}\\"
  do
    indexFromEnd=$(( $length - 1 - $index ))
    outArray+=( \\"\${this[$indexFromEnd]}\\" )
  done

  @get outArray
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/GetSpaces.sh 1`] = `
"String::GetSpaces() {
  local howMany=\\"$1\\"

  if [[ \\"$howMany\\" -gt 0 ]]
  then
    ( printf \\"%*s\\" \\"$howMany\\" )
  fi
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/IsNumber.sh 1`] = `
"String::IsNumber() {
  local input=\\"$1\\"

  local regex='^-?[0-9]+([.][0-9]+)?$'
  if ! [[ \\"$input\\" =~ $regex ]]
  then
    return 1
  fi
  return 0
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/SanitizeForVariable.sh 1`] = `
"String::SanitizeForVariableName() {
  local type=\\"$1\\"
  echo \\"\${type//[^a-zA-Z0-9]/_}\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/SlashReplacement.sh 1`] = `
"String::ReplaceSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slash$slash/$slashReplacement}\\"
}

String::RestoreSlashes() {
  local stringToMark=\\"$1\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local slash=\\"\\\\\\\\\\"
  local slashReplacement='_%SLASH%_'
  echo \\"\${stringToMark/$slashReplacement/$slash}\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/UUID.sh 1`] = `
"String::GenerateUUID() {
  ## https://gist.github.com/markusfisch/6110640
  local N B C='89ab'

  for (( N=0; N < 16; ++N ))
  do
    B=$(( $RANDOM%256 ))

    case $N in
      6)
        printf '4%x' $(( B%16 ))
      ;;
      8)
        printf '%c%x' \${C:$RANDOM%\${#C}:1} $(( B%16 ))
      ;;
      3 | 5 | 7 | 9)
        printf '%02x-' $B
      ;;
      *)
        printf '%02x' $B
      ;;
    esac
  done
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Color.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  alias UI.Color.Default=\\"echo \\\\$'\\\\033[0m'\\"

  alias UI.Color.Black=\\"echo \\\\$'\\\\033[0;30m'\\"
  alias UI.Color.Red=\\"echo \\\\$'\\\\033[0;31m'\\"
  alias UI.Color.Green=\\"echo \\\\$'\\\\033[0;32m'\\"
  alias UI.Color.Yellow=\\"echo \\\\$'\\\\033[0;33m'\\"
  alias UI.Color.Blue=\\"echo \\\\$'\\\\033[0;34m'\\"
  alias UI.Color.Magenta=\\"echo \\\\$'\\\\033[0;35m'\\"
  alias UI.Color.Cyan=\\"echo \\\\$'\\\\033[0;36m'\\"
  alias UI.Color.LightGray=\\"echo \\\\$'\\\\033[0;37m'\\"

  alias UI.Color.DarkGray=\\"echo \\\\$'\\\\033[0;90m'\\"
  alias UI.Color.LightRed=\\"echo \\\\$'\\\\033[0;91m'\\"
  alias UI.Color.LightGreen=\\"echo \\\\$'\\\\033[0;92m'\\"
  alias UI.Color.LightYellow=\\"echo \\\\$'\\\\033[0;93m'\\"
  alias UI.Color.LightBlue=\\"echo \\\\$'\\\\033[0;94m'\\"
  alias UI.Color.LightMagenta=\\"echo \\\\$'\\\\033[0;95m'\\"
  alias UI.Color.LightCyan=\\"echo \\\\$'\\\\033[0;96m'\\"
  alias UI.Color.White=\\"echo \\\\$'\\\\033[0;97m'\\"

  # flags
  alias UI.Color.Bold=\\"echo \\\\$'\\\\033[1m'\\"
  alias UI.Color.Dim=\\"echo \\\\$'\\\\033[2m'\\"
  alias UI.Color.Italics=\\"echo \\\\$'\\\\033[3m'\\"
  alias UI.Color.Underline=\\"echo \\\\$'\\\\033[4m'\\"
  alias UI.Color.Blink=\\"echo \\\\$'\\\\033[5m'\\"
  alias UI.Color.Invert=\\"echo \\\\$'\\\\033[7m'\\"
  alias UI.Color.Invisible=\\"echo \\\\$'\\\\033[8m'\\"

  alias UI.Color.NoBold=\\"echo \\\\$'\\\\033[21m'\\"
  alias UI.Color.NoDim=\\"echo \\\\$'\\\\033[22m'\\"
  alias UI.Color.NoItalics=\\"echo \\\\$'\\\\033[23m'\\"
  alias UI.Color.NoUnderline=\\"echo \\\\$'\\\\033[24m'\\"
  alias UI.Color.NoBlink=\\"echo \\\\$'\\\\033[25m'\\"
  alias UI.Color.NoInvert=\\"echo \\\\$'\\\\033[27m'\\"
  alias UI.Color.NoInvisible=\\"echo \\\\$'\\\\033[28m'\\"
else
  alias UI.Color.Default=\\"echo\\"

  alias UI.Color.Black=\\"echo\\"
  alias UI.Color.Red=\\"echo\\"
  alias UI.Color.Green=\\"echo\\"
  alias UI.Color.Yellow=\\"echo\\"
  alias UI.Color.Blue=\\"echo\\"
  alias UI.Color.Magenta=\\"echo\\"
  alias UI.Color.Cyan=\\"echo\\"
  alias UI.Color.LightGray=\\"echo\\"

  alias UI.Color.DarkGray=\\"echo\\"
  alias UI.Color.LightRed=\\"echo\\"
  alias UI.Color.LightGreen=\\"echo\\"
  alias UI.Color.LightYellow=\\"echo\\"
  alias UI.Color.LightBlue=\\"echo\\"
  alias UI.Color.LightMagenta=\\"echo\\"
  alias UI.Color.LightCyan=\\"echo\\"
  alias UI.Color.White=\\"echo\\"

  # flags
  alias UI.Color.Bold=\\"echo\\"
  alias UI.Color.Dim=\\"echo\\"
  alias UI.Color.Underline=\\"echo\\"
  alias UI.Color.Blink=\\"echo\\"
  alias UI.Color.Invert=\\"echo\\"
  alias UI.Color.Invisible=\\"echo\\"

  alias UI.Color.NoBold=\\"echo\\"
  alias UI.Color.NoDim=\\"echo\\"
  alias UI.Color.NoUnderline=\\"echo\\"
  alias UI.Color.NoBlink=\\"echo\\"
  alias UI.Color.NoInvert=\\"echo\\"
  alias UI.Color.NoInvisible=\\"echo\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  alias UI.Powerline.PointingArrow=\\"echo -e $'\\\\u27a1'\\"
  alias UI.Powerline.ArrowLeft=\\"echo -e $'\\\\u25c0'\\"
  alias UI.Powerline.ArrowRight=\\"echo -e $'\\\\u25b6'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo -e $'\\\\u2198'\\"
  alias UI.Powerline.ArrowDown=\\"echo -e $'\\\\u2B07'\\"
  alias UI.Powerline.PlusMinus=\\"echo -e $'\\\\ue00b1'\\"
  alias UI.Powerline.Branch=\\"echo -e $'\\\\ue0a0'\\"
  alias UI.Powerline.RefersTo=\\"echo -e $'\\\\u27a6'\\"
  alias UI.Powerline.OK=\\"echo -e $'\\\\u2714'\\"
  alias UI.Powerline.Fail=\\"echo -e $'\\\\u2718'\\"
  alias UI.Powerline.Lightning=\\"echo -e $'\\\\u26a1'\\"
  alias UI.Powerline.Cog=\\"echo -e $'\\\\u2699'\\"
  alias UI.Powerline.Heart=\\"echo -e $'\\\\u2764'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo -e $'\\\\u2b50'\\"
  alias UI.Powerline.Saxophone=\\"echo -e $'\\\\U1F3B7'\\"
  alias UI.Powerline.ThumbsUp=\\"echo -e $'\\\\U1F44D'\\"
else
  alias UI.Powerline.PointingArrow=\\"echo '~'\\"
  alias UI.Powerline.ArrowLeft=\\"echo '<'\\"
  alias UI.Powerline.ArrowRight=\\"echo '>'\\"
  alias UI.Powerline.ArrowRightDown=\\"echo '>'\\"
  alias UI.Powerline.ArrowDown=\\"echo '_'\\"
  alias UI.Powerline.PlusMinus=\\"echo '+-'\\"
  alias UI.Powerline.Branch=\\"echo '|}'\\"
  alias UI.Powerline.RefersTo=\\"echo '*'\\"
  alias UI.Powerline.OK=\\"echo '+'\\"
  alias UI.Powerline.Fail=\\"echo 'x'\\"
  alias UI.Powerline.Lightning=\\"echo '!'\\"
  alias UI.Powerline.Cog=\\"echo '{*}'\\"
  alias UI.Powerline.Heart=\\"echo '<3'\\"

  # colorful
  alias UI.Powerline.Star=\\"echo '*''\\"
  alias UI.Powerline.Saxophone=\\"echo '(YEAH)'\\"
  alias UI.Powerline.ThumbsUp=\\"echo '(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Color.var.sh 1`] = `
"alias UI.Color.IsAvailable='[ $(tput colors 2>/dev/null || echo 0) -ge 16 ] && [ -t 1 ]'
if UI.Color.IsAvailable
then
  UI_Color_Default=$'\\\\033[0m'

  UI_Color_Black=$'\\\\033[0;30m'
  UI_Color_Red=$'\\\\033[0;31m'
  UI_Color_Green=$'\\\\033[0;32m'
  UI_Color_Yellow=$'\\\\033[0;33m'
  UI_Color_Blue=$'\\\\033[0;34m'
  UI_Color_Magenta=$'\\\\033[0;35m'
  UI_Color_Cyan=$'\\\\033[0;36m'
  UI_Color_LightGray=$'\\\\033[0;37m'

  UI_Color_DarkGray=$'\\\\033[0;90m'
  UI_Color_LightRed=$'\\\\033[0;91m'
  UI_Color_LightGreen=$'\\\\033[0;92m'
  UI_Color_LightYellow=$'\\\\033[0;93m'
  UI_Color_LightBlue=$'\\\\033[0;94m'
  UI_Color_LightMagenta=$'\\\\033[0;95m'
  UI_Color_LightCyan=$'\\\\033[0;96m'
  UI_Color_White=$'\\\\033[0;97m'

  # flags
  UI_Color_Bold=$'\\\\033[1m'
  UI_Color_Dim=$'\\\\033[2m'
  UI_Color_Italics=$'\\\\033[3m'
  UI_Color_Underline=$'\\\\033[4m'
  UI_Color_Blink=$'\\\\033[5m'
  UI_Color_Invert=$'\\\\033[7m'
  UI_Color_Invisible=$'\\\\033[8m'

  UI_Color_NoBold=$'\\\\033[21m'
  UI_Color_NoDim=$'\\\\033[22m'
  UI_Color_NoItalics=$'\\\\033[23m'
  UI_Color_NoUnderline=$'\\\\033[24m'
  UI_Color_NoBlink=$'\\\\033[25m'
  UI_Color_NoInvert=$'\\\\033[27m'
  UI_Color_NoInvisible=$'\\\\033[28m'
else
  UI_Color_Default=\\"\\"

  UI_Color_Black=\\"\\"
  UI_Color_Red=\\"\\"
  UI_Color_Green=\\"\\"
  UI_Color_Yellow=\\"\\"
  UI_Color_Blue=\\"\\"
  UI_Color_Magenta=\\"\\"
  UI_Color_Cyan=\\"\\"
  UI_Color_LightGray=\\"\\"

  UI_Color_DarkGray=\\"\\"
  UI_Color_LightRed=\\"\\"
  UI_Color_LightGreen=\\"\\"
  UI_Color_LightYellow=\\"\\"
  UI_Color_LightBlue=\\"\\"
  UI_Color_LightMagenta=\\"\\"
  UI_Color_LightCyan=\\"\\"
  UI_Color_White=\\"\\"

  # flags
  UI_Color_Bold=\\"\\"
  UI_Color_Dim=\\"\\"
  UI_Color_Italics=\\"\\"
  UI_Color_Underline=\\"\\"
  UI_Color_Blink=\\"\\"
  UI_Color_Invert=\\"\\"
  UI_Color_Invisible=\\"\\"

  UI_Color_NoBold=\\"\\"
  UI_Color_NoDim=\\"\\"
  UI_Color_NoItalics=\\"\\"
  UI_Color_NoUnderline=\\"\\"
  UI_Color_NoBlink=\\"\\"
  UI_Color_NoInvert=\\"\\"
  UI_Color_NoInvisible=\\"\\"
fi

alias UI.Powerline.IsAvailable=\\"UI.Color.IsAvailable && test -z \\\\\${NO_UNICODE-} && (echo -e $'\\\\u1F3B7' | grep -v F3B7) &> /dev/null\\"
if UI.Powerline.IsAvailable
then
  UI_Powerline_PointingArrow=$'\\\\u27a1'
  UI_Powerline_ArrowLeft=$'\\\\ue0b2'
  UI_Powerline_ArrowRight=$'\\\\ue0b0'
  UI_Powerline_ArrowRightDown=$'\\\\u2198'
  UI_Powerline_ArrowDown=$'\\\\u2B07'
  UI_Powerline_PlusMinus=$'\\\\ue00b1'
  UI_Powerline_Branch=$'\\\\ue0a0'
  UI_Powerline_RefersTo=$'\\\\u27a6'
  UI_Powerline_OK=$'\\\\u2714'
  UI_Powerline_Fail=$'\\\\u2718'
  UI_Powerline_Lightning=$'\\\\u26a1'
  UI_Powerline_Cog=$'\\\\u2699'
  UI_Powerline_Heart=$'\\\\u2764'

  # colorful
  UI_Powerline_Star=$'\\\\u2b50'
  UI_Powerline_Saxophone=$'\\\\U1F3B7'
  UI_Powerline_ThumbsUp=$'\\\\U1F44D'
else
  UI_Powerline_PointingArrow=\\"'~'\\"
  UI_Powerline_ArrowLeft=\\"'<'\\"
  UI_Powerline_ArrowRight=\\"'>'\\"
  UI_Powerline_ArrowRightDown=\\"'>'\\"
  UI_Powerline_ArrowDown=\\"'_'\\"
  UI_Powerline_PlusMinus=\\"'+-'\\"
  UI_Powerline_Branch=\\"'|}'\\"
  UI_Powerline_RefersTo=\\"'*'\\"
  UI_Powerline_OK=\\"'+'\\"
  UI_Powerline_Fail=\\"'x'\\"
  UI_Powerline_Lightning=\\"'!'\\"
  UI_Powerline_Cog=\\"'{*}'\\"
  UI_Powerline_Heart=\\"'<3'\\"

  # colorful
  UI_Powerline_Star=\\"'*''\\"
  UI_Powerline_Saxophone=\\"'(YEAH)'\\"
  UI_Powerline_ThumbsUp=\\"'(OK)'\\"
fi

UI.Color.Print() {
  local -i colorCode=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[\${colorCode}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256text() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[38;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}

UI.Color.256background() {
  local -i colorNumber=\\"$1\\"

  if UI.Color.IsAvailable
  then
    local colorString=\\"\\\\$'\\\\033[48;5;\${colorNumber}m'\\"
    eval echo \\"\${colorString}\\"
  else
    echo
  fi
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Console.sh 1`] = `
"import UI/Color

Console::WriteStdErr() {
  # http://stackoverflow.com/questions/2990414/echo-that-outputs-to-stderr
  cat <<< \\"$*\\" 1>&2
  return
}

Console::WriteStdErrAnnotated() {
  local script=\\"$1\\"
  local lineNo=$2
  local color=$3
  local type=$4
  shift; shift; shift; shift

  Console::WriteStdErr \\"$color[$type] $(UI.Color.Blue)[\${script}:\${lineNo}]$(UI.Color.Default) $* \\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Cursor.sh 1`] = `
"import util/class

class:UI.Cursor() {
  # http://askubuntu.com/questions/366103/saving-more-corsor-positions-with-tput-in-bash-terminal
	# http://unix.stackexchange.com/questions/88296/get-vertical-cursor-position

	private integer x
	private integer y

  UI.Cursor.capture() {
    local x
    local y
    IFS=';' read -sdR -p $'\\\\E[6n' y x

    this y = $(( \${y#*[} - 1 ))
    this x = $(( \${x} - 1 ))

    @return
  }

  UI.Cursor.restore() {
    [integer] shift=1

    local -i totalHeight=$(tput lines)
    local -i y=$(this y)
    local -i x=$(this x)

    (( $y + 1 == $totalHeight )) && y+=-$shift

    tput cup $y $x

    @return
  }
}

Type::Initialize UI.Cursor
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/oo-bootstrap.sh 1`] = `
"#!/usr/bin/env bash

###########################
### BOOTSTRAP FUNCTIONS ###
###########################

if [[ -n \\"\${__INTERNAL_LOGGING__:-}\\" ]]
then
  alias DEBUG=\\":; \\"
else
  alias DEBUG=\\":; #\\"
fi

System::SourceHTTP() {
  local URL=\\"$1\\"
  local -i RETRIES=3
  shift

  if hash curl 2>/dev/null
  then
    builtin source <(curl --fail -sL --retry $RETRIES \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && curl --fail -sL --retry $RETRIES \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  else
    builtin source <(wget -t $RETRIES -O - -o /dev/null \\"\${URL}\\" || { [[ \\"$URL\\" != *'.sh' && \\"$URL\\" != *'.bash' ]] && wget -t $RETRIES -O - -o /dev/null \\"\${URL}.sh\\"; } || echo \\"e='Cannot import $URL' throw\\") \\"$@\\"
  fi
  __oo__importedFiles+=( \\"$URL\\" )
}

System::SourcePath() {
  local libPath=\\"$1\\"
  shift
  # echo trying $libPath
  if [[ -d \\"$libPath\\" ]]
  then
    local file
    for file in \\"$libPath\\"/*.sh
    do
      System::SourceFile \\"$file\\" \\"$@\\"
    done
  else
    System::SourceFile \\"$libPath\\" \\"$@\\" || System::SourceFile \\"\${libPath}.sh\\" \\"$@\\"
  fi
}

declare -g __oo__fdPath=$(dirname <(echo))
declare -gi __oo__fdLength=$(( \${#__oo__fdPath} + 1 ))

System::ImportOne() {
  local libPath=\\"$1\\"
  local __oo__importParent=\\"\${__oo__importParent-}\\"
  local requestedPath=\\"$libPath\\"
  shift

  if [[ \\"$requestedPath\\" == 'github:'* ]]
  then
    requestedPath=\\"https://raw.githubusercontent.com/\${requestedPath:7}\\"
  elif [[ \\"$requestedPath\\" == './'* ]]
  then
    requestedPath=\\"\${requestedPath:2}\\"
  elif [[ \\"$requestedPath\\" == \\"$__oo__fdPath\\"* ]] # starts with /dev/fd
  then
    requestedPath=\\"\${requestedPath:$__oo__fdLength}\\"
  fi

  # [[ \\"$__oo__importParent\\" == 'http://'* || \\"$__oo__importParent\\" == 'https://'* ]] &&
  if [[ \\"$requestedPath\\" != 'http://'* && \\"$requestedPath\\" != 'https://'* ]]
  then
    requestedPath=\\"\${__oo__importParent}/\${requestedPath}\\"
  fi

  if [[ \\"$requestedPath\\" == 'http://'* || \\"$requestedPath\\" == 'https://'* ]]
  then
    __oo__importParent=$(dirname \\"$requestedPath\\") System::SourceHTTP \\"$requestedPath\\"
    return
  fi

  # try relative to parent script
  # try with parent
  # try without parent
  # try global library
  # try local library
  {
    local localPath=\\"$( cd \\"\${BASH_SOURCE[1]%/*}\\" && pwd )\\"
    localPath=\\"\${localPath}/\${libPath}\\"
    System::SourcePath \\"\${localPath}\\" \\"$@\\"
  } || \\\\
  System::SourcePath \\"\${requestedPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__libPath}/\${libPath}\\" \\"$@\\" || \\\\
  System::SourcePath \\"\${__oo__path}/\${libPath}\\" \\"$@\\" || e=\\"Cannot import $libPath\\" throw
}

System::Import() {
  local libPath
  for libPath in \\"$@\\"
  do
    System::ImportOne \\"$libPath\\"
  done
}

File::GetAbsolutePath() {
  # http://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
  # $1 : relative filename
  local file=\\"$1\\"
  if [[ \\"$file\\" == \\"/\\"* ]]
  then
    echo \\"$file\\"
  else
    echo \\"$(cd \\"$(dirname \\"$file\\")\\" && pwd)/$(basename \\"$file\\")\\"
  fi
}

System::WrapSource() {
  local libPath=\\"$1\\"
  shift

  builtin source \\"$libPath\\" \\"$@\\" || throw \\"Unable to load $libPath\\"
}

System::SourceFile() {
  local libPath=\\"$1\\"
  shift

  # DEBUG subject=level3 Log \\"Trying to load from: \${libPath}\\"
  [[ ! -f \\"$libPath\\" ]] && return 1 # && e=\\"Cannot import $libPath\\" throw

  libPath=\\"$(File::GetAbsolutePath \\"$libPath\\")\\"

  # echo \\"importing $libPath\\"

  # [ -e \\"$libPath\\" ] && echo \\"Trying to load from: \${libPath}\\"
  if [[ -f \\"$libPath\\" ]]
  then
    ## if already imported let's return
    # if declare -f \\"Array::Contains\\" &> /dev/null &&
    if [[ \\"\${__oo__allowFileReloading-}\\" != true ]] && [[ ! -z \\"\${__oo__importedFiles[*]}\\" ]] && Array::Contains \\"$libPath\\" \\"\${__oo__importedFiles[@]}\\"
    then
      # DEBUG subject=level3 Log \\"File previously imported: \${libPath}\\"
      return 0
    fi

    # DEBUG subject=level2 Log \\"Importing: $libPath\\"

    __oo__importedFiles+=( \\"$libPath\\" )
    __oo__importParent=$(dirname \\"$libPath\\") System::WrapSource \\"$libPath\\" \\"$@\\"
    # eval \\"$(<\\"$libPath\\")\\"

  else
    :
    # DEBUG subject=level2 Log \\"File doesn't exist when importing: $libPath\\"
  fi
}

System::Bootstrap() {
  ## note: aliases are visible inside functions only if
  ## they were initialized AFTER they were created
  ## this is the reason why we have to load files in a specific order
  if ! System::Import Array/Contains
  then
    cat <<< \\"FATAL ERROR: Unable to bootstrap (missing lib directory?)\\" 1>&2
    exit 1
  fi
}

########################
### INITIALZE SYSTEM ###
########################

# From: http://wiki.bash-hackers.org/scripting/debuggingtips
export PS4='+(\${BASH_SOURCE##*/}:\${LINENO}): \${FUNCNAME[0]:+\${FUNCNAME[0]}(): }'

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail

shopt -s expand_aliases
declare -g __oo__libPath=\\"$( cd \\"\${BASH_SOURCE[0]%/*}\\" && pwd )\\"
declare -g __oo__path=\\"\${__oo__libPath}/..\\"
declare -ag __oo__importedFiles

## stubs in case either exception or log is not loaded
namespace() { :; }
throw() { eval 'cat <<< \\"Exception: $e ($*)\\" 1>&2; read -s;'; }

System::Bootstrap

alias import=\\"__oo__allowFileReloading=false System::Import\\"
alias source=\\"__oo__allowFileReloading=true System::ImportOne\\"
alias .=\\"__oo__allowFileReloading=true System::ImportOne\\"

declare -g __oo__bootstrapped=true
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/bash4.sh 1`] = `
"[[ \\"\${BASH_VERSINFO[0]}\\" -lt 4 ]] && echo \\"The module you are trying to load requires bash >= 4\\" && exit 1 || true
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/class.sh 1`] = `
"namespace util/type
import util/type String/SanitizeForVariable
# ------------------------ #

Type::DefineProperty() {
  local visibility=\\"$1\\"
  local class=\\"$2\\"
  local type=\\"$3\\"
  local property=\\"$4\\"
  local assignment=\\"$5\\"
  local defaultValue=\\"$6\\"

  class=\\"\${class//[^a-zA-Z0-9]/_}\\"

  eval \\"__\${class}_property_names+=( '$property' )\\"
  eval \\"__\${class}_property_types+=( '$type' )\\"
  eval \\"__\${class}_property_visibilities+=( '$visibility' )\\"
  # if [[ \\"$assignment\\" == '=' && ! -z \\"$defaultValue\\" ]]
  # then
    eval \\"__\${class}_property_defaults+=( \\\\\\"\\\\$defaultValue\\\\\\" )\\"
  # fi
}

private() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty private $class \\"$@\\"
}

public() {
  # \${FUNCNAME[1]} contains the name of the class
  local class=\${FUNCNAME[1]#*:}

  Type::DefineProperty public $class \\"$@\\"
}

Type::Initialize() {
  local name=\\"$1\\"
  local style=\\"\${2:-default}\\"

  Function::Exists class:$name && class:$name || true

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"

  case \\"$style\\" in
    'primitive') ;;
    'static')
      declare -Ag __oo_static_instance_\${name}=\\"$(Type::Construct $name)\\"
      eval \\"\${name}\\"'(){ '\\"Type::Handle __oo_static_instance_\${name}\\"' \\"$@\\"; }'
    ;;
    *)
      ## add alias for parameters
      alias [$name]=\\"_type=$name Variable::TrapAssign local -A\\"

      ## add alias for creating vars
      alias $name=\\"_type=$name Type::TrapAssign declare -A\\"
    ;;
  esac
}

Type::InitializeStatic() {
  local name=\\"$1\\"

  Type::Initialize \\"$name\\" static
}

Type::Construct() {
  local type=\\"$1\\"
  local typeSanitized=$(String::SanitizeForVariableName $type)
  local assignToVariable=\\"$2\\"

  if [[ ! -z \\"\${__constructor_recursion+x}\\" ]]
  then
    __constructor_recursion=$(( \${__constructor_recursion} + 1 ))
  fi

  local -A constructedType=( [__object_type]=\\"$type\\" )
  # else
  #   echo \\"$assignToVariable[__object_type]=\\\\\\"$type\\\\\\"\\"
  # fi

  if Variable::Exists \\"__\${typeSanitized}_property_names\\"
  then
    local propertyIndexesIndirect=\\"__\${typeSanitized}_property_names[@]\\"
    local -i propertyIndex=0
    local propertyName
    for propertyName in \\"\${!propertyIndexesIndirect}\\"
    do
      # local propertyNameIndirect=__\${typeSanitized}_property_names[$propertyIndex]
      # local propertyName=\\"\${!propertyNameIndirect}\\"

      local propertyTypeIndirect=__\${typeSanitized}_property_types[$propertyIndex]
      local propertyType=\\"\${!propertyTypeIndirect}\\"

      local defaultValueIndirect=__\${typeSanitized}_property_defaults[$propertyIndex]
      local defaultValue=\\"\${!defaultValueIndirect}\\"

      if [[ $propertyType == 'boolean' ]] && [[ \\"$defaultValue\\" == 'false' || \\"$defaultValue\\" == 'true' ]]
      then
        defaultValue=\\"\${__primitive_extension_fingerprint__boolean}:$defaultValue\\"
      fi

      local constructedPropertyDefinition=\\"$defaultValue\\"

      DEBUG Log \\"iterating type: \${typeSanitized}, property: [$propertyIndex] $propertyName = $defaultValue\\"

      ## AUTOMATICALLY CONSTRUCTS THE PROPERTIES:
      # case \\"$propertyType\\" in
      #   'array'|'map'|'string'|'integer'|'integerArray') ;;
      #       # 'integer') constructedPropertyDefinition=\\"\${__integer_fingerprint}$defaultValue\\" ;;
      #       # 'integerArray') constructedPropertyDefinition=\\"\${__integer_array_fingerprint}$defaultValue\\" ;;
      #   * )
      #     if [[ -z \\"$defaultValue\\" && \\"$__constructor_recursion\\" -lt 15 ]]
      #     then
      #       constructedPropertyDefinition=$(Type::Construct \\"$propertyType\\")
      #     fi
      #   ;;
      # esac

      if [[ ! -z \\"$constructedPropertyDefinition\\" ]]
      then
        ## initialize non-empty fields

        DEBUG Log \\"Will exec: constructedType+=( [\\\\\\"$propertyName\\\\\\"]=\\\\\\"$constructedPropertyDefinition\\\\\\" )\\"
        constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )
        # eval 'constructedType+=( [\\"$propertyName\\"]=\\"$constructedPropertyDefinition\\" )'
      fi

      propertyIndex+=1
    done
  fi

  if [[ -z \\"$assignToVariable\\" ]]
  then
    Variable::PrintDeclaration constructedType
  else
    local constructedIndex
    for constructedIndex in \\"\${!constructedType[@]}\\"
    do
      eval \\"$assignToVariable[\\\\\\"\\\\$constructedIndex\\\\\\"]=\\\\\\"\\\\\${constructedType[\\\\\\"\\\\$constructedIndex\\\\\\"]}\\\\\\"\\"
    done
  fi
}

alias new='Type::Construct'
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/command.sh 1`] = `
"# no dependencies

Command::GetType() {
  local name=\\"$1\\"
  local typeMatch=$(type -t \\"$name\\" 2> /dev/null || true)
  echo \\"$typeMatch\\"
}

Command::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" || \\"$typeMatch\\" == \\"function\\" || \\"$typeMatch\\" == \\"builtin\\" ]]
}

Alias::Exists(){
  local name=\\"$1\\"
  local typeMatch=$(Command::GetType \\"$name\\")
  [[ \\"$typeMatch\\" == \\"alias\\" ]]
}

Function::Exists(){
  local name=\\"$1\\"
  declare -f \\"$name\\" &> /dev/null
}

Function::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'function' \\"$startsWith\\" || true
}

Function::InjectCode() {
  local functionName=\\"$1\\"
  local injectBefore=\\"$2\\"
  local injectAfter=\\"$3\\"
  local body=$(declare -f \\"$functionName\\")
  body=\\"\${body#*{}\\" # trim start
  body=\\"\${body%\\\\}}\\" # trim end
  local enter=$'\\\\n'
  eval \\"\${functionName}() { \${enter}\${injectBefore}\${body}\${injectAfter}\${enter} }\\"
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/exception.sh 1`] = `
"namespace util/exception
import String/GetSpaces String/SlashReplacement UI/Color UI/Console

#########################
### HANDLE EXCEPTIONS ###
#########################

trap \\"__EXCEPTION_TYPE__=\\\\\\"\\\\$_\\\\\\" command_not_found_handle \\\\$? \\\\$BASH_COMMAND\\" ERR
set -o errtrace  # trace ERR through 'time command' and other functions

# unalias throw 2> /dev/null || true
unset -f throw 2> /dev/null || true
alias throw=\\"__EXCEPTION_TYPE__=\\\\\${e:-Manually invoked} command_not_found_handle\\"

Exception::CustomCommandHandler() {
  ## this method can be overridden to create a custom, unknown command handler
  return 1
}

Exception::FillExceptionWithTraceElements() {
  local IFS=$'\\\\n'
  for traceElement in $(Exception::DumpBacktrace \${skipBacktraceCount:-3})
  do
    exception+=( \\"$traceElement\\" )
  done
}

command_not_found_handle() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  # ignore the error from the catch subshell itself
  if [[ \\"$*\\" = '( set -'*'; true'* ]] ## TODO: refine with a regex and test
  then
    return 0
  fi

  Exception::CustomCommandHandler \\"$@\\" && return 0 || true

  local exit_code=\\"\${1}\\"
  shift || true # there might have not been any parameter, in which case \\"shift\\" would fail
  local script=\\"\${BASH_SOURCE[1]#./}\\"
  local lineNo=\\"\${BASH_LINENO[0]}\\"
  local undefinedObject=\\"$*\\"
  local type=\\"\${__EXCEPTION_TYPE__:-\\"Undefined command\\"}\\"

  if [[ \\"$undefinedObject\\" == \\"(\\"*\\")\\" ]]
  then
    type=\\"Subshell returned a non-zero value\\"
  fi

  if [[ -z \\"$undefinedObject\\" ]]
  then
    undefinedObject=\\"$type\\"
  fi

  if [[ $__oo__insideTryCatch -gt 0 ]]
  then
    subject=level3 Log \\"inside Try No.: $__oo__insideTryCatch\\"

    if [[ ! -s $__oo__storedExceptionLineFile ]]; then
      echo \\"$lineNo\\" > $__oo__storedExceptionLineFile
    fi
    if [[ ! -s $__oo__storedExceptionFile ]]; then
      echo \\"$undefinedObject\\" > $__oo__storedExceptionFile
    fi
    if [[ ! -s $__oo__storedExceptionSourceFile ]]; then
      echo \\"$script\\" > $__oo__storedExceptionSourceFile
    fi
    if [[ ! -s $__oo__storedExceptionBacktraceFile ]]; then
      Exception::DumpBacktrace 2 > $__oo__storedExceptionBacktraceFile
    fi

    return 1 # needs to be return 1
  fi

  if [[ $BASH_SUBSHELL -ge 25 ]] ## TODO: configurable
  then
    echo \\"ERROR: Call stack exceeded (25).\\"
    Exception::ContinueOrBreak || exit 1
  fi

  local -a exception=( \\"$lineNo\\" \\"$undefinedObject\\" \\"$script\\" )

  Exception::FillExceptionWithTraceElements

  Console::WriteStdErr
  Console::WriteStdErr \\" $(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Bold)UNCAUGHT EXCEPTION: $(UI.Color.LightRed)\${type} $(UI.Color.Yellow)$(UI.Color.Italics)(\${exit_code})$(UI.Color.Default)\\"
  Exception::PrintException \\"\${exception[@]}\\"

  Exception::ContinueOrBreak
}

Exception::PrintException() {
  #    [...rest] exception
  local -a exception=(\\"$@\\")

  local -i backtraceIndentationLevel=\${backtraceIndentationLevel:-0}

  local -i counter=0
  local -i backtraceNo=0

  local -a backtraceLine
  local -a backtraceCommand
  local -a backtraceFile

  #for traceElement in Exception::GetLastException
  while [[ $counter -lt \${#exception[@]} ]]
  do
    backtraceLine[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceCommand[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1
    backtraceFile[$backtraceNo]=\\"\${exception[$counter]}\\"
    counter+=1

    backtraceNo+=1
  done

  local -i index=1

  while [[ $index -lt $backtraceNo ]]
  do
    Console::WriteStdErr \\"$(Exception::FormatExceptionSegment \\"\${backtraceFile[$index]}\\" \\"\${backtraceLine[$index]}\\" \\"\${backtraceCommand[($index - 1)]}\\" $(( $index + $backtraceIndentationLevel )) )\\"
    index+=1
  done
}

Exception::CanHighlight() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  if [[ \\"$errLine\\" == *\\"$stringToMarkWithoutSlash\\"* ]]
  then
    return 0
  else
    return 1
  fi
}

Exception::HighlightPart() {
  #    [string] errLine
  #    [string] stringToMark
  local errLine=\\"$1\\"
  local stringToMark=\\"$2\\"

  # Workaround for a Bash bug that causes string replacement to fail when a \\\\ is in the string
  local stringToMarkWithoutSlash=\\"$(String::ReplaceSlashes \\"$stringToMark\\")\\"
  errLine=\\"$(String::ReplaceSlashes \\"$errLine\\")\\"

  local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
  local underlinedObjectInLine=\\"\${errLine/$stringToMarkWithoutSlash/$underlinedObject}\\"

  # Bring back the slash:
  underlinedObjectInLine=\\"$(String::RestoreSlashes \\"$underlinedObjectInLine\\")\\"

  # Trimming:
  underlinedObjectInLine=\\"\${underlinedObjectInLine#\\"\${underlinedObjectInLine%%[![:space:]]*}\\"}\\" # \\"

  echo \\"$underlinedObjectInLine\\"
}

Exception::GetUnderlinedPart() {
  #    [string] stringToMark
  local stringToMark=\\"$1\\"

  echo \\"$(UI.Color.LightGreen)$(UI.Powerline.RefersTo) $(UI.Color.Magenta)$(UI.Color.Underline)$stringToMark$(UI.Color.White)$(UI.Color.NoUnderline)\\"
}

Exception::FormatExceptionSegment() {
  local script=\\"$1\\"
  local -i lineNo=\\"$2\\"
  local stringToMark=\\"$3\\"
  local -i callPosition=\\"\${4:-1}\\"
  #    [string] script
  #    [integer] lineNo
  #    [string] stringToMark
  #    [integer] callPosition=1

  local errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  local originalErrLine=\\"$errLine\\"

  local -i linesTried=0

  ## TODO: when line ends with slash \\\\ it is a multiline statement
  ## TODO: when eval or alias
  # In case it's a multiline eval, sometimes bash gives a line that's offset by a few
  while [[ $linesTried -lt 5 && $lineNo -gt 0 ]] && ! Exception::CanHighlight \\"$errLine\\" \\"$stringToMark\\"
  do
    linesTried+=1
    lineNo+=-1
    errLine=\\"$(sed \\"\${lineNo}q;d\\" \\"$script\\")\\"
  done

  # Cut out the path, leave the script name
  script=\\"\${script##*/}\\"

  local prefix=\\"   $(UI.Powerline.Branch)$(String::GetSpaces $(($callPosition * 3 - 3)) || true) \\"

  if [[ $linesTried -ge 5 ]]
  then
    # PRINT THE ORGINAL OBJECT AND ORIGINAL LINE #
    #local underlinedObject=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"
    local underlinedObject=\\"$(Exception::GetUnderlinedPart \\"$stringToMark\\")\\"
    echo \\"\${prefix}$(UI.Color.White)\${underlinedObject}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
    prefix=\\"$prefix$(UI.Powerline.Fail) \\"
    errLine=\\"$originalErrLine\\"
  fi

  local underlinedObjectInLine=\\"$(Exception::HighlightPart \\"$errLine\\" \\"$stringToMark\\")\\"

  echo \\"\${prefix}$(UI.Color.White)\${underlinedObjectInLine}$(UI.Color.Default) [$(UI.Color.Blue)\${script}:\${lineNo}$(UI.Color.Default)]\\"
}

Exception::ContinueOrBreak() (
  ## TODO: Exceptions that happen in commands that are piped to others do not HALT the execution
  ## TODO: Add a workaround for this ^
  ## probably it's enough to -pipefail, check for a pipe in command_not_found - and if yes - return 1

  # if in a terminal
  if [ -t 0 ]
  then
    trap \\"stty sane; exit 1\\" INT
    Console::WriteStdErr
    Console::WriteStdErr \\" $(UI.Color.Yellow)$(UI.Powerline.Lightning)$(UI.Color.White) Press $(UI.Color.Bold)[CTRL+C]$(UI.Color.White) to exit or $(UI.Color.Bold)[Return]$(UI.Color.White) to continue execution.\\"
    read -s
    Console::WriteStdErr \\"$(UI.Color.Blue)$(UI.Powerline.Cog)$(UI.Color.White)  Continuing...$(UI.Color.Default)\\"
    return 0
  else
    Console::WriteStdErr
    exit 1
  fi
)

Exception::DumpBacktrace() {
  local -i startFrom=\\"\${1:-1}\\"
  #    [integer] startFrom=1
  # inspired by: http://stackoverflow.com/questions/64786/error-handling-in-bash

  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local -i i=0

  while caller $i > /dev/null
  do
    if (( $i + 1 >= $startFrom ))
    then
      local -a trace=( $(caller $i) )

      echo \\"\${trace[0]}\\"
      echo \\"\${trace[1]}\\"
      echo \\"\${trace[@]:2}\\"
    fi
    i+=1
  done
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/exits.sh 1`] = `
"#!/usr/bin/env bash
#
# exits
#
# Those values are come from /usr/include/sysexits.h
#

# successful termination
Util_ExitCode_OK=0
Util_ExitCode_USAGE=64  # command line usage error
Util_ExitCode_DATAERR=65  # data format error
Util_ExitCode_NOINPUT=66  # cannot open input
Util_ExitCode_NOUSER=67  # addressee unknown
Util_ExitCode_NOHOST=68  # host name unknown
Util_ExitCode_UNAVAILABLE=69  # service unavailable
Util_ExitCode_SOFTWARE=70  # internal software error
Util_ExitCode_OSERR=71  # system error (e.g., can't fork)
Util_ExitCode_OSFILE=72  # critical OS file missing
Util_ExitCode_CANTCREAT=73  # can't create (user) output file
Util_ExitCode_IOERR=74  # input/output error
Util_ExitCode_TEMPFAIL=75  # temp failure; user is invited to retry
Util_ExitCode_PROTOCOL=76  # remote error in protocol
Util_ExitCode_NOPERM=77  # permission denied
Util_ExitCode_CONFIG=78  # configuration error
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/log.sh 1`] = `
"import util/bash4
import UI/Color UI/Console

declare -Ag __oo__logScopes
declare -Ag __oo__logScopeOutputs
declare -Ag __oo__logDisabledFilter
declare -Ag __oo__loggers

Log::NameScope() {
  local scopeName=\\"$1\\"
  local script=\\"\${BASH_SOURCE[1]}\\"
  __oo__logScopes[\\"$script\\"]=\\"$scopeName\\"
}

Log::AddOutput() {
  local scopeName=\\"$1\\"
  local outputType=\\"\${2:-STDERR}\\"
  __oo__logScopeOutputs[\\"$scopeName\\"]+=\\"$outputType;\\"
}

Log::ResetOutputsAndFilters() {
  local scopeName=\\"$1\\"
  unset __oo__logScopeOutputs[\\"$scopeName\\"]
  unset __oo__logDisabledFilter[\\"$scopeName\\"]
}

Log::ResetAllOutputsAndFilters() {
  unset __oo__logScopeOutputs
  unset __oo__logDisabledFilter
  declare -Ag __oo__logScopeOutputs
  declare -Ag __oo__logDisabledFilter
}

Log::DisableFilter() {
  __oo__logDisabledFilter[\\"$1\\"]=true
}

Log() {
  local callingFunction=\\"\${FUNCNAME[1]}\\"
  local callingScript=\\"\${BASH_SOURCE[1]}\\"
  local scope
  if [[ ! -z \\"\${__oo__logScopes[\\"$callingScript\\"]}\\" ]]
  then
    scope=\\"\${__oo__logScopes[\\"$callingScript\\"]}\\"
  else # just the filename without extension
    scope=\\"\${callingScript##*/}\\"
    scope=\\"\${scope%.*}\\"
  fi
  local loggerList
  local loggers
  local logger
  local logged

  if [[ ! -z \\"$subject\\" ]]
  then
    if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$subject\\"]}\\"
    elif [[ ! -z \\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\" ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$subject\\"]}\\"
    fi

    loggers=( \${loggerList//;/ } )
    for logger in \\"\${loggers[@]}\\"
    do
      subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      logged=true
    done
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope/$callingFunction\\"]} == true || \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope/$callingFunction\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
          subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
          logged=true
      done
    fi
  fi

  if [[ ! -z \\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\" ]]
  then
    if [[ -z $logged ]] || [[ \${__oo__logDisabledFilter[\\"$scope\\"]} == true ]]
    then
      loggerList=\\"\${__oo__logScopeOutputs[\\"$scope\\"]}\\"
      loggers=( \${loggerList//;/ } )
      for logger in \\"\${loggers[@]}\\"
      do
        subject=\\"\${subject:-LOG}\\" Log::Using \\"$logger\\" \\"$@\\"
      done
    fi
  fi
}

Log::RegisterLogger() {
  local logger=\\"$1\\"
  local method=\\"$2\\"
  __oo__loggers[\\"$logger\\"]=\\"$method\\"
}

Log::Using() {
  local logger=\\"$1\\"
  shift
  if [[ ! -z \${__oo__loggers[\\"$logger\\"]} ]]
  then
      \${__oo__loggers[\\"$logger\\"]} \\"$@\\"
  fi
}

Logger::DEBUG() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) DEBUG \\"$@\\"
}
Logger::ERROR() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Red) ERROR \\"$@\\"
}
Logger::INFO() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Blue) INFO \\"$@\\"
}
Logger::WARN() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) WARN \\"$@\\"
}
Logger::CUSTOM() {
    Console::WriteStdErr \\"$(UI.Color.Yellow)[\${subject^^}] $(UI.Color.Default)$* \\"
}
Logger::DETAILED() {
    Console::WriteStdErrAnnotated \\"\${BASH_SOURCE[3]##*/}\\" \${BASH_LINENO[2]} $(UI.Color.Yellow) \\"\${subject^^}\\" \\"$@\\"
}

Log::RegisterLogger STDERR Console::WriteStdErr
Log::RegisterLogger DEBUG Logger::DEBUG
Log::RegisterLogger ERROR Logger::ERROR
Log::RegisterLogger INFO Logger::INFO
Log::RegisterLogger WARN Logger::WARN
Log::RegisterLogger CUSTOM Logger::CUSTOM
Log::RegisterLogger DETAILED Logger::DETAILED

alias namespace=\\"Log::NameScope\\"
namespace oo/log
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/namedParameters.sh 1`] = `
"namespace oo/type
import util/variable

# depends on modules: variable, exception

declare -g ref=D10F7FB728364261BB50A7E818D537C4
declare -g var=A04FB7D7594E479B8CD8D90C5014E37A

# TODO: required parameters
Variable::TrapAssignNumberedParameter() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift
  #  Log \\"TRAP: \${commandWithArgs[@]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* || \\"$command\\" == \\"_isRequired=\\"* || \\"$command\\" == \\"_isReadOnly=\\"*  || \\"$command\\" == \\"_noHandle=\\"* || \\"$command\\" == \\"_isGlobal=\\"* ]]
  then
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __assign_next=true
    DEBUG subject=\\"parameters-assign\\" Log \\"Will assign next one\\"

    local nextAssignment=$(( \${__assign_paramNo:-0} + 1 ))
    if [[ \\"\${!nextAssignment-}\\" == \\"$ref:\\"* ]]
    then
      DEBUG subject=\\"parameters-reference\\" Log \\"next param ($nextAssignment) is an object reference\\"
      __assign_parameters=\\"-n\\"
    ## TODO: type checking
    else
      __assign_parameters=\\"\\"
    fi
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* || $varDeclaration == '\${__assign'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"
  # TODO: checking for parameter existence or default value

  if [[ \\"\${__assign_varType:-null}\\" != \\"null\\" ]]
  then
    local requiredType=\\"$__assign_varType\\" ## TODO: use this information
    [[ $__assign_parameters == '-n' ]] && __assign_varType=\\"reference\\"

    DEBUG subject=\\"parameters-setting\\" Log \\"SETTING: [$__assign_varType] $__assign_varName = \\\\$$__assign_paramNo [rq:$__assign_valueRequired]\\" # [val:\${!__assign_paramNo}]
    # subject=\\"parameters-setting\\" Log --

    if [[ \\"$__assign_valueRequired\\" == 'true' && -z \\"\${!__assign_paramNo+x}\\" ]]
    then
      e=\\"Value is required for the parameter $__assign_varName ($__assign_paramNo) of type [$__assign_varType]\\" throw
    fi

    unset __assign_valueRequired __assign_valueReadOnly

    local indirectAccess=\\"$__assign_paramNo\\"

    if [[ \\"\${!indirectAccess-}\\" == \\"$var:\\"* ]]
    then
      local realVarName=\\"\${!indirectAccess#*$var:}\\"
      if Variable::Exists \\"$realVarName\\"
      then
        local __declaration
        local __declaration_type
        Variable::ExportDeclarationAndTypeToVariables \\"$realVarName\\" __declaration
        # Log realVarName \\"\${!indirectAccess#*$var:}\\" type \\"$declaration_type vs $__assign_varType\\" declaration: \\"$__declaration\\" vs \\"$(Variable::PrintDeclaration \\"$realVarName\\")\\"
        indirectAccess=__declaration

        if [[ \\"$__declaration_type\\" != \\"$__assign_varType\\" && \\"$__assign_varType\\" != 'params' && \\"$__assign_varType\\" != 'rest' ]]
        then
          e=\\"Passed in variable: ($__assign_paramNo) $__assign_varName is of different than its required type [required: $__assign_varType] [actual: $__declaration_type]\\" throw
        fi
      fi
    fi

    case \\"$__assign_varType\\" in
      'params')
      # passing array:
        eval \\"__assign_arrLength=$__assign_arrLength\\"
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo:$__assign_arrLength}\\\\\\" )\\"

        ## TODO: foreach param expand $var: indirectAccess
        __assign_paramNo+=$(($__assign_arrLength - 1))
        unset __assign_arrLength
      ;;
      'rest')
      ## TODO: foreach param expand $var: indirectAccess
        eval \\"$__assign_varName=( \\\\\\"\\\\\${@:$__assign_paramNo}\\\\\\" )\\"
      ;;
      'boolean')
        DEBUG Log passed \\"\${!indirectAccess}\\", default \\"\${__assign_varValue}\\"
        local boolean_fingerprint=\\"\${__primitive_extension_fingerprint__boolean:+__primitive_extension_fingerprint__boolean:}\\"

        if [[ ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"\${boolean_fingerprint}\\"* ]]
          then
            __assign_varValue=\\"\${!indirectAccess}\\"
          elif [[ \\"\${!indirectAccess}\\" == 'true' || \\"\${!indirectAccess}\\" == 'false' ]]
          then
            __assign_varValue=\\"\${boolean_fingerprint}\${!indirectAccess}\\"
          else
            __assign_varValue=\\"\${boolean_fingerprint}false\\"
          fi
        elif [[ \\"\${__assign_varValue}\\" == 'true' || \\"\${__assign_varValue}\\" == 'false' ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}\${__assign_varValue}\\"
        elif [[ \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}true\\" && \\"\${__assign_varValue}\\" != \\"\${boolean_fingerprint}false\\" ]]
        then
          __assign_varValue=\\"\${boolean_fingerprint}false\\"
        fi
        eval \\"$__assign_varName=\\\\\\"\${__assign_varValue}\\\\\\"\\"
      ;;
      'string'|'integer'|'reference')
        if [[ \\"$__assign_varType\\" == \\"reference\\" || ! -z \\"\${!indirectAccess-}\\" ]]
        then
          if [[ \\"\${!indirectAccess}\\" == \\"$ref:\\"* ]]
          then
            local refVarName=\\"\${!indirectAccess#*$ref:}\\"
            eval \\"$__assign_varName=$refVarName\\"
          else
            DEBUG Log \\"Will eval $__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
            # escape $indirectAccess with \\\\\\"
            # local escapedAssignment=\\"\${!indirectAccess}\\"
            # escapedAssignment=\\"\${escapedAssignment//\\\\\\"/\\\\\\\\\\\\\\"}\\"
            # execute=\\"$__assign_varName=\\\\\\"$escapedAssignment\\\\\\"\\"
            eval \\"$__assign_varName=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          fi

        # DEBUG subject=\\"parameters-executing\\" Log \\"EXECUTING: $execute\\"
        fi
      ;;
      *) # 'array'|'map'|objects
        if [[ ! -z \\"\${!indirectAccess}\\" ]]
        then
          eval \\"local -$(Variable::GetDeclarationFlagFromType '$__assign_varType') tempMap=\\\\\\"\\\\$$indirectAccess\\\\\\"\\"
          local index
          local value

          ## copy the array / map item by item
          for index in \\"\${!tempMap[@]}\\"
          do
            eval \\"$__assign_varName[\\\\$index]=\\\\\\"\\\\\${tempMap[\\\\$index]}\\\\\\"\\"
          done

          unset index value tempMap
        fi
      ;;
    esac

    unset __assign_varType
    unset __assign_parameters

    if [[ \\"$__assign_valueGlobal\\" == \\"true\\" ]]; then
      local declaration=\\"$(declare -p $__assign_varName)\\"
      declaration=\\"\${declaration/declare/declare -g}\\"
      eval \\"$declaration\\"
    fi
    unset __assign_valueGlobal

    if [[ \\"$__assign_noHandle\\" != 'true' && ! -z \${__oo__bootstrapped+x} ]] && declare -f 'Type::CreateHandlerFunction' &> /dev/null
    then
      DEBUG Log \\"Will create handle for $__assign_varName\\"
      Type::CreateHandlerFunction \\"$__assign_varName\\" # 2> /dev/null || true
    fi
  fi

  if [[ \\"$command\\" != \\"local\\" || \\"\${__assign_next-}\\" != \\"true\\" ]]
  then
    __assign_normalCodeStarted+=1

    DEBUG subject=\\"parameters-nopass\\" Log \\"NOPASS \${commandWithArgs[*]}\\"
    DEBUG subject=\\"parameters-nopass\\" Log \\"normal code count ($__assign_normalCodeStarted)\\"
  # subject=\\"parameters-nopass\\" Log --
  else
    unset __assign_next

    __assign_normalCodeStarted=0
    __assign_varName=\\"$varName\\"
    __assign_varValue=\\"$varValue\\"
    __assign_varType=\\"$__capture_type\\"
    __assign_arrLength=\\"$__capture_arrLength\\"
    __assign_valueRequired=\\"$__capture_valueRequired\\"
    __assign_valueReadOnly=\\"$__capture_valueReadOnly\\"
    __assign_valueGlobal=\\"$__capture_valueGlobal\\"
    __assign_noHandle=\\"$__capture_noHandle\\"

    DEBUG subject=\\"parameters-pass\\" Log \\"PASS \${commandWithArgs[*]}\\"
    # subject=\\"parameters-pass\\" Log --

    __assign_paramNo+=1
  fi
}

Variable::InTrapCaptureParameters() {
  DEBUG subject=\\"parameters\\" Log \\"Capturing Type $_type\\"
  # subject=\\"parameters\\" Log --

  __capture_type=\\"$_type\\"
  __capture_arrLength=\\"\${l-'\${#@}'}\\"
  __capture_valueRequired=\\"\${_isRequired-false}\\"
  __capture_valueReadOnly=\\"\${_isReadOnly-false}\\"
  __capture_valueGlobal=\\"\${_isGlobal-false}\\"
  __capture_noHandle=\\"\${_noHandle-false}\\"
}

## ARGUMENT RESOLVERS ##

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Variable::TrapAssign='Variable::InTrapCaptureParameters; local -i __assign_normalCodeStarted=0; trap \\"declare -i __assign_paramNo; Variable::TrapAssignNumberedParameter \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__assign_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __assign_varType __assign_varName __assign_varValue __assign_paramNo __assign_valueRequired __assign_valueReadOnly __assign_valueGlobal __assign_noHandle\\" DEBUG; true; true; '
alias [reference]='_type=reference Variable::TrapAssign local -n'
alias Variable::TrapAssignLocal='Variable::TrapAssign local \${__assign_parameters}'
alias [string]=\\"_type=string Variable::TrapAssignLocal\\"
# alias [string]=\\"_type=string Variable::TrapAssign local \\\\\${__assign_parameters}\\"
alias [integer]='_type=integer Variable::TrapAssign local \${__assign_parameters:--i}'
alias [array]='_type=array Variable::TrapAssign local \${__assign_parameters:--a}'
alias [map]='_type=map Variable::TrapAssign local \${__assign_parameters:--A}'
# TODO: alias [integerArray]='_type=array Variable::TrapAssign local \${__assign_parameters:--ai}'
alias [boolean]='_type=boolean Variable::TrapAssignLocal'
alias [string[]]='_type=params Variable::TrapAssignLocal'
alias [string[1]]='l=1 _type=params Variable::TrapAssignLocal'
alias [string[2]]='l=2 _type=params Variable::TrapAssignLocal'
alias [string[3]]='l=3 _type=params Variable::TrapAssignLocal'
alias [string[4]]='l=4 _type=params Variable::TrapAssignLocal'
alias [string[5]]='l=5 _type=params Variable::TrapAssignLocal'
alias [string[6]]='l=6 _type=params Variable::TrapAssignLocal'
alias [string[7]]='l=7 _type=params Variable::TrapAssignLocal'
alias [string[8]]='l=8 _type=params Variable::TrapAssignLocal'
alias [string[9]]='l=9 _type=params Variable::TrapAssignLocal'
alias [string[10]]='l=10 _type=params Variable::TrapAssignLocal'
alias [...rest]='_type=rest Variable::TrapAssignLocal'
alias @required='_isRequired=true'
alias @handleless='_noHandle=true'
alias @global='_isGlobal=true'
# TODO: alias @readonly='_isReadOnly=true '
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/pipe.sh 1`] = `
"# no dependencies

Pipe::Capture() {
  read -r -d '' $1 || true
}

Pipe::CaptureFaithful() {
  IFS= read -r -d '' $1 || true
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/test.sh 1`] = `
"import util/class util/tryCatch UI/Cursor

class:Test() {
  private UI.Cursor onStartCursor
  private string groupName
  public string errors
  # public boolean errors = false

  Test.Start() {
    [string] verb
    [string] description

    this onStartCursor capture
    echo \\"$(UI.Color.Yellow)$(UI.Powerline.PointingArrow) $(UI.Color.Yellow)[$(UI.Color.LightGray)$(UI.Color.Bold)TEST$(UI.Color.NoBold)$(UI.Color.Yellow)] $(UI.Color.White)\${verb} \${description}$(UI.Color.Default)\\"
    @return
  }

  Test.OK() {
    [string] printInPlace=true

    [[ $printInPlace == true ]] && this onStartCursor restore

    echo \\"$(UI.Color.Green)$(UI.Powerline.OK) $(UI.Color.Yellow)[ $(UI.Color.Green)$(UI.Color.Bold)OK$(UI.Color.NoBold) $(UI.Color.Yellow)]$(UI.Color.Default)\\"
    @return
  }

  Test.EchoedOK() {
    this OK false
  }

  Test.Fail() {
    [string] line
    [string] error
    [string] source
    echo \\"$(UI.Color.Red)$(UI.Powerline.Fail) $(UI.Color.Yellow)[$(UI.Color.Red)$(UI.Color.Bold)FAIL$(UI.Color.NoBold)$(UI.Color.Yellow)]$(UI.Color.Default) in $(UI.Color.Yellow)\${source}$(UI.Color.Default):$(UI.Color.Blue)\${line}$(UI.Color.Default) $(UI.Powerline.RefersTo) $(UI.Color.Red)\${error}$(UI.Color.Default)\\"
    @return
  }

  Test.DisplaySummary() {
    if [[ $(this errors) == true ]]
    # if this errors
    then
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Red)There were errors $(UI.Color.Default)$(UI.Powerline.Lightning)\\"
      this errors = false
    else
      echo \\"$(UI.Powerline.ArrowLeft) $(UI.Color.Magenta)Completed [$(UI.Color.White)$(this groupName)$(UI.Color.Magenta)]: $(UI.Color.Default)$(UI.Color.Yellow)Test group completed successfully $(UI.Color.Default)$(UI.Powerline.ThumbsUp)\\"
    fi
    @return
  }

  Test.NewGroup() {
    [string] groupName

    echo \\"$(UI.Powerline.ArrowRight)\\" $(UI.Color.Magenta)Testing [$(UI.Color.White)\${groupName}$(UI.Color.Magenta)]: $(UI.Color.Default)

    this groupName = \\"$groupName\\"

    @return
  }
}

Type::InitializeStatic Test

### TODO: special case for static classes
### for storage use a generated variable name (hash of class name?)
### for execution use class' name, e.g. Test Start

alias describe='Test NewGroup'
alias summary='Test DisplaySummary'
alias caught=\\"echo \\\\\\"CAUGHT: $(UI.Color.Red)\\\\$__BACKTRACE_COMMAND__$(UI.Color.Default) in \\\\$__BACKTRACE_SOURCE__:\\\\$__BACKTRACE_LINE__\\\\\\"\\"
alias it=\\"Test Start it\\"
alias expectPass=\\"Test OK; catch { Test errors = true; Test Fail \\\\\\"\\\\\${__EXCEPTION__[@]}\\\\\\"; }\\"
alias expectOutputPass=\\"Test EchoedOK; catch { Test errors = true; Test Fail; }\\"
alias expectFail='catch { caught; Test EchoedOK; }; test $? -eq 1 && Test errors = false; '
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/tryCatch.sh 1`] = `
"# no dependencies
declare -ig __oo__insideTryCatch=0
declare -g __oo__presetShellOpts=\\"$-\\"

# in case try-catch is nested, we set +e before so the parent handler doesn't catch us instead
alias try='[[ $__oo__insideTryCatch -eq 0 ]] || __oo__presetShellOpts=\\"$(echo $- | sed 's/[is]//g')\\"; __oo__insideTryCatch+=1; set +e; ( set -e; true; '
alias catch='); declare __oo__tryResult=$?; __oo__insideTryCatch+=-1; [[ $__oo__insideTryCatch -lt 1 ]] || set -\${__oo__presetShellOpts:-e} && Exception::Extract $__oo__tryResult || '

Exception::SetupTemp() {
  declare -g __oo__storedExceptionLineFile=\\"$(mktemp -t stored_exception_line.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionSourceFile=\\"$(mktemp -t stored_exception_source.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionBacktraceFile=\\"$(mktemp -t stored_exception_backtrace.$$.XXXXXXXXXX)\\"
  declare -g __oo__storedExceptionFile=\\"$(mktemp -t stored_exception.$$.XXXXXXXXXX)\\"
}

Exception::CleanUp() {
  local exitVal=$?
  rm -f $__oo__storedExceptionLineFile $__oo__storedExceptionSourceFile $__oo__storedExceptionBacktraceFile $__oo__storedExceptionFile || exit 1
  exit $exitVal
}

Exception::ResetStore() {
  > $__oo__storedExceptionLineFile
  > $__oo__storedExceptionFile
  > $__oo__storedExceptionSourceFile
  > $__oo__storedExceptionBacktraceFile
}

Exception::GetLastException() {
  if [[ -s $__oo__storedExceptionFile ]]
  then
    cat $__oo__storedExceptionLineFile
    cat $__oo__storedExceptionFile
    cat $__oo__storedExceptionSourceFile
    cat $__oo__storedExceptionBacktraceFile

    Exception::ResetStore
  else
    echo -e \\"\${BASH_LINENO[1]}\\\\n \\\\n\${BASH_SOURCE[2]#./}\\"
  fi
}

Exception::Extract() {
  local retVal=$1
  unset __oo__tryResult

  if [[ $retVal -gt 0 ]]
  then
    local IFS=$'\\\\n'
    __EXCEPTION__=( $(Exception::GetLastException) )

    local -i counter=0
    local -i backtraceNo=0

    while [[ $counter -lt \${#__EXCEPTION__[@]} ]]
    do
      __BACKTRACE_LINE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_COMMAND__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      __BACKTRACE_SOURCE__[$backtraceNo]=\\"\${__EXCEPTION__[$counter]}\\"
      counter+=1
      backtraceNo+=1
    done

    return 1 # so that we may continue with a \\"catch\\"
  fi
  return 0
}

Exception::SetupTemp
trap Exception::CleanUp EXIT INT TERM
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/type.sh 1`] = `
"namespace util/type

import util/bash4
import Array/Contains String/SanitizeForVariable
import util/namedParameters util/pipe util/variable util/command

declare -g __primitive_extension_declaration=2D6A822E
declare -g __primitive_extension_fingerprint__boolean=\${__primitive_extension_declaration}36884C70843578D37E6773C4
declare -g __return_separator=52A586A48E074BB6812DCFDC790841F5
declare -g __oo__type_handler_functions=()
declare -g __oo__variableMethodPrefix=\\"$var:\\"

# /**
#   * Code like: Variable::ExportDeclarationAndTypeToVariables
#   * TODO: Merge parts
#   */
Type::GetTypeOfVariable() {
  local variableName=\\"$1\\"
  local dereferrence=\\"\${2:-true}\\"

  local regex=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p \\"\${variableName}\\" 2> /dev/null || true)

  [[ -z \\"$definition\\" ]] && e=\\"Variable not defined\\" throw
  if [[ \\"$definition\\" =~ $regex ]]
  then
    local variableType
    local primitiveType=\${BASH_REMATCH[1]}

    local objectTypeIndirect=\\"$variableName[__object_type]\\"
    if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
    then
      DEBUG Log \\"typeof $variableName: Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
      variableType=\\"\${!objectTypeIndirect}\\"
    else
      variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
      DEBUG Log \\"typeof $variableName: Primitive Type $primitiveType Resolved \${variableType}\\"
    fi

    if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
    then
      local dereferrencedVariableName=$(Variable::PrintDeclaration \\"$variableName\\" false)
      variableType=$(Type::GetTypeOfVariable \\"$dereferrencedVariableName\\")
    fi

    if [[ \\"$variableType\\" == 'string' ]]
    then
      local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
      if [[ ! -z \\"$extensionType\\" ]]
      then
        variableType=\\"$extensionType\\"
      fi
    fi

    DEBUG Log \\"Variable $variableName is typeof $variableType\\"

    echo \\"$variableType\\"
  fi
}

Type::IsPrimitive() {
  local type=\\"$1\\"

  case \\"$type\\" in
    'array'|'map'|'string'|'integer'|'boolean'|'integerArray'|'reference') ## TODO: reference should be resolved
      return 0 ;;
    * )
      return 1 ;;
  esac
}

## Returns a matching __primitive_extension_fingerprint__*
## Or nothing
Type::GetPrimitiveExtensionFromVariable() {
  local variableName=\\"$1\\"

  if [[ \\"\${!variableName}\\" != \\"$__primitive_extension_declaration\\"* ]]
  then
    return
  fi

  local prefix=__primitive_extension_fingerprint__
  local extensionType
  for extensionType in $(Variable::GetAllStartingWith $prefix)
  do
    local fingerprint=\${!extensionType}
    if [[ \\"\${!variableName}\\" == \\"$fingerprint\\"* ]]
    then
      extensionType=\${extensionType##$prefix}
      echo \\"$extensionType\\"
      return
    fi
  done
}

Type::GetPrimitiveExtensionFingerprint() {
  local type=\\"$1\\"

  local fingerprintVariable=\\"__primitive_extension_fingerprint__\${type}\\"
  printf \\"\${!fingerprintVariable}\\"
}

Type::CreateHandlerFunction() {
  local variableName=\\"$1\\"

  if [[ -z $variableName ]]
  then
    subject=WARN Log \\"No variable specified when trying to create a handle.\\"
    return
  fi

  ## don't allow creating a handler if a command/function/alias of such name already exists
  ## unless it is a handler already (keeps track)

  if ! Command::Exists \\"\${__oo__variableMethodPrefix}\${variableName}\\"
  then
    DEBUG Log \\"creating handler for $variableName\\"
    ## declare method with the name of the var ##
    eval \\"\${__oo__variableMethodPrefix}\${variableName}() { Type::Handle $variableName \\\\\\"\\\\$@\\\\\\"; }\\"
    __oo__type_handler_functions+=( \\"\${variableName}\\" )

  elif ! Array::Contains \\"\${variableName}\\" \\"\${__oo__type_handler_functions[@]}\\"
  then
    ## TODO: a way to solve this is to store the original functions
    ## and temporairly override it, returning back to the old formula in @return
    subject=WARN Log \\"Unable to create a handle for '$variableName'. A command of the same name already exists.\\"
  fi

  Type::RunFunctionGarbageCollector
}

Type::RunFunctionGarbageCollector() {
  local -a variables=( $(compgen -A 'variable' || true) )

  local index
  local handler
  for index in \\"\${!__oo__type_handler_functions[@]}\\"
  do
    handler=\\"\${__oo__type_handler_functions[$index]}\\"

    local exists=
    for variable in \\"\${variables[@]}\\"
    do
      # Log \\"comparing: \${variable} == $handler\\"
      [[ \\"$variable\\" == \\"$handler\\" ]] && { exists=1; break; }
    done
    ## unset all the functions that don't have corresponding variables
    if [[ ! -n $exists ]]
    then
      DEBUG Log \\"Unsetting handler for $handler\\"
      unset -f \\"\${__oo__variableMethodPrefix}\${handler}\\"
      unset __oo__type_handler_functions[$index]
    else
      DEBUG Log \\"not deleting: handler and variable exists: \${variable}\\"
    fi
  done
}

Type::InjectThisResolutionIfNeeded() {
  local methodName=\\"$1\\"

  local methodBody=$(declare -f \\"$methodName\\" || true)

  if [[ -z \\"$methodBody\\" ]]
  then
    e=\\"Method $methodName is not defined.\\" throw
    return
  fi

  if [[ \\"$methodBody\\" != *'@resolve:this'* && \\"$methodBody\\" != *'__local_return_self_and_result=false'* ]]
  then
    DEBUG Log \\"Injecting @this resolution to: $methodName\\"
    DEBUG [[ \\"$methodName\\" == \\"Human\\"* ]] && Log \\"$methodBody\\"

    if [[ \\"$methodBody\\" != *'@return'* ]]
    then
      Function::InjectCode \\"$methodName\\" '@resolve:this' '@return'
    else
      Function::InjectCode \\"$methodName\\" '@resolve:this'
    fi
  fi
}

Type::ConvertAllOfTypeToMethodsIfNeeded() {
  local type=\\"$1\\"

  local -a methods=( $(Function::GetAllStartingWith \\"\${type}.\\") )
  local method

  for method in \\"\${methods[@]}\\"
  do
    Type::InjectThisResolutionIfNeeded \\"$method\\"
  done
}

Type::InitializePrimitive() {
  local name=\\"$1\\"

  Type::ConvertAllOfTypeToMethodsIfNeeded \\"$name\\"
}

Type::TrapAndCreate() {
  # USE DEFAULT IFS IN CASE IT WAS CHANGED
  local IFS=$' \\\\t\\\\n'

  local commandWithArgs=( $1 )
  local command=\\"\${commandWithArgs[0]}\\"

  shift

  # Log \\"\${commandWithArgs[*]}\\"

  if [[ \\"$command\\" == \\"trap\\" || \\"$command\\" == \\"l=\\"* || \\"$command\\" == \\"_type=\\"* ]]
  then
    # set +x
    return 0
  fi

  if [[ \\"\${commandWithArgs[*]}\\" == \\"true\\" ]]
  then
    __typeCreate_next=true
    # Console::WriteStdErr \\"Will assign next one\\"
    # set +x
    return 0
  fi

  local varDeclaration=\\"\${commandWithArgs[*]:1}\\"
  if [[ $varDeclaration == '-'* ]]
  then
    varDeclaration=\\"\${commandWithArgs[*]:2}\\"
  fi
  local varName=\\"\${varDeclaration%%=*}\\"

  # var value is only important if making an object later on from it
  local varValue=\\"\${varDeclaration#*=}\\"

  # TODO: make this better, otherwise edge case bug:
  if [[ \\"$varValue\\" == \\"$varName\\" ]]
  then
    # Log \\"equal $varName=$varValue\\"
    local varValue=\\"\\"
  fi

  if [[ ! -z $__typeCreate_varType ]]
  then

    local __primitive_extension_fingerprint__boolean=\${__primitive_extension_fingerprint__boolean:-2D6A822E36884C70843578D37E6773C4}
    # Console::WriteStdErr \\"SETTING $__typeCreate_varName = \\\\$$__typeCreate_paramNo\\"
    # Console::WriteStdErr --
    #Console::WriteStdErr $tempName

    DEBUG Log \\"creating: $__typeCreate_varName ($__typeCreate_varType) = $__typeCreate_varValue\\"

    if [[ -z \\"$__typeCreate_varValue\\" ]]
    then
      case \\"$__typeCreate_varType\\" in
        'array'|'map') eval \\"$__typeCreate_varName=()\\" ;;
        'string') eval \\"$__typeCreate_varName=''\\" ;;
        'integer') eval \\"$__typeCreate_varName=0\\" ;;
        'boolean') eval \\"$__typeCreate_varName=\${__primitive_extension_fingerprint__boolean}:false\\" ;;
        * )
        # Log \\"constructing: $__typeCreate_varName ($__typeCreate_varType) = $(__constructor_recursion=0 Type::Construct $__typeCreate_varType)\\"

          __constructor_recursion=0 Type::Construct \\"$__typeCreate_varType\\" \\"$__typeCreate_varName\\"

          DEBUG Log \\"constructed: $(@get $__typeCreate_varName)\\"
        ;;
      esac
    else
      case \\"$__typeCreate_varType\\" in
        'boolean')
          if [[ \\"\${__typeCreate_varValue}\\" != 'true' && \\"\${__typeCreate_varValue}\\" != 'false' ]]
          then
            __typeCreate_varValue='false'
          fi
          eval \\"$__typeCreate_varName=\\\\\\"\${__primitive_extension_fingerprint__boolean}:\${__typeCreate_varValue}\\\\\\"\\" ;;
      ## TODO: add case of setting value already with fingerprint
        *) ;;
      esac
    fi

    Type::CreateHandlerFunction \\"$__typeCreate_varName\\"

    ## IMPORTANT: TRAP won't work inside a TRAP, so such a constructor couldn't

    # case \\"$__typeCreate_varType\\" in
    #   'array'|'map'|'string'|'integer') ;;
    #   *)
    #     if Function::Exists \${__typeCreate_varType}.constructor
    #     then
    #       # __typeCreate_runConstructor=\${__typeCreate_varName}
    #       # Log __typeCreate_runConstructor $__typeCreate_runConstructor
    #       \${__typeCreate_varName} constructor
    #     fi
    #     # local return
    #     # Object.New $__typeCreate_varType $__typeCreate_varName
    #     # eval \\"$__typeCreate_varName=$return\\"
    #   ;;
    # esac

    # __oo__objects+=( $__typeCreate_varName )

    unset __typeCreate_varType
    unset __typeCreate_varValue
  fi

  if [[ \\"$command\\" != \\"declare\\" || \\"$__typeCreate_next\\" != \\"true\\" ]]
  then
    __typeCreate_normalCodeStarted+=1

  # Console::WriteStdErr \\"NOPASS \${commandWithArgs[*]}\\"
  # Console::WriteStdErr \\"normal code count ($__typeCreate_normalCodeStarted)\\"
  # Console::WriteStdErr --
  else
    unset __typeCreate_next

    __typeCreate_normalCodeStarted=0
    __typeCreate_varName=\\"$varName\\"
    __typeCreate_varValue=\\"$varValue\\"
    __typeCreate_varType=\\"$__capture_type\\"
    __typeCreate_arrLength=\\"$__capture_arrLength\\"

    # Console::WriteStdErr \\"PASS \${commandWithArgs[*]}\\"
    # Console::WriteStdErr --

    __typeCreate_paramNo+=1
  fi
  # set +x
}

Type::CaptureParams() {
    # Console::WriteStdErr \\"Capturing Type $_type\\"
    # Console::WriteStdErr --

    __capture_type=\\"$_type\\"
}

# NOTE: true; true; at the end is required to workaround an edge case where TRAP doesn't behave properly
alias Type::TrapAssign='Type::CaptureParams; declare -i __typeCreate_normalCodeStarted=0; trap \\"declare -i __typeCreate_paramNo; Type::TrapAndCreate \\\\\\"\\\\$BASH_COMMAND\\\\\\" \\\\\\"\\\\$@\\\\\\"; [[ \\\\$__typeCreate_normalCodeStarted -ge 2 ]] && trap - DEBUG && unset __typeCreate_varType __typeCreate_varName __typeCreate_varValue __typeCreate_paramNo\\" DEBUG; true; true; '
alias reference='_type=reference Type::TrapAssign declare -n'
alias string='_type=string Type::TrapAssign declare'
alias boolean='_type=boolean Type::TrapAssign declare'
alias integer='_type=integer Type::TrapAssign declare -i'
alias array='_type=array Type::TrapAssign declare -a'
alias integerArray='_type=integerArray Type::TrapAssign declare -ai'
alias map='_type=map Type::TrapAssign declare -A'
#alias global:reference='_type=reference Type::TrapAssign declare -ng'
#alias global:string='_type=string Type::TrapAssign declare -g'
#alias global:integer='_type=integer Type::TrapAssign declare -ig'
#alias global:array='_type=array Type::TrapAssign declare -ag'
#alias global:map='_type=map Type::TrapAssign declare -Ag'

##############################

# for use in the object's methods
this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:this() {
  __access_private=true Type::Handle this \\"$@\\"
}

var:() {
  Type::Handle \\"$@\\"
  # Type::Handle $1 \\"\${@:2}\\"
}

@return() {
  local variableName=\\"$1\\"
  local thisName=\\"\${2:-this}\\"

  local __return_declaration
  local __return_declaration_type

  ## if not returning anything, just update the self
  if [[ ! -z \\"$variableName\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $variableName __return_declaration
  elif [[ ! -z \\"\${monad+x}\\" ]]
  then
    Variable::ExportDeclarationAndTypeToVariables $thisName __return_declaration
  fi

  if [[ \\"\${__local_return_self_and_result}\\" == \\"true\\" || \\"\${__return_self_and_result}\\" == \\"true\\" ]]
  then
    # Log \\"returning heavy\\"
    local -a __return=(\\"$(Variable::PrintDeclaration $thisName)\\" \\"$__return_declaration\\" \\"$__return_declaration_type\\")

    printf \${__return_separator:-52A586A48E074BB6812DCFDC790841F5}
    Variable::PrintDeclaration __return
    # __modifiedThis=\\"$(Variable::PrintDeclaration this)\\"
  elif [[ \\"\${#__return_declaration}\\" -gt 0 ]]
  then
    echo \\"$__return_declaration\\"
  fi

  Type::RunFunctionGarbageCollector
}

@return:value() {
  local value=\\"$@\\"
  @return value
}

# ------------------------ #
# STACK HANDLING #
# ------------------------ #

Type::ExecuteMethod() {
  local type=\\"$1\\"
  local variableName=\\"$2\\"
  local method=\\"$3\\"

  shift; shift; shift;

  Type::InjectThisResolutionIfNeeded \\"$type.$method\\"

  thisReference=$variableName thisReferenceType=\\"$type\\" $type.$method \\"$@\\"
}

# /**
#  * used inside Type::Handle() for getting out the return value and updating this
#  */
Type::RunCurrentStack() {
  DEBUG Log \\"will execute: $method (\${params[@]})\\"

  if [[ ! -z \\"$returnValueDefinition\\" && \\"$affectTheInitialVariable\\" == 'false' ]]
  then
    local -$(Variable::GetDeclarationFlagFromType $returnValueType) \\"__self=$returnValueDefinition\\"
    variableName=__self
  fi

  # Log \\"Will assign: result=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\")\\"
  local resultString=$(__return_self_and_result=true Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"$method\\" \\"\${params[@]}\\" || { local falseBool=\\"\${__primitive_extension_fingerprint__boolean}:false\\"; __return_self_and_result=true @return falseBool $variableName; })
  # || echo \\"\${__return_separator}specialBool:\${__primitive_extension_fingerprint__boolean}:false\\"

  ## TODO: some problem here sometimes
  DEBUG Log \\"Result string: START | $resultString | END\\"

  local echoed=

  if [[ -z \\"$resultString\\" || \\"$resultString\\" != *\\"$__return_separator\\"* ]]
  then
    ## if resultString does not contain return_separator, use all as returnString and nothing as echo
    ## TODO: debug these situations if all ok.
    # theoretically, this is when no @return is present
    # or when no return separator provided - we use the echoed output as the result
    #
    ## implicit \\"string\\"
    local -a result=( \\"$(@get $variableName)\\" \\"$(@get resultString)\\" \\"string\\" )
  else
    # echo everything before the first occurrence of the separator
    echoed=\\"\${resultString%%$__return_separator*}\\"

    DEBUG [[ ! -z \\"$echoed\\" ]] && Log \\"Echoed: START | $(@get echoed) | END\\"

    # the result is everything after the first occurrence of the separator
    resultString=\\"\${resultString#*$__return_separator}\\"

    # Log \\"resultString: $resultString\\"
    local -a result=$resultString
    # eval \\"local -a result=$resultString\\"
  fi

  unset __self

  # declare -p result
  local assignResult=\\"\${result[0]}\\"

  DEBUG Log \\"Assign Result:\\"
  DEBUG Log \\"START $assignResult END\\"
  # declare -p assignResult

  local typeParam=$(Variable::GetDeclarationFlagFromType $type)

  DEBUG Log \\"Will eval: | $variableName=$assignResult |\\"
  # [[ \\"\${assignResult}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1

  if [[ \\"$typeParam\\" =~ [aA] ]]
  then
    # update the object
    eval \\"$variableName=$assignResult\\"
  else
    ## TODO: use the primitive extension fingerprint here, not in the methods themselves
    # assignResult=\\"$(Type::GetPrimitiveExtensionFingerprint $type):$assignResult\\"
    eval \\"$variableName=\\\\\\"\\\\$assignResult\\\\\\"\\"
  fi

  # update the result
  returnValueDefinition=\\"\${result[1]}\\"
  returnValueType=\\"\${result[2]}\\"

  # Log \\"returned: $returnValueType: $returnValueDefinition\\"

  # switch context for the next command
  if [[ \\"$assignResult\\" != \\"\${returnValueDefinition}\\" ]]
  then
    affectTheInitialVariable=false
    type=\\"$returnValueType\\" # $(Variable::GetPrimitiveTypeFromDeclarationFlag $returnValueType)
  fi

  printf %s \\"$echoed\\"

  ## cleanup vars:
  method=''
  params=()

  # TODO: this should work directly but doesn't
  # eval $variableName=\\\\$assignResult
}

Type::RunGetter() {
  local variableName=\\"$1\\"
  local type=\\"$2\\"

  if Function::Exists \\"$type.__getter__\\"
  then
    __return_self_and_result=false Type::ExecuteMethod \\"$type\\" \\"$variableName\\" \\"__getter__\\"
  else
    @get \\"$variableName\\"
  fi
}

## TODO: private handling should be reimplemented - only this() should be able to access private entries
Type::Handle() {
  local variableName=\\"$1\\"
  local type=$(Type::GetTypeOfVariable \\"\${variableName}\\")
  local affectTheInitialVariable=true
  local -a propertyTree=(\\"$1\\")

  if [[ \\"$type\\" == \\"undefined\\" ]]
  then
    e=\\"No variable named: $variableName\\" throw
    return
  fi

  shift

  local returnValueDefinition
  local returnValueType

  local currentPropertyVisibility=public

  local multiExpression=false

  if [[ \\"$1\\" == ':' ]]
  then
    multiExpression=true
    shift
  fi

  DEBUG subject=\\"type handling\\" Log \\"START ANALYZING: type: $type | variable: $variableName $@\\"
  DEBUG subject=\\"type handling\\" Log \\"WHAT: $(declare -p $variableName)\\"

  # Log multiExpression $multiExpression

  if [[ $# -gt 0 ]]
  then
    local method
    local -a params
    local mode=method
    local prevMode
    local prevModeNext
    local bracketsStarted=false
    local -i closingBracketCount=0

    while [[ $# -gt 0 ]]
    do
      if [[ \\"$__access_private\\" != \\"true\\" && \\"$currentPropertyVisibility\\" == \\"private\\" ]]
      then
        e=\\"Trying to access a private property: $method\\" throw
        return
      fi

      prevModeNext=$mode

      if [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '{' ]]
      then
        if [[ $bracketsStarted == 'true' ]]
        then
          ## handle edge case of '}' as actual parameter
          while (( closingBracketCount+=-1 ))
          do
            params+=( '}' )
          done

          Type::RunCurrentStack
        fi
        bracketsStarted=true
        # mode=params
      elif [[ $multiExpression == 'true' ]] && [[ \\"$1\\" == '}' ]]
      then
        closingBracketCount+=1
        mode=method
        prevModeNext=params
      elif [[ \\"$mode\\" == 'params' ]]
      then
        params+=(\\"$1\\")
      elif [[ \\"$mode\\" == 'method' ]]
      then
        # Log $(@get __\${type}_property_names | array.indexOf $1) $1 idx
        # Log $(@get __\${type}_property_names | array.contains $1 && echo t)

        # Log index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${1})

        local typeSanitized=$(String::SanitizeForVariableName \${type})
        # local typeSanitized=\\"\${type//[^a-zA-Z0-9]/_}\\"

        if Variable::Exists __\${typeSanitized}_property_names &&
            @get __\${typeSanitized}_property_names | __return_self_and_result=false array.contains $1
        then
          # stack now belongs to selected property:
          local property=\\"$1\\"

          DEBUG Log found index __\${type}_property_names $(@get __\${type}_property_names | __return_self_and_result=false array.indexOf \${property})
          # Log prop: $property of [$(@get __\${type}_property_names)]

          ## TODO: theoretically, we could get rid of: __return_self_and_result=false
          local -i index=$(@get __\${typeSanitized}_property_names | __return_self_and_result=false array.indexOf \${property})

          if [[ $index -ge 0 ]]
          then
            DEBUG Log \\"traversing to a child property $property of type $type\\"

            local newType=__\${typeSanitized}_property_types[$index]
            type=\${!newType}
            local typeParam=$(Variable::GetDeclarationFlagFromType $type)

            local currentPropertyVisibilityIndirect=__\${typeSanitized}_property_visibilities[$index]
            currentPropertyVisibility=\${!currentPropertyVisibilityIndirect}

            local propertyValueIndirect=$variableName[$property]

            if [[ -z \\"\${!propertyValueIndirect}\\" && \\"$typeParam\\" =~ [aA] ]]
            then
              local -$typeParam \\"__$property=()\\"
            else
              ## TODO: check if this preserves spaces correctly
              local -$typeParam \\"__$property=\${!propertyValueIndirect}\\"

              if ! Type::IsPrimitive \\"$type\\"
              then
                eval \\"__$property[__object_type]=\\\\\\"\\\\$type\\\\\\"\\"
              fi
            fi

            DEBUG Log \\".$property new $type value is: \\" # \${propertyValueIndirect} vs '\${!propertyValueIndirect}'
            DEBUG Log \\"$(declare -p __$property)\\"
            # affectTheInitialVariable=false

            ## TODO: variableName needs to be unique (add count at the end)
            ## in case the same property is nested
            variableName=__$property

            propertyTree+=(\\"$property\\")

            prevModeNext=property
          fi
          ### /selectProperty
        else
          mode=params
          method=\\"$1\\"
        fi
      fi
      prevMode=$prevModeNext

      DEBUG subject=\\"type handling\\" Log \\"iter: $1 | prevMode: $prevMode | mode: $mode | type: $type | variable: $variableName | method: $method | #params: \${#params[@]}\\"

      shift
    done

    if [[ \\"\${#method}\\" -gt 0 ]]
    then
      # Log 'running stack for:' $variableName
      Type::RunCurrentStack
      # Log 'output was:' \\"\${!variableName}\\"
      ## TODO: this does not work: (false boolean should return fail)
      [[ \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}:false\\" ]] && return 1 # && Log \\"LALALALA\\"
    elif [[ \\"$prevMode\\" == 'property' ]]
    then
      if [[ \\"$currentPropertyVisibility\\" == 'public' || \\"$__access_private\\" == \\"true\\" ]]
      then
        DEBUG subject='property' Log 'print out the property' $variableName
        ## print out the property or run the getter
        Type::RunGetter $variableName $type
      else
        e=\\"Property is private\\" throw
      fi
    fi

    ## TODO: shouldn't this be an elif ?
    # finally echo the latest return value if not empty
    if [[ ! -z \\"$returnValueDefinition\\" ]]
    then
      echo \\"$returnValueDefinition\\"
    fi

    ## UPDATE THE OBJECT RECURSIVELY:
    local -i propertyTreeLength=\${#propertyTree[@]}
    if [[ \${#propertyTree[@]} -gt 1 ]]
    then
      # Log PropertyTree: $(@get propertyTree)
      local -a reversedPropertyTree=$(@get propertyTree | __return_self_and_result=false array.reverse)

      local -i i=$propertyTreeLength
      local property
      local parent
      for parent in \\"\${reversedPropertyTree[@]}\\"
      do
        ## recursively insert the children into parents

        i+=-1
        (( $i == $propertyTreeLength - 1 )) && property=$parent && continue

        local parentVarName=__$parent

        (( $i == 0 )) && parentVarName=$parent

        local propertyDefinition=\\"$(@get __$property)\\"
        # Log \\"Will eval: $parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"
        eval \\"$parentVarName[$property]=\\\\\\"\\\\$propertyDefinition\\\\\\"\\"

        DEBUG Log \\"SETTING: ($i) $parentVarName.$property = \\\\\\"$propertyDefinition\\\\\\"\\"

        property=$parent
      done
    fi
  else
    #@get $variableName
    Type::RunGetter $variableName $type
  fi
}

## TODO: take note of what variables have handler functions in a global variable
## in @resolve:this save the list and then compare it in a @return
## -- or better yet -- to it in the parent that executes the method
## before and after execution

## question - how to add @resolve:this to all methods without explicitly stating it?

## \\"garbage collect\\", i.e. remove all the new references so they don't pollute the global scope

## note: declaration needs to be trimmed,
## since bash adds an enter at the end, hence %?
alias @resolve:this=\\"
  local __local_return_self_and_result=false
  [[ \\\\$__return_self_and_result == 'true' ]] && local __local_return_self_and_result=true && local __return_self_and_result=false
  # TODO: local __access_private_members_of=
  if [[ -z \\\\\${__use_this_transparently+x} ]];
  then
    local __declaration;
    local __declaration_type;

    if [[ ! -z \\\\\\"\\\\\${useReturnValueDefinition}\\\\\\" ]];
    then
      # subject='@resolve:this' Log 'using: ReturnValueDefinition'
      __declaration=\\\\\\"\\\\$returnValueDefinition\\\\\\"
      __declaration_type=\\\\$returnValueType
    elif [[ -z \\\\\${thisReference+x} && ! -t 0 ]];
    then
      # subject='@resolve:this' Log 'using: pipe'
      Pipe::Capture __declaration;
      __declaration_type=\\\\\${FUNCNAME[0]%.*}
      DEBUG Log capturing via pipe \\\\\${__declaration_type}
    else
      # subject='@resolve:this' Log 'using: thisReference:' $ \\\\$thisReference type: \\\\$thisReferenceType
      Variable::ExportDeclarationAndTypeToVariables \\\\$thisReference __declaration;
      __declaration_type=\\\\\\"\\\\$thisReferenceType\\\\\\"
      unset thisReference;
    fi;

    local typeParam=\\\\$(Variable::GetDeclarationFlagFromType \\\\\\"\\\\\${__declaration_type}\\\\\\" '-');
    # subject='@resolve:this' Log \\\\$__declaration_type = \\\\$typeParam = \\\\$__declaration

    # TODO: does it preserve spaces properly?
    local -\\\\$typeParam this=\\\\\${__declaration};

    ## add type for objects that don't have them set explicitly
    if [[ \\\\$typeParam == 'A' && \\\\$__declaration_type != 'map' && -z \\\\\${this[__object_type]+x} ]]
    then
      # Log setting object type
      this[__object_type]=\\\\\\"\\\\$__declaration_type\\\\\\"
    fi

    unset __declaration;
    unset __declaration_type;
  fi
  \\"

# ------------------------ #

import TypePrimitives
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/variable.sh 1`] = `
"import util/command
namespace util/variable

declare __declaration_type ## for Variable::ExportDeclarationAndTypeToVariables (?)

Variable::Exists() {
  local variableName=\\"$1\\"
  declare -p \\"$variableName\\" &> /dev/null
}

Variable::GetAllStartingWith() {
  local startsWith=\\"$1\\"
  compgen -A 'variable' \\"$startsWith\\" || true
}

Variable::GetDeclarationFlagFromType() {
  DEBUG subject=\\"GetParamFromType\\" Log 'getting param from type' \\"$@\\"

  local typeInfo=\\"$1\\"
  local fallback=\\"$2\\"

  if [[ \\"$typeInfo\\" == \\"map\\" ]] || Function::Exists \\"class:\${typeInfo}\\"
  then
    echo A
  else
    case \\"$typeInfo\\" in
      \\"reference\\")
        echo n
      ;;
      \\"array\\")
        echo a
      ;;
      \\"string\\" | \\"boolean\\")
        echo -
      ;;
      \\"integer\\")
        echo i
      ;;
      \\"integerArray\\")
        echo ai
      ;;
      *)
        echo \\"\${fallback:-A}\\"
      ;;
    esac
  fi
}

Variable::GetPrimitiveTypeFromDeclarationFlag() {
  local typeInfo=\\"$1\\"

  case \\"$typeInfo\\" in
    \\"n\\"*)
      echo reference
    ;;
    \\"a\\"*)
      echo array
    ;;
    \\"A\\"*)
      echo map
    ;;
    \\"i\\"*)
      echo integer
    ;;
    \\"ai\\"*)
      echo integerArray
    ;;
    \\"Ai\\"*)
      echo integerMap
    ;;
    *)
      echo string
    ;;
  esac
}

Variable::ExportDeclarationAndTypeToVariables() {
  local variableName=\\"$1\\"
  local targetVariable=\\"$2\\"
  local dereferrence=\\"\${3:-true}\\"

  # TODO: rename for a safer, less common variablename so parents can output to declaration
  local declaration
  local regexArray=\\"declare -([a-zA-Z-]+) $variableName='(.*)'\\"
  local regex=\\"declare -([a-zA-Z-]+) $variableName=\\\\\\"(.*)\\\\\\"\\"
  local regexArrayBash4_4=\\"declare -([a-zA-Z-]+) $variableName=(.*)\\"
  local definition=$(declare -p $variableName 2> /dev/null || true)

  local escaped=\\"'\\\\\\\\\\\\'\\"
  local escapedQuotes='\\\\\\\\\\"'
  local singleQuote='\\"'

  local doubleSlashes='\\\\\\\\\\\\\\\\'
  local singleSlash='\\\\'

  [[ -z \\"$definition\\" ]] && e=\\"Variable $variableName not defined\\" throw

  if [[ \\"$definition\\" =~ $regexArray ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\"
  elif [[ \\"$definition\\" =~ $regex ]]
  then
    declaration=\\"\${BASH_REMATCH[2]//$escaped/}\\" ## TODO: is this transformation needed?
    declaration=\\"\${declaration//$escapedQuotes/$singleQuote}\\"
    declaration=\\"\${declaration//$doubleSlashes/$singleSlash}\\"
  elif [[ \\"$definition\\" =~ $regexArrayBash4_4 ]]
  then
    declaration=\\"\${BASH_REMATCH[2]}\\"
  fi

  local variableType

  DEBUG Log \\"Variable Is $variableName = $definition ==== \${BASH_REMATCH[1]}\\"

  local primitiveType=\${BASH_REMATCH[1]}

  local objectTypeIndirect=\\"$variableName[__object_type]\\"
  if [[ \\"$primitiveType\\" =~ [A] && ! -z \\"\${!objectTypeIndirect}\\" ]]
  then
    DEBUG Log \\"Object Type $variableName[__object_type] = \${!objectTypeIndirect}\\"
    variableType=\\"\${!objectTypeIndirect}\\"
  # elif [[ ! -z \${__primitive_extension_fingerprint__boolean+x} && \\"$primitiveType\\" == '-' && \\"\${!variableName}\\" == \\"\${__primitive_extension_fingerprint__boolean}\\"* ]]
  # then
  #   variableType=\\"boolean\\"
  else
    variableType=\\"$(Variable::GetPrimitiveTypeFromDeclarationFlag \\"$primitiveType\\")\\"
    DEBUG Log \\"Primitive Type $primitiveType Resolved \${variableType}\\"
  fi

  if [[ \\"$variableType\\" == 'string' ]] && Function::Exists 'Type::GetPrimitiveExtensionFromVariable'
  then
    local extensionType=$(Type::GetPrimitiveExtensionFromVariable \\"\${variableName}\\")
    if [[ ! -z \\"$extensionType\\" ]]
    then
      variableType=\\"$extensionType\\"
    fi
  fi

  DEBUG Log \\"Variable $variableName is typeof $variableType\\"

  if [[ \\"$variableType\\" == 'reference' && \\"$dereferrence\\" == 'true' ]]
  then
    local dereferrencedVariableName=\\"$declaration\\"
    Variable::ExportDeclarationAndTypeToVariables \\"$dereferrencedVariableName\\" \\"$targetVariable\\" \\"$dereferrence\\"
  else
    eval \\"$targetVariable=\\\\\\"\\\\$declaration\\\\\\"\\"
    eval \\"\${targetVariable}_type=\\\\$variableType\\"
  fi
}

Variable::PrintDeclaration() {
  local variableName=\\"\${1}\\"
  local dereferrence=\\"\${2:-true}\\"

  local __declaration
  local __declaration_type
  Variable::ExportDeclarationAndTypeToVariables \\"$variableName\\" __declaration \\"$dereferrence\\"
  echo \\"$__declaration\\"
}

alias @get='Variable::PrintDeclaration'
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-config/.gitignore 1`] = `
"/config
/crypto-config
"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-config/configtx.yaml 1`] = `
"################################################################################
#   SECTION: Capabilities
################################################################################
Capabilities:
    Channel: &ChannelCapabilities
        V1_4_3: true
    Orderer: &OrdererCapabilities
        V1_4_2: true
    Application: &ApplicationCapabilities
        V1_4_2: true

################################################################################
#   CHANNEL Defaults
################################################################################
Channel: &ChannelDefaults
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: \\"ANY Readers\\"
        Writers:
            Type: ImplicitMeta
            Rule: \\"ANY Writers\\"
        Admins:
            Type: ImplicitMeta
            Rule: \\"MAJORITY Admins\\"
    Capabilities:
        <<: *ChannelCapabilities

################################################################################
#   Section: Organizations
################################################################################
Organizations:
    - &OrdererOrg
        Name: Orderer
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/root.com/msp 
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.com/msp
        AnchorPeers:
            - Host: peer0.org1.com
              Port: 7051
    - &Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: crypto-config/peerOrganizations/org2.com/msp
        AnchorPeers:
            - Host: peer0.org2.com
              Port: 7051

################################################################################
#   SECTION: Application
################################################################################
Application: &ApplicationDefaults
    Organizations:
    Capabilities:
        <<: *ApplicationCapabilities

################################################################################
#   SECTION: Orderer
################################################################################
Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses: 
        - orderer0.root.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Organizations:

################################################################################
#   Profile
################################################################################
# https://github:com/hyperledger/fabric/blob/master/sampleconfig/configtx.yaml

Profiles:
    SoloOrdererGenesis:
        <<: *ChannelDefaults
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations: 
                    - *Org1
                    - *Org2
    AllOrgChannel:
        <<: *ChannelDefaults
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations: 
                - *Org1
                - *Org2
            Capabilities:
                <<: *ApplicationCapabilities

"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-config/crypto-config-org1.yaml 1`] = `
"PeerOrgs:
  - Name: Org1
    Domain: org1.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-config/crypto-config-org2.yaml 1`] = `
"PeerOrgs:
  - Name: Org2
    Domain: org2.com
    Template:
      Count: 2
    Users:
      Count: 1

"
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabric-config/crypto-config-root.yaml 1`] = `
"OrdererOrgs:
  - Name: Orderer
    Domain: root.com
    Specs: 
      - Hostname: orderer0
    "
`;

exports[`e2e/__tmp__/sample-04 should create proper e2e/__tmp__/sample-04/fabrikkaConfig-2orgs-2channels-1chaincode-tls.json 1`] = `
"{
  \\"fabrikkaVersion\\": \\"alpha-0.0.1\\",
  \\"fileVersion\\": \\"0.1\\",
  \\"networkSettings\\": {
    \\"fabricVersion\\": \\"1.4.3\\",
    \\"tls\\": true
  },
  \\"rootOrg\\": {
    \\"organization\\": {
      \\"key\\": \\"root\\",
      \\"name\\": \\"Orderer\\",
      \\"mspName\\": \\"OrdererMSP\\",
      \\"domain\\": \\"root.com\\"
    },
    \\"ca\\": {
      \\"prefix\\": \\"ca\\"
    },
    \\"orderer\\": {
      \\"prefix\\": \\"orderer\\",
      \\"consensus\\": \\"solo\\",
      \\"instances\\": 1
    }
  },
  \\"orgs\\": [
    {
      \\"organization\\": {
        \\"key\\": \\"org1\\",
        \\"name\\": \\"Org1\\",
        \\"mspName\\": \\"Org1MSP\\",
        \\"domain\\": \\"org1.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    },
    {
      \\"organization\\": {
        \\"key\\": \\"org2\\",
        \\"name\\": \\"Org2\\",
        \\"mspName\\": \\"Org2MSP\\",
        \\"domain\\": \\"org2.com\\"
      },
      \\"ca\\": {
        \\"prefix\\": \\"ca\\"
      },
      \\"peer\\": {
        \\"prefix\\": \\"peer\\",
        \\"instances\\": 2,
        \\"db\\": \\"LevelDb\\"
      }
    }
  ],
  \\"channels\\": [
    {
      \\"key\\": \\"channel1\\",
      \\"name\\": \\"my-channel1\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer0\\"
          ]
        }
      ]
    },
    {
      \\"key\\": \\"channel2\\",
      \\"name\\": \\"my-channel2\\",
      \\"orgs\\": [
        {
          \\"key\\": \\"org1\\",
          \\"peers\\": [
            \\"peer1\\"
          ]
        },
        {
          \\"key\\": \\"org2\\",
          \\"peers\\": [
            \\"peer1\\"
          ]
        }
      ]
    }
  ],
  \\"chaincodes\\": [
    {
      \\"name\\": \\"chaincode1\\",
      \\"version\\": \\"0.0.1\\",
      \\"lang\\": \\"java\\",
      \\"channel\\": \\"channel1\\",
      \\"init\\": \\"{'Args':[]}\\",
      \\"endorsement\\": \\"AND ('Org1.member')\\",
      \\"directory\\": \\"chaincode1\\"
    }
  ]
}
"
`;

exports[`e2e/__tmp__/sample-04 should create proper files 1`] = `
Array [
  "e2e/__tmp__/sample-04/fabric-compose.sh",
  "e2e/__tmp__/sample-04/fabric-compose/.env",
  "e2e/__tmp__/sample-04/fabric-compose/commands-generated.sh",
  "e2e/__tmp__/sample-04/fabric-compose/docker-compose.yaml",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/base-functions.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/base-help.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/cli/channel_fns.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Contains.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Intersect.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/List.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/Array/Reverse.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/GetSpaces.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/IsNumber.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/SanitizeForVariable.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/SlashReplacement.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/String/UUID.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Color.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Color.var.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Console.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/UI/Cursor.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/oo-bootstrap.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/bash4.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/class.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/command.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/exception.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/exits.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/log.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/namedParameters.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/pipe.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/test.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/tryCatch.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/type.sh",
  "e2e/__tmp__/sample-04/fabric-compose/scripts/lib/util/variable.sh",
  "e2e/__tmp__/sample-04/fabric-config/.gitignore",
  "e2e/__tmp__/sample-04/fabric-config/configtx.yaml",
  "e2e/__tmp__/sample-04/fabric-config/crypto-config-org1.yaml",
  "e2e/__tmp__/sample-04/fabric-config/crypto-config-org2.yaml",
  "e2e/__tmp__/sample-04/fabric-config/crypto-config-root.yaml",
  "e2e/__tmp__/sample-04/fabrikkaConfig-2orgs-2channels-1chaincode-tls.json",
]
`;
